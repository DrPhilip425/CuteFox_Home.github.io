<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android6.0的旧手机玩Termux</title>
      <link href="/CuteFox_Home.github.io/2023/10/31/Android6-0%E7%9A%84%E6%97%A7%E6%89%8B%E6%9C%BA%E7%8E%A9Termux/"/>
      <url>/CuteFox_Home.github.io/2023/10/31/Android6-0%E7%9A%84%E6%97%A7%E6%89%8B%E6%9C%BA%E7%8E%A9Termux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.旧手机安装Termux软件</h1><blockquote><p>因为我用的是旧手机，<strong>Android版本为6.0且没有被root</strong>，所以我选用<em>Termux</em>来模拟<em>Linux环境</em></p></blockquote><p>termux官方的github-actions里给了适合Android5.0和6.0版本的<a href="https://github.com/termux/termux-app/actions/workflows/debug_build.yml?query=branch%3Amaster+event%3Apush">应用压缩包</a><br>我是用的是<a href="https://github.com/termux/termux-app/suites/17389451010/artifacts/993775523">0.118.0通用版的termux</a>，解压缩后就可以得到相应版本的termux安装包</p><h1>2.查看termux官方源给的可以安装的包</h1><pre><code class="language-bash">pkg list-all</code></pre><p>在某个包后面如果出现了<em>installed</em>，则说明这个包<strong>已经被安装了</strong>；第一步先查看官方源给的包的原因是当我们使用命令<code>pkg install 某个package</code>来安装<strong>某个包</strong>时，如果出现了<code>Unable to locate package 某个package</code>，是因为你想安装的<strong>这个包</strong>不在官方给的源里，需要另外去添加<strong>别人的源</strong></p><h1>3.添加源或更换源</h1><pre><code class="language-bash">pkg install vim</code></pre><p>首先得安装<em>vim</em>这个文字编辑器，我这里用的是vim，不会vim语法的可以自行搜索</p><pre><code class="language-bash">pkg install nano</code></pre><p>或者安装<em>nano</em>这个文字编辑器，看自己哪个可以安装或者哪个熟悉就用哪个</p><pre><code class="language-bash">vim $PREFIX/etc/apt/sources.list</code></pre><p>进入官方的源文件，在<em>手机输入法键盘</em>按<code>i</code>即可进入<em>编辑模式</em>，你可以在官方源前面加上<code>#</code>来注释保留，也可以删掉换成其他的源比如换成<em>清华源</em><code>deb https://mirrors.tuna.tsinghua.edu.cn/termux/termux-packages-24 stable main</code>，当然也可以换成其他的源，这个可以自行搜索；<br>更改完成后，先在termux的<em>虚拟键盘</em>上按<code>ESC</code>进入<em>命令模式</em>，再在<em>手机输入法键盘</em>上依次输入<code>:wq</code>即可<strong>保存并退出</strong>vim</p><pre><code class="language-bash">vim $PREFIX/etc/apt/sources.list.d/science.list</code></pre><p><code>science.list</code>也和上面的<code>sources.list</code>差不多，可以换成清华源<code>deb https://mirrors.tuna.tsinghua.edu.cn/termux/science-packages-24 science stable</code>，再保存并退出</p><pre><code class="language-bash">vim $PREFIX/etc/apt/sources.list.d/game.list</code></pre><p><code>game.list</code>也可以换成清华源<code>deb https://mirrors.tuna.tsinghua.edu.cn/termux/game-packages-24 games stable</code>，再保存并退出</p><blockquote><p>因为我在清华源和中科大的源里找不到一些termux官方源有的包，所以我没有更换源，就用的官方源，如果官方源安装不了包可能是网络问题，需要科学上网</p></blockquote><h1>4.给termux更换配色</h1><pre><code class="language-bash">termux-setup-storage #先得让termux获取手机存储权限pkg install curl</code></pre><p>首先安装<code>curl</code>以执行下面命令</p><pre><code class="language-bash">sh -c "$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)" </code></pre><p>然后这个命令会打开一个脚本，这个脚本先会弹出<code>Enter a number, leave blank to not to change: </code>，可以输入数字<code>0-43</code>来选择你想要的<code>色彩</code>，你也可以在全部选择完成后，重新在termux中输入<code>chcolor</code>，它会列出具体的<code>0-43</code>这44种<code>色彩</code>；<br>接着又会出现一个<code>Enter a number, leave blank to not to change: </code>，也可以输入数字<code>0-26</code>来选择你想要的<code>字体</code>，你也可以在全部选择完成后，重新在termux中输入<code>chfont</code>，它会列出具体的<code>0-26</code>这27种<code>字体</code></p><h1>5.给termux更改启动问候语</h1><pre><code class="language-bash">vim $PREFIX/etc/motd</code></pre><p>依旧输入<code>i</code>进行编辑，例如你可以复制粘贴国光大佬的</p><pre><code> _____                              |_   _|__ _ __ _ __ ___  _   ___  __  | |/ _ \ '__| '_ ` _ \| | | \ \/ /  | |  __/ |  | | | | | | |_| |&gt;  &lt;   |_|\___|_|  |_| |_| |_|\__,_/_/\_\</code></pre><p>也可以试试我的，然后保存退出后重进termux就可以了</p><pre><code>      /\     __       ~~  ____   ____     //\\    ||       ||   ||   / __ \    //——\\   ||____   ||   ||  | \__\ \   //    \\  |_____|  ||   ||   \____/\\    </code></pre><h1>6.安装编译环境</h1><h2 id="6-1安装Clang">6.1安装Clang</h2><pre><code class="language-bash">pkg install clang</code></pre><p>安装完clang后就能在termux写<em>C和C++语言</em>，例如</p><pre><code class="language-bash">vim hello.c</code></pre><pre><code class="language-C">#include&lt;stdio.h&gt;  int main(){    printf("Hello friends!");    return 0;}</code></pre><p>先创建一个<em>C语言的文件</em>，再写入上面内容并保存退出</p><pre><code class="language-bash">clang hello.c -o hellols</code></pre><p>然后编译这个C语言文件并列出当前目录的文件有哪些，输入<code>ls</code>后你就可以看到有一个<code>hello</code>的文件</p><pre><code class="language-bash">./hello</code></pre><p>这样就能运行编译后的hello文件，然后你会看见<code>Hello friends!</code>输出在屏幕上了</p><h2 id="6-2安装python">6.2安装python</h2><pre><code class="language-bash">pkg install python -ypython -V #查看python的版本</code></pre><p>这里默认安装的是<em>python3</em>而不是<em>python2</em>，如果需要安装<em>python2</em>，则输入下面即可</p><pre><code class="language-bash">pkg install python2 -y</code></pre><h2 id="6-3安装nodejs">6.3安装nodejs</h2><pre><code class="language-bash">pkg install nodejs-lts #lts为长期支持版本</code></pre><blockquote><p>注意别用<code>pkg install nodejs</code>，不然你会发现你用<code>npm</code>的时候下不了一些<code>node_modules</code>；如果安装了就<code>pkg uninstall nodejs</code>，再重新安装<code>nodejs-lts</code></p></blockquote><h2 id="6-4安装http-server">6.4安装http-server</h2><pre><code class="language-bash">npm install -g http-server</code></pre><p>然后运行<code>http-server</code></p><pre><code class="language-bash">http-server</code></pre><p>你可以看到它给出了一个<code>http:127.0.0.1:8080</code>的<em>url</em>，然后你用手机的浏览器访问这个<em>url</em>就能看到你<em>termux的文件夹</em>的内容了；接着在<em>termux</em>中按一下<em>虚拟键盘</em>上的<code>CTRL</code>和你<em>手机输入法键盘</em>上的<code>c</code>即可退出</p><h2 id="6-5安装MariaDB-MySQL">6.5安装MariaDB(MySQL)</h2><pre><code class="language-bash">pkg install mariadbmysql --version #查看mysql版本</code></pre><pre><code class="language-bash">nohup mysqld &amp; #用Linux自带的nohup启动</code></pre><p>mysql安装好就能启动，<strong>不需要</strong>初始化！能启动成功说明mysql已经安装好了</p><pre><code class="language-bash">kill -9 `pgrep mysql` #关掉mysql的进程</code></pre><h1>7.安装Aria2来下载东西</h1><h2 id="7-1安装aria2">7.1安装aria2</h2><pre><code class="language-bash">pkg install aria2aria2c -v #查看aria2的版本</code></pre><blockquote><p>要注意的是<em>aria2</em>的命令是<code>aria2c</code>而不是<code>aria2</code></p></blockquote><h2 id="7-2创建aria2的配置文件、数据文件和日志文件">7.2创建aria2的配置文件、数据文件和日志文件</h2><pre><code class="language-bash">touch aria2.conf #配置文件touch aria2.session #数据文件touch aria2.log #日志文件</code></pre><h3 id="7-2-1自定义aria2的配置文件">7.2.1自定义aria2的配置文件</h3><pre><code class="language-bash">readlink -f aria2.session #获取aria2.session文件的完整路径，并记下来readlink -f aria2.log #获取aria2.log文件的完整路径，并记下来readlink -f aria2.conf #获取aria2.conf文件的完整路径，并记下来</code></pre><p>上面两个文件<code>aria2.session</code>和<code>aria2.log</code>的路径要记住，因为后面配置<code>aria2.conf</code>的时候需要用到</p><pre><code class="language-bash">vim aria2.conf</code></pre><p>进入我们之前新建的<code>aria2.conf</code>文件，复制粘贴下面的内容</p><pre><code>##===================================#### 文件保存相关 ####===================================### 文件保存目录dir=[下载文件夹位置]# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16Mdisk-cache=16M# 断点续传continue=true#日志保存log=[日志文件位置/aria2.log]# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项file-allocation=prealloc##===================================#### 下载连接相关 ####===================================### 最大同时下载任务数, 运行时可修改, 默认:5max-concurrent-downloads=10# 同一服务器连接数, 添加时可指定, 默认:1# 官方的aria2最高设置为16, 如果需要设置任意数值请重新编译aria2max-connection-per-server=16# 整体下载速度限制, 运行时可修改, 默认:0（不限制）max-overall-download-limit=0# 单个任务下载速度限制, 默认:0（不限制）max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0（不限制）max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0（不限制）max-upload-limit=0# 禁用IPv6, 默认:falsedisable-ipv6=false# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5# 建议同max-connection-per-server设置为相同值split=16##===================================#### 进度保存相关 ####===================================### 从会话文件中读取下载任务input-file=[数据文件保存位置/aria2.session]# 在Aria2退出时保存错误的、未完成的下载任务到会话文件save-session=[数据文件保存位置/aria2.session]# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0save-session-interval=60##===================================#### RPC相关设置 ####此部分必须启用，否则无法使用WebUI##===================================### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许外部访问, 默认:falserpc-listen-all=true# RPC端口, 仅当默认端口被占用时修改rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=# 启动SSL# rpc-secure=true# 证书文件, 如果启用SSL则需要配置证书文件, 例如用https连接aria2# rpc-certificate=# rpc-private-key=##===================================#### BT/PT下载相关 ####===================================### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:truefollow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=true# 打开IPv6 DHT功能, PT需要禁用enable-dht6=true# DHT网络监听端口, 默认:6881-6999dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:falsebt-enable-lpd=true# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=true# 每个种子限速, 对少种的PT很有用, 默认:50Kbt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件force-save=true# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true# 单个种子最大连接数, 默认:55 0表示不限制bt-max-peers=0# 最小做种时间, 单位:分# seed-time = 60# 分离做种任务bt-detach-seed-only=true#BT Tracker List ;下载地址：https://cdn.jsdelivr.net/gh/XIU2/TrackersListCollection/best_aria2.txt#页面地址：https://github.com/XIU2/TrackersListCollection/blob/master/README-ZH.mdbt-tracker=http://all4nothin.net:80/announce.php,http://kinorun.com:80/announce.php,http://masters-tb.com:80/announce.php,http://mediaclub.tv:80/announce.php,http://milanesitracker.tekcities.com:80/announce,http://nyaa.tracker.wf:7777/announce,http://open.acgnxtracker.com:80/announce,http://openbittorrent.com:80/announce,http://opentracker.xyz:80/announce,http://share.camoe.cn:8080/announce,http://t.nyaatracker.com:80/announce,http://torrent-team.net:80/announce.php,http://torrentzilla.org:80/announce,http://torrentzilla.org:80/announce.php,http://tr.cili001.com:8070/announce,http://tracker.files.fm:6969/announce,http://tracker.gbitt.info:80/announce,http://tracker.ipv6tracker.ru:80/announce,http://tracker.tfile.me:80/announce,http://tracker.torrentyorg.pl:80/announce,http://vps02.net.orel.ru:80/announce,http://www.all4nothin.net:80/announce.php,https://1337.abcvg.info:443/announce,https://carbon-bonsai-621.appspot.com:443/announce,https://tr.ready4.icu:443/announce,https://tr.torland.ga:443/announce,https://tracker.imgoingto.icu:443/announce,https://tracker.kuroy.me:443/announce,https://tracker.lilithraws.cf:443/announce,https://tracker.nitrix.me:443/announce,https://tracker.parrotsec.org:443/announce,https://tracker.tamersunion.org:443/announce,https://trackme.theom.nz:443/announce,udp://9.rarbg.com:2810/announce,udp://abufinzio.monocul.us:6969/announce,udp://bt1.archive.org:6969/announce,udp://bt2.archive.org:6969/announce,udp://code2chicken.nl:6969/announce,udp://discord.heihachi.pw:6969/announce,udp://engplus.ru:6969/announce,udp://escorts.subventas.com:53/announce,udp://exodus.desync.com:6969/announce,udp://fe.dealclub.de:6969/announce,udp://ipv6.tracker.monitorit4.me:6969/announce,udp://ipv6.tracker.zerobytes.xyz:16661/announce,udp://jeremylee.sh:6969/announce,udp://mail.realliferpg.de:6969/announce,udp://movies.zsw.ca:6969/announce,udp://open.demonii.com:1337/announce,udp://open.tracker.cl:1337/announce,udp://opentor.org:2710/announce,udp://p4p.arenabg.com:1337/announce,udp://retracker.hotplug.ru:2710/announce,udp://thetracker.org:80/announce,udp://tracker-de.ololosh.space:6969/announce,udp://tracker.0x.tf:6969/announce,udp://tracker.altrosky.nl:6969/announce,udp://tracker.auctor.tv:6969/announce,udp://tracker.beeimg.com:6969/announce,udp://tracker.birkenwald.de:6969/announce,udp://tracker.bitsearch.to:1337/announce,udp://tracker.blacksparrowmedia.net:6969/announce,udp://tracker.dler.com:6969/announce,udp://tracker.haynet.io:6969/announce,udp://tracker.jordan.im:6969/announce,udp://tracker.leech.ie:1337/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.monitorit4.me:6969/announce,udp://tracker.ololosh.space:6969/announce,udp://tracker.openbittorrent.com:6969/announce,udp://tracker.opentrackr.org:1337/announce,udp://tracker.pomf.se:80/announce,udp://tracker.theoks.net:6969/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.zerobytes.xyz:1337/announce,udp://tracker0.ufibox.com:6969/announce,udp://tracker1.bt.moack.co.kr:80/announce,udp://tracker2.dler.com:80/announce,udp://tracker2.dler.org:80/announce,udp://u.wwwww.wtf:1/announce,udp://udp-tracker.shittyurl.org:6969/announce,udp://vibe.sleepyinternetfun.xyz:1738/announce,udp://www.torrent.eu.org:451/announce,wss://tracker.openwebtorrent.com:443/announce</code></pre><p>修改上面的<code>[下载文件夹位置]</code>，去掉<code>[]</code>把它换成由<code>/</code>组成的你想放在安卓内存中的位置如<code>/storage/emulated/0/Dowmload</code>；修改<code>[日志文件位置/aria2.log]</code>，去掉<code>[]</code>把它换成由<code>/</code>组成的刚刚获取的<code>touch aria2.log</code>文件的完整路径；修改<code>[数据文件保存位置/aria2.session]</code>，去掉<code>[]</code>把它换成由<code>/</code>组成的刚刚获取的<code>aria2.session</code>文件的完整路径；然后保存并退出</p><h2 id="7-3启动aria2的rpc服务">7.3启动aria2的rpc服务</h2><pre><code class="language-bash">aria2c --conf-path=[aria2.conf文件路径/aria2.conf] #注意要删除[]，aria2.conf文件路径为我们刚刚获取的路径</code></pre><p>启动aria2的rpc服务后termux可能输入不了命令了，这时可以选择<strong>从左边向右滑动屏幕</strong>新建一个<em>termux会话窗口</em>或直接退出termux</p><h3 id="7-3-1把aria2的rpc服务放入后台启动">7.3.1把aria2的rpc服务放入后台启动</h3><pre><code class="language-bash">aria2c --conf-path=[aria2.conf文件路径/aria2.conf] -D #在启动aria2的基础上加一个-D即可</code></pre><h3 id="7-3-2实现打开termux后其后台自动启动aria2的rpc服务">7.3.2实现打开termux后其后台自动启动aria2的rpc服务</h3><pre><code class="language-bash">readlink -f .zshrc #获取.zshrc文件的完整路径vim /data/data/com.termux/files/home/.zshrc #打开.zshrc文件，/data/data/com.termux/files/home路径用你刚刚获取的，我的路径是这样的:/data/data/com.termux/files/home</code></pre><p>用vim打开<code>.zshrc</code>文件后，添加下面内容到最后一行，然后保存并退出</p><pre><code>aria2c --conf-path=[aria2.conf文件路径/aria2.conf] -D</code></pre><h3 id="7-3-3自定义短命令后台启动aria2的rpc服务">7.3.3自定义短命令后台启动aria2的rpc服务</h3><p>和上面一样打开<code>.zshrc</code>文件，把下面内容添加到刚刚添加的那行的上一行即<strong>倒数第二行</strong></p><pre><code>alias aria2c-s='aria2c --conf-path=[aria2.conf文件路径/aria2.conf] -D' </code></pre><p>上面的<code>aria2c-s</code>可以<strong>自定义</strong>要后台启动aria2的rpc服务的<em>短命令</em>，我改成的是<code>aria2c-s</code></p><h2 id="7-4安装并启动webui-aria2本地管理服务器">7.4安装并启动webui-aria2本地管理服务器</h2><h3 id="7-4-1安装git">7.4.1安装git</h3><pre><code class="language-bash">pkg install git</code></pre><h3 id="7-4-2克隆webui-aria2项目">7.4.2克隆webui-aria2项目</h3><pre><code class="language-bash">git clone https://github.com/ziahamza/webui-aria2.git</code></pre><h3 id="7-4-3启动webui-aria2本地管理服务器">7.4.3启动webui-aria2本地管理服务器</h3><pre><code class="language-bash">cd webui-aria2 #进入webui-aria2文件夹node node-server.js #启动webui-aria2</code></pre><p>启动<code>webui-aria2</code>完成后会看到termux已提示有<code>localhost:8888</code>了，然后我们打开浏览器输入<code>127.0.0.1:8888</code>即可看到<code>webui-aria2的本地管理服务器GUI</code></p><h2 id="7-5把aria2作为服务器来下载内容">7.5把aria2作为服务器来下载内容</h2><blockquote><p>因为本人没有申请<code>公网IP</code>，所以只能借助<code>内网穿透</code>试试看了，我目前只试了<code>cpolar</code>这个内网穿透的服务，因为可以直接在termux上操作（比较方便）；但还是可以去试试其他延迟比较低的内网穿透服务，我个人就不在这里推荐了，因为免费的服务它的延迟可能都那样（确信</p></blockquote><h3 id="7-5-1创建sources-list-d文件夹">7.5.1创建sources.list.d文件夹</h3><pre><code class="language-bash">mkdir -p $PREFIX/etc/apt/sources.list.d</code></pre><h3 id="7-5-2添加cpolar源">7.5.2添加cpolar源</h3><pre><code class="language-bash">echo "deb [trusted=yes] http://termux.cpolar.com termux extras" &gt;&gt; $PREFIX/etc/apt/sources.list.d/cpolar.list</code></pre><h3 id="7-5-3更新库">7.5.3更新库</h3><pre><code class="language-bash">pkg update</code></pre><h3 id="7-5-4安装cpolar">7.5.4安装cpolar</h3><pre><code class="language-bash">pkg install cpolar</code></pre><h3 id="7-5-5安装termux服务">7.5.5安装termux服务</h3><pre><code class="language-bash">pkg install termux-services</code></pre><blockquote><p>安装完termux服务后记得退出termux重新进一次才能生效</p></blockquote><h3 id="7-5-6启动和关闭cpolar服务">7.5.6启动和关闭cpolar服务</h3><pre><code class="language-bash">sv up cpolar #启动sv down cpolar #关闭</code></pre><h3 id="7-5-7设置开机自启cpolar服务">7.5.7设置开机自启cpolar服务</h3><pre><code class="language-bash">sv-enable cpolar</code></pre><h3 id="7-5-8进入cpolar的GUI界面">7.5.8进入cpolar的GUI界面</h3><p>在浏览器中输入<code>127.0.0.1:9200</code>即可打开该页面，打开后会有一个登录界面，用邮箱去<strong>注册</strong>一个新的账户，然后选择<strong>免费的套餐</strong>就可以用cpolar的内网穿透服务了</p><h3 id="7-5-9创建8888端口的隧道">7.5.9创建8888端口的隧道</h3><p>①点击cpolar的GUI界面左边导航栏的<code>隧道管理</code>，然后选择<code>创建隧道</code>；<br>②<code>隧道名字</code>任意取即可；<br>③<code>协议</code>选择<code>http</code>；<br>④<code>本地地址</code>填入<code>8888</code>（也就是我们<code>webui-aria2的本地管理服务器GUI</code>的端口号）；<br>⑤然后<code>域名类型</code>选择<code>随机域名</code>（如果自己有多的域名也好像可以选择自定义域名，不过我没试过；选这个<code>随机域名</code>有个<strong>缺点</strong>，就是说你创建的这个<code>公网隧道链接</code>可能过了一段时间就用不了，得重新刷新这个界面才会显示新的<code>公网隧道链接</code>）；<br>⑥<code>地区</code>选择<code>China Top</code>就好了，因为选其他的的话，如果没有开会员，可能用不了或延时比较高<br>⑦点击<code>创建</code>即可</p><h3 id="7-5-10查找公网隧道链接">7.5.10查找公网隧道链接</h3><p>点击cpolar的GUI界面左边导航栏的<code>状态</code>，然后选择<code>在线隧道列表</code>，在右边列表的<code>公网地址</code>那一列即可看到以<code>http</code>和<code>https</code>开头的就是我们<code>webui-aria2的本地管理服务器GUI</code>的<code>公网隧道链接</code>了</p><h3 id="7-5-11通过其他设备访问公网隧道链接">7.5.11通过其他设备访问公网隧道链接</h3><p>打开其他设备的浏览器，输入刚刚创建的<code>公网隧道链接</code>即可（虽然但是，内网穿透服务的延迟太高效果可能也不好；还有值得注意的一点是，<code>安装termux本机</code>的<code>8888</code>端口<strong>只是</strong><code>aria2</code>的<code>GUI界面</code>，还要确保<code>aria2</code>的<code>rpc</code>服务能够连上才能通过其他设备远程使用<code>安装termux本机</code>上的<code>aria2</code>来下载东西）</p><h1>8.安装kali-nethunter系统</h1><h2 id="8-1安装wget">8.1安装wget</h2><pre><code class="language-bash">pkg install wget</code></pre><h2 id="8-2安装kali官网的脚本">8.2安装kali官网的脚本</h2><pre><code class="language-bash">wget -O install-nethunter-termux https://offs.ec/2MceZWr</code></pre><h2 id="8-3给kali脚本执行权限并运行">8.3给kali脚本执行权限并运行</h2><pre><code class="language-bash">chmod +x install-nethunter-termux ./install-nethunter-termux</code></pre><p>安装完成后会有<code>kali的图标</code>和<code>命令行提示</code>出现，输入<code>nh</code>即可打开<code>kali-nethunter的终端</code>，输入<code>exit</code>即可退出</p><blockquote><p>安装过程有点漫长，毕竟超过1GB了，如果像我一样安装<code>原版kali</code>且手机<code>没有被root</code>可能会遇到它一直在<code>extracting rootfs</code>即<code>提取root文件</code>，那得继续等，直到它提取失败后，问是否要重试，我直接选的否，因为我实在不想折腾刷机这块了；如果手机已经被root了，那应该畅通无阻，除非不会科学上网</p></blockquote><h2 id="8-4开启kex-VNC-服务进行远程连接kali桌面">8.4开启kex(VNC)服务进行远程连接kali桌面</h2><h3 id="8-4-1创建连接密码">8.4.1创建连接密码</h3><pre><code class="language-bash">nh kex passwd</code></pre><p>然后会弹出提示输入一次，再验证输入一次即可</p><h3 id="8-4-2下载远程连接软件–VNC-Viewer或NetHunter-KeX">8.4.2下载远程连接软件–VNC Viewer或NetHunter KeX</h3><ul><li><a href="https://www.realvnc.com/en/connect/download/viewer/">VNC-Viewer</a></li><li><a href="https://store.nethunter.com/en/packages/com.offsec.nethunter.kex/">NetHunter KeX</a></li></ul><h3 id="8-4-3启动kex服务">8.4.3启动kex服务</h3><pre><code class="language-bash">nh kex &amp;</code></pre><p>启动后会开启<code>5901端口</code></p><blockquote><p>可能会有警告<code>no matching vnc server running for this user</code>，但好像可以正常使用，因为我安装了<code>nmap</code>，用<code>nmap 127.0.0.1</code>扫描主机号后发现确实有<code>5901端口</code></p></blockquote><h3 id="8-4-4用远程连接软件连接5901端口">8.4.4用远程连接软件连接5901端口</h3><p>打开<code>VNC Viewer</code>或<code>NetHunter KeX</code>，在<em>主机地址</em>那填上<code>127.0.0.1</code>，<em>端口号</em>填<code>5901</code>，<code>VNC Viewer</code>连接后还需要输入刚刚在termux创建连接时的密码，而<code>NetHunter KeX</code>则是<em>主机地址和端口号以及密码</em>都要填才能连接</p><blockquote><p>如果你和我一样在这出现了<strong>连接上了</strong>但只有<em>报错提示</em>的话，可以参考下<a href="https://bbs.x10001.com/forum-post/1534.html">这篇文章</a>，虽然我没成功，因为termux的官方源里没有<code>rinetd</code>这个包</p></blockquote><h1>9.安装Ubuntu或其他Linux发行版</h1><blockquote><p>直接用上国光大佬写的脚本</p></blockquote><h2 id="9-1安装proot来模拟root">9.1安装proot来模拟root</h2><pre><code class="language-bash">pkg install proot</code></pre><h2 id="9-2克隆Linux发行版安装脚本项目">9.2克隆Linux发行版安装脚本项目</h2><pre><code class="language-bash">git clone https://github.com/sqlsec/termux-install-linux</code></pre><h2 id="9-3运行Linux发行版安装脚本">9.3运行Linux发行版安装脚本</h2><pre><code class="language-bash">cd termux-install-linux python termux-linux-install.py</code></pre><p>直接选择数字安装或卸载想要安装的Linux发行版即可，这点毫无压力</p><h2 id="9-4启动Ubuntu终端">9.4启动Ubuntu终端</h2><pre><code class="language-bash">cd ~/Termux-Linux/Ubuntu./start-ubuntu.sh</code></pre><p>输入<code>exit</code>即可退出<code>Ubuntu终端</code></p><h1>10.通过SSH用电脑连接手机的termux</h1><h2 id="10-1查看自己的IP地址">10.1查看自己的IP地址</h2><pre><code class="language-bash">ifconfig </code></pre><p>在<code>wlan0</code>下面，以<code>192.168</code>开头的就是自己的IP地址，然后记下来</p><h2 id="10-2查看自己的用户名">10.2查看自己的用户名</h2><pre><code class="language-bash">whoami</code></pre><p><code>u0_</code>开头的这个就是，也记下来</p><h2 id="10-3安装openSSH">10.3安装openSSH</h2><pre><code class="language-bash">pkg install opensshpasswd</code></pre><p>安装完成后输入<code>passwd</code>，填写两次连接时的密码</p><h2 id="10-4安装nmap">10.4安装nmap</h2><pre><code class="language-bash">pkg install nmap</code></pre><h2 id="10-5电脑上安装xshell">10.5电脑上安装xshell</h2><ul><li><a href="https://www.netsarang.com/zh/xshell/">xshell</a></li></ul><h2 id="10-6手机上termux开启ssh">10.6手机上termux开启ssh</h2><pre><code class="language-bash">sshd</code></pre><h2 id="10-7电脑xshell连接手机termux">10.7电脑xshell连接手机termux</h2><p>在xshell左上角点击<em>新建会话</em>的图标，主机号输入之前查询的自己的IP地址，端口号填<code>8022</code>，之后会弹出验证用户名，输入之前查询的用户名即可，完成后就能在电脑上敲命令执行termux的任务了！</p><hr><br><blockquote><p>参考资料1：<a href="https://www.sqlsec.com/2018/05/termux.html">Termux 高级终端安装使用配置教程</a><br>参考资料2：<a href="https://www.bilibili.com/read/cv14084579/">优雅地使用完美版Termux-Aria2服务器（带本地GUI管理）以及ipv6的公网访问</a><br>参考资料3：<a href="https://blog.csdn.net/weixin_42599499/article/details/111185609">Termux的安装、换源、基本库安装、基本操作讲解以及Termux的使用心得</a><br>参考资料4：<a href="https://www.cpolar.com/blog/install-mysql-on-android-termux-and-use-cpolar-for-secure-remote-access">Android Termux安装MySQL，内网穿透实现公网远程访问</a></p></blockquote><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Termux </tag>
            
            <tag> Aria2 </tag>
            
            <tag> Kali-Nethunter </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 电脑SSH远程手机 </tag>
            
            <tag> cpolar </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/10/06/Java%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/10/06/Java%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.基本结构</h1><br><h2 id="1-1文件名与类名">1.1文件名与类名</h2><pre><code class="language-Java">public class HelloWorld{    public static void main(String[] args){        System.out.println("hello,world!你好，世界！");    }}</code></pre><p>①<code>public class 类名</code>这个<code>public</code>只能有<strong>一个</strong><br>②<code>文件名.java</code>这个<em>文件名</em>要和<code>public class 类名</code>的<em>类名</em><strong>一样</strong>；就如上面代码中<em>类名</em>是<code>HelloWorld</code>，则该<code>.java</code>文件的<em>文件名</em>也必须是<code>HelloWorld</code></p><br><h2 id="1-2main程序执行的入口">1.2<code>main</code>程序执行的入口</h2><pre><code class="language-Java">public class HelloWorld{    public static void main(String[] args){        System.out.println("hello,world!你好，世界！");    }}class HelloChina{    public static void main(String a[]){        System.out.println("hello,world!你好，中国！");    }}</code></pre><p>①<code>public static void main(String[] args)</code>是一个<strong>可执行的</strong>Java程序<strong>必须</strong>有的，因为它是执行语句的<strong>入口</strong><br>②<code>public static void main(String[] args)</code>其中的<code>String[] args</code>可以写成<code>String arg[]</code>，<code>arg</code>也可以改成<strong>任意</strong>可表示<strong>数组</strong>的符号如<code>a</code>等；有<code>public</code>是因为它<strong>权限最大</strong>，有<code>static</code>是因为它<strong>与类相关</strong>，有<code>void</code>是因为它<strong>在栈帧最底部</strong>不需要返回值<br>③<strong>一个</strong>Java程序里可以有多个<code>main</code></p><br><h1>2.输出与输入</h1><br><h2 id="2-1输出">2.1输出</h2><pre><code class="language-Java">public class PrintTest{    public static void main(String[] args){    System.out.print(); //只输出，不换行    System.out.print(""+"\n"); //先输出后换行    System.out.println(); //先输出后换行    System.out.println("abc123"); //双引号里写字符串    System.out.println(123+4); //整数直接计算    System.out.println(0.1+0.2); //输出不是0.3，而是0.30000000000000004，因为现代编译器基本采用IEEE 754标准，所以不能实现每一个十进制小数对应一个二进制小数    System.out.println("Stu"+"dent"); //+(加号)为连接符    int a=1;    int b=1;    System.out.println(a==b); //==(连等号)为判断是否相等的符号    }}</code></pre><br><h2 id="2-2输入">2.2输入</h2><pre><code class="language-Java">import java.util.Scanner; //导入Java的util包里的Scanner类public class ScanTest{    public static void main(String[] args){        Scanner n=new Scanner(System.in); //创建Scanner类型的对象n，并使n能够获取控制台输入的功能即Scanner(System.in)        String name=n.next(); //创建String类型的对象name，把对象n的next()方法赋值给name，并开始输入name的值        System.out.println("name:"+name); //输出刚刚输入的name    }}</code></pre><br><h1>3.基本数据类型</h1><br><h2 id="3-1-byte">3.1 byte</h2><pre><code class="language-Java">{    byte b1=-128;    byte b2=127;    System.out.println(b1+"\n"+b2);}</code></pre><p>①<em>byte</em>类型的<strong>范围</strong>是<code>-128~127</code>(即<code>-2^7~2^7-1</code>)<br>②<strong>1</strong>个<em>byte</em>占<strong>1</strong>个字节(<code>Byte</code>)，<strong>8</strong>位(<code>bit</code>)</p><br><h2 id="3-2-short">3.2 short</h2><pre><code class="language-Java">{    short s1=-32768;    short s2=32767;    System.out.println(s1+"\n"+s2);}</code></pre><p>①<em>short</em>类型的<strong>范围</strong>是<code>-32768~32767</code>(即<code>-2^15~2^15-1</code>)<br>②<strong>1</strong>个<em>short</em>占<strong>2</strong>个字节(<code>Byte</code>)，<strong>16</strong>位(<code>bit</code>)</p><br><h2 id="3-3-int">3.3 int</h2><pre><code class="language-Java">{    int i1=-2147483648;    int i2=2147483647;    System.out.println(i1+"\n"+i2);}</code></pre><p>①<em>int</em>类型的<strong>范围</strong>是<code>-2147483648~2147483647</code>(即<code>-2^31~2^31-1</code>)<br>②<strong>1</strong>个<em>int</em>占<strong>4</strong>个字节(<code>Byte</code>)，<strong>32</strong>位(<code>bit</code>)</p><br><h2 id="3-4-long">3.4 long</h2><pre><code class="language-Java">{    long l1=-9223372036854775808L;    long l2=9223372036854775807L;    System.out.println(l1+"\n"+l2);}</code></pre><p>①<em>long</em>类型的<strong>范围</strong>是<code>-9223372036854775808~9223372036854775807</code>(即<code>-2^63~2^63-1</code>)<br>②<em>long</em>类型在<strong>数字的末尾</strong>要加上<code>L或l</code><br>③<strong>1</strong>个<em>long</em>占<strong>8</strong>个字节(<code>Byte</code>)，<strong>64</strong>位(<code>bit</code>)</p><br><h2 id="3-5-float">3.5 float</h2><pre><code class="language-Java">{    float f1=9.999999F;     float f2=9999999F;    float f3=f2+1;    System.out.println(f1); //9.999999    System.out.println(f2); //9999999.0    System.out.println(f3); //1.0E7，这里的E7指的是10^7即10的7次方    float f4=-9999999F;    float f5=-(f4-1);    System.out.println(f4); //-9999999.0    System.out.println(f5); //-1.0E7    float f6=123123123f; //前7位数不会丢失精度，但从第8位开始就可能会出现精度丢失的情况    float f7=f6+1;    System.out.println("f6=" + f6); //f6=1.2312312E8    System.out.println("f7=" + f7); //f7=1.2312312E8    System.out.println(f6 == f7); //返回true，因为精度丢失了，它们输出一样的结果    }</code></pre><p>①<em>float</em>类型的<strong>范围</strong>比较特殊，正常来说<strong>前7位</strong>都是<strong>正常的</strong>，超过7位后会出现<code>E</code>来表示<strong>科学计数法</strong>；然后在<strong>前8位</strong>中有一部分也是正常的，但到了<strong>后面的部分</strong>会出现<strong>精度丢失</strong>的现象<br>②<em>float</em>类型在<strong>数字的末尾</strong>要加上<code>F或f</code><br>③<strong>1</strong>个<em>float</em>占<strong>4</strong>个字节(<code>Byte</code>)，<strong>32</strong>位(<code>bit</code>)<br>④<em>Java</em>中默认<strong>小数</strong>为<em>double</em>类型，所以如果要使用<em>float</em>类型就需要加上<code>F或f</code>或者<strong>强制转换</strong>成<em>float</em>类型</p><br><h2 id="3-6-double">3.6 double</h2><pre><code class="language-Java">    double d1=0.0000001d;    System.out.println(d1); //1.0E-7，即1*(10^-7)</code></pre><p>①<em>double</em>类型的<strong>范围</strong>要比<em>float</em>类型的要广很多，能精确到<code>15~16</code>位，具体<strong>有效位数</strong>可以自行查找；但是和<em>float</em>类型一样，到了<strong>后面的部分</strong>也会出现<strong>精度丢失</strong>的现象<br>②<em>double</em>类型在<strong>数字的末尾</strong>要加上<code>D或d</code><br>③<strong>1</strong>个<em>double</em>占<strong>8</strong>个字节(<code>Byte</code>)，<strong>64</strong>位(<code>bit</code>)</p><br><h2 id="3-7-char">3.7 char</h2><pre><code class="language-Java">{    char a1='a';    System.out.println("a1="+a1); //a1=a    char a2='1';    System.out.println("a2="+a2); //a2=1    char b1='\u0042';    System.out.println("b1="+b1); //b1=B    char b2='\t';    System.out.println("I love"+b2+"you"); //I loveyou    char b3='\n';    System.out.println(b3+"baby"); //(换行) baby    char c1=1;    System.out.println("c1="+c1); //c1=SOH，SOH(Start Of Headling)是ASCII码的第1个    char c2=48;    System.out.println("c2="+c2); //c2=0，ASCII码的第48个为0    System.out.println("c1+c2="+(c1+c2)); //49，1+48    System.out.println("a2+c1="+(a2+c1)); //50，49+1，a2的'1'为ASCII码的第49个    System.out.println("a2+c2="+(a2+c2)); //97，49+48}</code></pre><p>①<em>char</em>类型<strong>只能</strong>写入<strong>1个字符</strong>，字符表示<em>Unicode（万国码）<em>编码表中的每1个符号，每个符号使用</em>单引号</em>(<code>''</code>)引起来，其中<strong>前128个符号</strong>和<em>ASCII表</em>相同，且这个字符可以是<em>转义字符</em>，如上面的<code>'\u0042'</code>表示转义成<em>Unicode</em>的第42个即<em>大写的B</em>，<code>'\t'</code>表示转义成<em>制表符</em>(即4个空格)，<code>'\n'</code>表示转义成<em>换行符</em>(即换1行)</p><table><thead><tr><th>Unicode转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\u000a</td><td>换行符 <code>\n</code></td></tr><tr><td>\u000d</td><td>回车符 <code>\r</code></td></tr><tr><td>\u007b</td><td>大括号左半部 <code>{</code></td></tr><tr><td>\u007d</td><td>大括号右半部 <code>}</code></td></tr><tr><td>\u0008</td><td>退格符 <code>\b</code></td></tr><tr><td>\u0009</td><td>制表符 <code>\t</code></td></tr><tr><td>\u0022</td><td>双引号半边 <code>"</code></td></tr><tr><td>\u0027</td><td>单引号半边 <code>'</code></td></tr><tr><td>\u002b</td><td>加号 <code>+</code></td></tr><tr><td>\u003b</td><td>分号 <code>;</code></td></tr><tr><td>\u005c</td><td>反斜杠 <code>\</code></td></tr><tr><td>\u0041 ~ \u005a</td><td>字符 <code>A~Z</code></td></tr><tr><td>\u0061 ~ \u007a</td><td>字符 <code>a~z</code></td></tr></tbody></table><p>②<em>char</em>类型的变量的值如果<strong>不</strong>带上<em>单引号</em>(<code>''</code>)，则<strong>只能写入数字</strong>(可以是1个，也可以是多个)，表示直接把写入的<strong>变量的值</strong>视为<strong>ASCII码对应的十进制数字</strong>，如上面<code>char c2=48;</code>意思是将<em>ASCII码</em>的<code>第48个</code>(即是数字<code>0</code>)赋值给<code>c2</code>，所以<code>System.out.println("c2="+c2);</code>这个的结果是<code>c2=0</code>；而在<code>System.out.println("a2+c1="+(a2+c1));</code>中，结果之所以是<code>50</code>的原因是<code>a2</code>和<code>c1</code>在<code>println()</code>中进行的是<em>ASCII码的值</em>的相加运算，因为<code>a2='1'</code>，所以<code>'1'</code>在<em>ASCII码中的值</em>是<code>49</code>，而<code>c1=1</code>，<code>1</code>本来代表的就是<em>ASCII码的值</em>为<code>1</code>，所以<code>50=49+1</code>，<code>System.out.println("c1+c2="+(c1+c2));</code>和<code>System.out.println("a2+c2="+(a2+c2));</code>同理<br>③<strong>1</strong>个<em>char</em>占<strong>2</strong>个字节(<code>Byte</code>)，<strong>16</strong>位(<code>bit</code>)，它的取值范围是<code>0~65535</code></p><br><h2 id="3-8-boolean">3.8 boolean</h2><pre><code class="language-Java">    boolean isMan=true;    if(isMan){        System.out.println("请进男厕");    }    else {        System.out.println("请进女厕");    }</code></pre><p>①<strong>1</strong>个<em>boolean</em>占<strong>1</strong>位，有<code>true</code>和<code>false</code>这2个值，一个表示<code>真</code>，一个表示<code>假</code>，一般用于表示<strong>逻辑运算</strong><br>②<em>boolean</em>类型<code>true</code>和<code>false</code>都<strong>不谈</strong>字节大小，但<strong>实际上</strong>会被转换成<code>1</code>和<code>0</code>，所以占<strong>4</strong>字节(<code>Byte</code>)</p><br><h1>4.引用数据类型</h1><br><h2 id="4-1-String">4.1 String</h2><pre><code class="language-Java">    String str2="";    String str1="HelloChina!"; //String类型变量用""赋值，String类，属于引用数据类型，即是字符串    System.out.println(str1); //HelloChina!    int i2=128;      //String str=str1+i2-3; //报错，因为String类型表示字符串，-表示减法，所以+被视为了加法而非连接    boolean isMan=true;    //String str=isMan+i2+str1; //报错，因为布尔类型isMan开头会+会被视为加法而非连接，是错的，应该把str1放前面    String str=str2+i2; //String类型做连接运算后还是String类型    System.out.println(str); //128    String str3=i2+""; //i2=128被放进""里了得到了str3    System.out.println(str3); //128    int num=Integer.parseInt(str3); //用Integer.parseInt()把str3里的数字取出来    System.out.println(num-1); //127，128-1的结果    String str4=3.2f+"";    System.out.println(str4); //3.2    //int num0=Integer.parseInt(str4); //取不出来str4，因为Integer.parseInt()取的是纯数字的字符串    //System.out.println(num0-1);    System.out.println(3+4+"Hello"); //7Hello，遇上了"Hello"是字符串，所以后面所有只能做连接运算    System.out.println("Hello"+3+4); //Hello34    System.out.println('a'+1+"Hello"); //98Hello，先'a'+1是ASCII运算，再遇上"Hello"做连接运算    System.out.println("Hello"+'a'+1); //Helloa1</code></pre><p>①<em>String</em>类型变量用<code>""</code>赋值<br>②如果用<strong>连接运算</strong>的表达式来给<em>String</em>类型变量赋值，则首先不能出现<code>-</code>，其次<em>boolean</em>的变量不能放在<code>=</code>后的第一个，然后要么<code>=</code>后面有<em>String</em>类型的变量，要么有<code>""</code></p><br><h1>5.包装类和自动装箱、拆箱</h1><br><h2 id="5-1">5.1</h2><h1>6.自动类型提升和强制类型转换</h1><h1>7.基本数据类型与引用数据类型(String)的区别及转换</h1><br><h2 id="7-1区别1：变量和值存放的位置">7.1区别1：变量和值存放的位置</h2><p>①<em>基本数据类型</em>的<strong>变量和值</strong>是<strong>一起</strong>存放在被划分的<em>栈内存</em>里的；而<em>引用数据类型</em>的<strong>变量</strong>是存放在<strong>栈内存</strong>中，但其<strong>值</strong>是存放在<strong>堆内存</strong>中的<br>②所以两个<em>基本数据类型</em>的变量的<strong>值</strong>可以是一样的；但如果两个<em>引用数据类型</em>的变量有<strong>相同的值</strong>，那么他们会<strong>共用同一个</strong>堆内存里的<strong>值</strong>，因为这个<strong>值</strong>的<strong>地址</strong>是<strong>唯一的</strong>，而这两个变量都指向的这个地址</p><br><h2 id="7-2区别2：判断是否相等">7.2区别2：判断是否相等</h2><p>①<em>基本数据类型</em>用<code>==</code>和<code>!=</code>来判断数据是否相等<br>②<em>引用数据类型</em>用<code>equals()</code>来判断数据是否相等(因为<code>equals()</code>比较的是<strong>内存地址</strong>)</p><br><h2 id="7-3转换">7.3转换</h2><p>①<em>String类型</em>变<em>基本数据类型</em>：</p><p>②<em>基本数据类型</em>变<em>String类型</em>：</p><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/C-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/C-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.关于<code>#include&lt;iostream&gt;</code></h1><p><em>C++语言</em>里<code>#include&lt;iostream&gt;</code>用于<em>引入标准输入输出流</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>即<code>cin(输入)</code>和<code>cout(输出)</code>，例如：</p><pre><code class="language-C++">#include"iostream"using namespace std;int main(){    int j; //声明整数j                                               cin &lt;&lt; j; //从键盘输入一个整数作为j的值                int i=1; //声明整数i的值为1    cout &lt;&lt; "输出的内容" &lt;&lt; i &lt;&lt; endl; //输出i的值}</code></pre><p>而<code>std::cout</code>与<code>cout</code>的区别是：<br><code>std</code>是一个<em>命名空间（namespace）</em>，<code>::</code>是<em>作用域</em>运算符，<code>cout</code>是<em>std空间</em>中的一个<em>函数名</em>，所以使用<code>cout</code>时，<strong>必须</strong>有使用std命名空间的说明<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，有两种说明方式（<code>cin</code>同理），如下：<br>①方式一：每次使用时都对cout说明</p><pre><code class="language-C++">#include"iostream"int main(){    std::cout&lt;&lt;"Input two numbers:";}</code></pre><p>②方式二：在主函数前说明一下，后面就可以直接使用cout</p><pre><code class="language-C++">#include"iostream"using namespace std;int main(){    cout &lt;&lt; "Input two numbers:";}</code></pre><h1>2.关于#pragma once</h1><p><em>C++语言</em>里<code>#pragma once</code>是用于<em>预编译</em>，为了<em>避免</em> <strong>同一个头文件</strong>被<code>include</code>多次，这里所说的<strong>同一个文件</strong>是指<strong>物理上</strong>的<em>一个文件</em>，而不是指<strong>内容相同</strong>的<em>两个文件</em></p><h1>3.关于<code>#include&lt;cstdlib&gt;</code></h1><p><em>C++语言</em>里<code>#include&lt;cstdlib&gt;</code>相当于<em>C语言</em>中<code>#include&lt;stdlib.h&gt;</code>的增强版，它包含了<em>C标准库的通用工具函数</em>，如<code>malloc</code>和<code>free</code>函数等</p><h1>4. nullptr关键字</h1><p>①在<em>C++11</em>之前，通常使用<code>0</code>或<code>NULL</code>来表示<strong>指针为空</strong>；在<em>C++11</em>中，引入了<code>nullptr</code><em>关键字</em>，它被定义为<code>std::nullptr_t</code><em>数据类型</em>的字面值<em>常量</em>，用于表示<strong>空指针</strong><br>②<em>C++11</em>中，初始化指针变量时，可以将其初始化为<code>nullptr</code>，如：<code>int *p = nullptr</code>，这种方式可以避免由于误解空指针的含义而导致的错误<br>③在<em>C++11</em>之后，<strong>不推荐</strong>使用<code>0</code>或<code>NULL</code>来表示<strong>空指针</strong>，因为它们在语义上<strong>不够明确</strong>，容易产生歧义；此外，对于<em>整型变量和指针类型变量</em> <strong>混用时</strong>，可能会导致一些问题<br>④由于<code>nullptr</code>是一个<strong>关键字</strong>，在进行初始化时<strong>不能</strong>将其改成其他字符，否则将会导致编译错误</p><h1>5. new关键字</h1><p>①<code>new</code>是<em>C++语言</em>中的一个<strong>关键字</strong>，用于在<strong>堆区</strong> <em>动态分配内存</em>并<em>返回其地址（即指针）</em>，可以使用<code>new</code>关键字<em>实例化一个类对象</em>、*分配一个数组或在堆区中动态分配内存等<br>②对于<strong>基本数据类型</strong>，使用<code>new</code>时可以<strong>指定初值</strong>，例如：</p><pre><code class="language-C++">int *p = new int(10);  //分配4个字节的内存，初始化为10，返回指向该内存的指针</code></pre><p>③对于<strong>自定义类型</strong>，需要通过<strong>构造函数</strong>来初始化对象，例如：</p><pre><code class="language-C++">class MyClass {public:    MyClass() { cout &lt;&lt; "MyClass Constructor" &lt;&lt; endl; }};MyClass *obj = new MyClass();  //动态分配内存并调用构造函数，返回指向该对象的指针</code></pre><p>④需要注意的是，在使用<code>new</code>关键字<strong>动态分配内存</strong>时，如果程序出现<strong>异常终止</strong>，可能会导致<strong>内存泄漏</strong>，所以在<strong>动态分配内存</strong>后应<strong>必须手动</strong>使用<code>delete</code>关键字<strong>释放内存</strong>，或使用<strong>智能指针</strong>等方式来<strong>自动管理内存</strong></p><h1>6.指向常量对象的常量指针(如：const double *point)</h1><pre><code class="language-C++">#include "iostream"using namespace std;int main() {    const double pi = 3.14;    const double *point = &amp;pi; //指向常量对象的常量指针    //不能通过指针point来修改pi的值    cout &lt;&lt; "pi的原始值：" &lt;&lt; pi &lt;&lt; endl;  //输出为 pi的原始值：3.14    //*point = 3.1415;  //错误：指针point指向的对象是常量，不能修改其值    //但是指针point自身的值可以修改，即可以指向其他的常量对象    const double anotherPi = 3.1415926;    point = &amp;anotherPi;  //可以修改指针point指向的其他对象的地址    cout &lt;&lt; "anotherPi的值：" &lt;&lt; *point &lt;&lt; endl;  //输出为 anotherPi的值：3.14159    return 0;}</code></pre><h1>7.指向常量的常量指针(如：double* const point)</h1><pre><code class="language-C++">#include "iostream"using namespace std;int main() {    double a = 1.0, b = 2.0;    double* const point = &amp;a;  //指向常量的常量指针    //指针point指向的对象是变量，可以通过指针point来修改该对象的值    cout &lt;&lt; "a的原始值：" &lt;&lt; a &lt;&lt; endl;  //输出为 a的原始值：1    *point = 3.0;    cout &lt;&lt; "a改变后的值：" &lt;&lt; a &lt;&lt; endl;  //输出为 a的改变后的值：3    //但是指针point自身的值不能修改，即不能指向其他的对象    //point = &amp;b;  //错误：指针point是常量，其地址不能改变    return 0;}</code></pre><h1>8.内联函数</h1><p>①内联函数是一种<strong>特殊的函数</strong>，它的<strong>函数体</strong>通常比较<strong>短小</strong>，并<strong>被频繁使用</strong>；在编译时，编译器将在<strong>每个</strong>调用处<strong>直接</strong>把内联函数的代码<strong>嵌入</strong>到调用该函数的地方，这样可以<strong>减少</strong>函数调用的<strong>开销</strong>，<strong>提高</strong>程序的执行<strong>效率</strong><br>②内联函数是对<strong>函数调用机制</strong>的<strong>优化</strong>，它并<strong>不影响</strong>函数的<strong>本质</strong>，且仍然<strong>遵循</strong>函数的<strong>语法</strong><br>③内联函数的<strong>局限性</strong>：内联函数过多会导致可执行程序的<strong>体积增大</strong><br>④内联函数<strong>不能</strong>被<strong>递归</strong>调用，因为递归需要在<strong>函数栈中</strong>存储<strong>每次</strong>调用的<strong>数据</strong>和<strong>返回地址</strong>，而内联函数的代码是在调用点<strong>直接嵌入</strong>到程序中的，<strong>没有函数栈</strong><br>⑤在<em>C++语言</em>中，用关键字<code>inline</code>来声明一个<em>内联函数</em>，如下：</p><pre><code class="language-C++">#include "iostream"using namespace std;//声明内联函数addinline int add(int a, int b) {    return a + b;}int main() {    int a = 3, b = 4;    int sum = add(a, b); // 调用内联函数add    cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl;    return 0;}</code></pre><h1>9.构造函数与内联函数</h1><p>①构造函数的<strong>调用时机</strong>和普通函数<strong>不同</strong>，构造函数在<strong>对象</strong>被<strong>创建</strong>时被调用，而<strong>不是</strong>通过<strong>函数名</strong>进行<strong>显式调用</strong><br>②<strong>构造函数</strong>可以<strong>被声明</strong>为<strong>内联函数</strong>，因为它们<strong>经常</strong>被用来<strong>创建类的对象</strong>，并且它们的<strong>函数体</strong>通常比较<strong>短小</strong><br>③将构造函数声明为内联函数<strong>并不是必须的</strong>，<strong>只有</strong>当构造函数的<strong>函数体</strong>非常<strong>简短</strong>并且在程序中被<strong>频繁</strong>使用时才可以考虑使用内联函数，<strong>如果</strong>构造函数的<strong>函数体很长</strong>，则声明为内联函数会<strong>增加可执行文件的大小</strong>而会<strong>适得其反</strong>，不过由于<strong>编译器</strong>会<strong>根据具体情况决定</strong>是否将函数展开成内联函数，所以在实际上，将构造函数声明为内联函数<strong>可能</strong>并<strong>不能</strong>真正地<strong>提高程序的执行效率</strong></p><h1>10.析构函数（析构方法）</h1><pre><code class="language-C++">#include "iostream"#include "cstring"class Person {public:    // 构造函数    Person(const char* name, int age) {        m_name = new char[strlen(name) + 1];        strcpy(m_name, name);        m_age = age;    }    // 析构函数    ~Person() {        std::cout &lt;&lt; "释放 " &lt;&lt; m_name &lt;&lt; " 所占用的内存" &lt;&lt; std::endl;        delete[] m_name;    }    // 成员函数    void printInfo() {        std::cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; ", 年龄：" &lt;&lt; m_age &lt;&lt; std::endl;    }private:    char* m_name;    int m_age;};int main() {    // 创建一个 Person 对象    Person* person = new Person("Jack", 25);    // 使用对象的成员函数    person-&gt;printInfo();    // 释放对象所占用的内存    delete person;    return 0;}</code></pre><p>①析构函数（析构方法）写法为<code>~类名() {}</code><br>②析构函数是一种<strong>特殊的</strong>成员函数，当一个对象被销毁时，如：一个局部变量离开了作用域、一个对象被<code>delete</code>掉等，就会执行析构函数<br>③析构函数通常用于<strong>释放对象所占用的资源</strong>，如：释放动态分配的内存、关闭打开的文件、断开网络连接等，但由于<em>C++语言</em>没有<strong>垃圾回收机制</strong>，因此需要<strong>手动释放资源</strong>，否则可能会导致<strong>程序崩溃</strong>或<strong>资源泄漏</strong>等问题</p><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>C++的I/O发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>用于避免导致全局命名冲突问题 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo页脚插入网站运行时间和不蒜子统计</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E9%A1%B5%E8%84%9A%E6%8F%92%E5%85%A5%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E9%A1%B5%E8%84%9A%E6%8F%92%E5%85%A5%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.网站页脚插入网站运行时间</h1><p>找到博客主题文件夹对应的页脚渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>footer.ejs</code>文件，把下面代码插入到<code>&lt;/footer&gt;</code>之前，然后在<code>var grt= new Date("08/10/2020 00:00:00")</code>把<code>08/10/2020 00:00:00</code>修改为自己的建站时间</p><pre><code>&lt;div&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt;    var now = new Date();     function createtime() {         var grt= new Date("08/10/2020 00:00:00");//在此处修改你的建站时间        now.setTime(now.getTime()+250);         days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);         hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);         if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);         mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}         seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);         snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}         document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 ";         document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";     } setInterval("createtime()",250);&lt;/script&gt;&lt;/div&gt;</code></pre><h1>2.不蒜子脚本使用</h1><p>找到博客主题文件夹对应的页脚渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>footer.ejs</code>文件，把下面代码插入到<code>&lt;/footer&gt;</code>之前；然后<code>&lt;script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</code>这行代码里<code>src=""</code>后面要填的就是不蒜子<strong>最新的</strong>脚本域名，可以在不蒜子官方网址查询</p><pre><code>&lt;div class="busuanzi-count"&gt;    &lt;script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;    &lt;span class="site-uv"&gt;      &lt;i class="fa fa-user"&gt;&lt;/i&gt;      总访客 &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 人      &lt;span class="post-meta-divider"&gt; | &lt;/span&gt;    &lt;/span&gt;    &lt;span class="site-uv"&gt;      &lt;i class="fa fa-eye"&gt;&lt;/i&gt;      访问量 &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次    &lt;/span&gt;&lt;/div&gt;</code></pre><blockquote><p>不蒜子官方网址:<a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a><br>参考文章1:<a href="https://blog.csdn.net/qq_39720594/article/details/105411030">https://blog.csdn.net/qq_39720594/article/details/105411030</a><br>参考文章2:<a href="https://blog.csdn.net/wangqingchuan92/article/details/126346205">https://blog.csdn.net/wangqingchuan92/article/details/126346205</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 网站运行时间统计 </tag>
            
            <tag> 访问量统计 </tag>
            
            <tag> 总访客数统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插入彩色滚动文字</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E6%8F%92%E5%85%A5%E5%BD%A9%E8%89%B2%E6%BB%9A%E5%8A%A8%E6%96%87%E5%AD%97/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E6%8F%92%E5%85%A5%E5%BD%A9%E8%89%B2%E6%BB%9A%E5%8A%A8%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>一段代码搞定</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前，也可以是其他位置；其中<code>var l = " Hi. "</code>的<code>Hi.</code>，<code>return r + "."</code>里的<code>.</code>，还有<code>o = []</code>中<code>[]</code>里的文字都可以自行修改</p><pre><code>&lt;p style="text-align:center" id="saintwei"&gt;&lt;/p&gt;&lt;script&gt;   var saintwei = function (r) {       function t() {           return b[Math.floor(Math.random() * b.length)]       }       function e() {           return String.fromCharCode(94 * Math.random() + 33)       }       function n(r) {           for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) {               var l = document.createElement("span");               l.textContent = e(), l.style.color = t(), n.appendChild(l)           }           return n       }       function i() {           var t = o[c.skillI];           c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)       }       var l = " Hi. ",           o = ["Welcome to my blog", "世界本就如此艰难，何必还要让它更艰难呢", "你若盛开，蝴蝶自来；你若精彩，天自安排", "Are You OK", "转身变成一只猫"].map(function (r) {               return r + "."           }),           a = 2,           g = 1,           s = 5,           d = 75,           b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],           c = {               text: "",               prefixP: -s,               skillI: 0,               skillP: 0,               direction: "forward",               delay: a,               step: g           };       i()   };   saintwei(document.getElementById('saintwei'));&lt;/script&gt;</code></pre><blockquote><p>参考文章:<a href="https://blog.csdn.net/qq_25896347/article/details/117968673">https://blog.csdn.net/qq_25896347/article/details/117968673</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 彩色滚动文字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo标题搞怪特效</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E6%A0%87%E9%A2%98%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E6%A0%87%E9%A2%98%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.直接法（已成功）</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前；其中离开本网站和回到本网站的<strong>表情和中文</strong>可以自行更改</p><pre><code>&lt;script type="text/javascript"&gt;    var OriginTitile=document.title,st;document.addEventListener("visibilitychange",function(){        document.hidden?(document.title="o(இ௰இ)怎么就走了！",clearTimeout(st)):(document.title="☆*o(≧▽≦)o*☆欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))    })&lt;/script&gt;</code></pre><h1>2.借用法（未实践）</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前；目的是借用别人写好的<code>js</code>文件链接，但不能修改里面的<strong>表情和中文</strong>，且这个链接的存在和消亡取决于发这个链接的作者o(≧口≦)o</p><pre><code>&lt;script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.5/source/js/FunnyTitle.js"&gt;&lt;/script&gt;</code></pre><blockquote><p>参考资料:<a href="https://blog.csdn.net/victoryxa/article/details/105841309/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8--blog-86065141.235%5Ev38%5Epc_relevant_sort&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11">https://blog.csdn.net/victoryxa/article/details/105841309/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8--blog-86065141.235^v38^pc_relevant_sort&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 标题搞怪特效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Aplayer插件在Hexo上插入音乐</title>
      <link href="/CuteFox_Home.github.io/2023/08/30/%E7%94%A8Aplayer%E6%8F%92%E4%BB%B6%E5%9C%A8Hexo%E4%B8%8A%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/"/>
      <url>/CuteFox_Home.github.io/2023/08/30/%E7%94%A8Aplayer%E6%8F%92%E4%BB%B6%E5%9C%A8Hexo%E4%B8%8A%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.安装hexo-tag-aplayer插件</h1><pre><code class="language-bash">$ npm install --save hexo-tag-aplayer</code></pre><h2 id="2-使用">2.使用</h2><h3 id="2-1-Aplayer播放器基本格式">2.1 Aplayer播放器基本格式</h3><p>在每篇文章即<code>.md</code>文件中的正文中添加如下内容：</p><pre><code class="language-md">{% aplayer title author music-url [picture-url, lrc:lrc-url, width:xx%, autoplay, narrow] %}</code></pre><p>但如果无法直接在标签参数中加入空格，则直接将参数用<strong>双引号</strong>括起来使用，如下：</p><pre><code class="language-md">{% aplayer "title" "author" "music-url" "picture-url" "lrc:lrc-url" "width:xx%" "autoplay" "narrow" %}</code></pre><p>其中，<code>{% aplayer %}</code>是<strong>必须</strong>写上的格式，其他<strong>标签参数</strong>具体如下：</p><ul><li><code>title</code>：歌曲的标题（必选）</li><li><code>author</code>：歌曲的作者（必选）</li><li><code>music-url</code>：歌曲本体的URL地址（必选）</li><li><code>picture-url</code>：歌曲封面的URL地址（可选）</li><li><code>lrc-url</code>：歌词的URL地址（可选）</li><li><code>width:xx%</code>：宽度（可选，默认100%）</li><li><code>autoplay</code>：自动播放（可选，移动端暂不支持）</li><li><code>narrow</code>：袖珍风格播放器（可选）<br>若在网站根目录下的<code>config.yml</code>文件中将<code>post_asset_folder</code>设为<code>true</code>，即开启了Hexo的文章资源文件夹功能，则可以将歌曲本体、歌曲封面、歌词放入<strong>与文章同名</strong>的对应的资源文件夹中，然后直接引用，如下：</li></ul><pre><code class="language-md">{% aplayer "Running In The Dark" "MONKEY MAJIK" "Running In The Dark.mp3" "Running In The Dark.jpg" "lrc:Running In The Dark.txt" %}</code></pre><p>效果如下<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found (Running In The Dark.jpg)");</script><p>除了单曲，还支持列表模式，具体可参照<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8">播放列表</a></p><h3 id="2-2-MeingJS播放器">2.2 MeingJS播放器</h3><p>介绍：MetingJS是基于Meting API的APlayer衍生播放器<br>功能：将支持对于QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放<br>①在网站根目录下的<code>config.yml</code>文件中添加如下：</p><pre><code class="language-yml">aplayer:  meting: true</code></pre><p>②在每篇文章即<code>.md</code>文件中的正文中添加如下内容：</p><pre><code class="language-md">{% meting "2068111443" "netease" "song" "theme:#7777" "mutex:true" "listmaxheight:340px" "preload:auto" %}</code></pre><p>效果如下：</p>    <div id="aplayer-xVEoePQG" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2068111443" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#7777"></div><p>其中，<code>{% meting %}</code>是<strong>必须</strong>写上的格式，其他<strong>标签参数</strong>具体如下：</p><ul><li><code>2068111443</code>是歌曲ID（必选），如网易云音乐分享歌曲链接的时<code>https://music.163.com/song?id=2068111443&amp;userid=</code>中<code>2068111443</code>就是该歌曲的ID</li><li><code>netease</code>是网易云音乐平台（必选），也可以换成其他音乐平台如：<code>tencent</code>，<code>kugou</code>，<code>xiami</code>，<code>baidu</code>等</li><li><code>song</code>是歌曲的类型（必选），单曲是<code>song</code>，歌单是<code>playlist</code>(效果可以参考我的<a href="https://drphilip425.github.io/CuteFox_Home.github.io/about/">About</a>)，专辑是<code>album</code>，还有<code>search</code>和<code>artist</code></li><li><code>theme:#7777</code>是播放器主题色（可选），具体喜欢的RGB颜色请自行查找并更改</li><li><code>mutex:true</code>意思是选择<code>true</code>时，如果<strong>同页面</strong>有其他aplayer播放，<strong>该播放器</strong>会暂停</li><li><code>listmaxheight:340px</code>意思是播放列表的最大长度默认为<code>340px</code></li><li><code>preload:auto</code>意思是音乐文件预载入模式为<code>auto</code>，可以改为<code>none</code>或<code>metadata</code><br>更多标签参数请看<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD">选项列表</a></li></ul><p>③非post（正文）页面使用问题<br>如果在非post（正文）页面中无法使用Aplayer播放器，可以试试在<code>.md</code>文件添加<code>{% aplayer %}</code>或<code>{% meting %}</code>之前添加如下内容：</p><pre><code>&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"&gt;&lt;/script&gt;</code></pre><blockquote><p>hexo-tag-aplayer官方中文文档:<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md</a><br>参考文章:<a href="https://blog.csdn.net/hushhw/article/details/88092728">https://blog.csdn.net/hushhw/article/details/88092728</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>不知道是不是主题原因，我用F12查看发现我的歌曲本体和歌词都没成功上传，暂时没得到解决 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Aplayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/08/26/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/08/26/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.基本格式</h1><pre><code class="language-C">#include "stdio.h"...//函数体int main(){ ...//主函数}</code></pre><h2 id="1-1简单实例">1.1简单实例</h2><pre><code class="language-C">#include "stdio.h"void prinHello(){    printf("Hello World!");}int main(){    prinHello();    return 0;}</code></pre><h2 id="1-2具体讲解">1.2具体讲解</h2><p>(1)<code>#include</code>意思为<strong>导入</strong>，<code>stdio</code>为<strong>标准输入和输出</strong>，而<code>.h</code>为<strong>头文件</strong>，所以<code>#include"stdio.h"</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的意思是<strong>导入一个标准输入和输出的头文件</strong>，这个<strong>头文件</strong>通常是<strong>系统自带的库里的文件</strong>，而导入的<strong>头文件不同</strong>，能使用该文件里的<strong>函数就不同</strong></p><p>(2)①在<strong>函数体</strong>中<code>void</code>表示<strong>没有返回值</strong>，如需有返回值则将<code>void</code>改为<strong>具体的返回值类型</strong>，且在<code>{}</code>写上<code>retrun 返回值</code>；<br>②<code>prinHello</code>为<strong>函数名</strong>，函数名<strong>只能</strong>用<em>字母、下划线、数字表示</em>，<strong>不能</strong>使用<s>关键字</s>，且<strong>必须</strong>以<em>字母或下划线</em>开头，<strong>不能</strong>以<s>数字</s>开头；<br>③<code>()</code>里可以写形式参数（简称“形参”），形参用<code>数据类型 声明的变量</code>表示，也可以不添加形参表示<strong>空参</strong>，但在调用空参函数时还是需要<strong>在函数名后面</strong>加上<code>()</code>；<br>④<strong>函数具体内容</strong>写在<code>{}</code>里面，可以一个<code>{}</code>内嵌入许多<code>{}</code>，每一个语句写完都要用<code>;</code>隔开；<br>⑤<code>printf()</code>是<strong>系统自带的函数</strong>，表示把输入的内容<strong>打印</strong>在输出窗口，调用时在<code>printf</code>的<code>()</code>里添加<code>""</code>，并在<code>""</code>里输入想要打印的内容即可</p><p>(3)①<code>int main()</code>是<strong>主函数的入口</strong>，其<code>{}</code>写入<strong>主函数执行语句</strong>，因为C语言<strong>从上到下</strong>编译的特性，普通函数<strong>只能</strong>写在主函数<strong>上面</strong>，且主函数<strong>只有</strong>一个；<br>②<code>prinHello()</code>是一个<strong>调用</strong>上面已经写好的<strong>函数</strong>的语句；<code>return 0</code>表示<strong>返回值为0</strong>，即退出程序</p><h1>2.数据类型与格式符</h1><p>(1)数据类型与它的格式符<strong>一一对应</strong>，数据类型声明变量，格式符放在输入输出语句中<br>(2)常见的有:int–%d，double–%lf，float–%f，char–%c，long–%ld，short–%hd，unsigned int–%u …</p><h1>3.输出对齐与保留小数位数</h1><p>如<code>print("%10.2lf",a)</code>中<code>10</code>表示<strong>向右对齐</strong>10个位置，同理<code>-10</code>表示<strong>向左对齐</strong>10个位置，而<code>.2</code>表示<strong>保留小数后2位</strong></p><h1>4.非格式化输入和输出</h1><h2 id="4-1-gets-输入与puts-输出">4.1 gets()输入与puts()输出</h2><h3 id="4-1-1-gets-输入">4.1.1 gets()输入</h3><p>(1)用法：</p><pre><code class="language-C">int main(){ char arr[10],*s; //声明一个字符数组变量，即字符串和一个字符串指针 gets(arr); //从键盘上输入字符串，直到回车结束   gets(s); //从键盘上输入字符串，直到回车结束}</code></pre><p>(2)特点：<br>①<code>gets()</code>是从<em>键盘输入字符串</em> <strong>开始</strong>到<em>按下回车</em> <strong>结束</strong>，其中直到<em>回车</em>前<strong>有空格也行</strong>，且<em>回车</em> <strong>不包含</strong>在字符串内<br>②<code>gets(arr)</code>其中<code>arr</code>可以是<strong>字符串数组名</strong>，也可以是<strong>字符串指针</strong>，如果不是<em>字符串</em>而是<em>单个字符</em>，则<strong>编译</strong>可能不报错，<strong>但</strong> <strong>运行</strong>会报错</p><h3 id="4-1-2-puts-输出">4.1.2 puts()输出</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char arr[]="Hello World!"; //声明一个字符串arr并给该字符串赋值    puts(arr); //输出arr内容到屏幕    char* s; //声明一个字符串指针s    s="Hi! World"; //给s赋值    puts(s); //输出s指向的内容到屏幕    puts("Hello China!"); //直接输出括号里的内容}</code></pre><p>(2)特点：<br>①输出完字符串后会<strong>自动换行</strong><br>②<strong>只能</strong>输出<em>字符串</em>，<strong>不能</strong>输出<em>运算结果</em><br>③可以<strong>直接</strong>在<code>puts()</code>里写入要输出的字符串</p><h2 id="4-2-getchar-输入与putchar-输出">4.2 getchar()输入与putchar()输出</h2><h3 id="4-2-1-getchar-输入">4.2.1 getchar()输入</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char a; //声明一个单个字符变量a    a=getchar(); //从键盘上读取输入的单个字符赋值给a}</code></pre><p>(2)特点：<br>①无论从键盘上输入多少个字符，<code>getchar()</code>只读取输入的<strong>第一个字符</strong>作为返回值<br>②从<em>键盘输入字符</em> <strong>开始</strong>到<em>按下回车</em> 才<strong>结束</strong></p><p>(3)解释：<br><code>getchar()</code>是<code>stdio.h</code>中的<em>库函数</em>，它的作用是从<code>stdio</code>流中读入<strong>一个字符</strong>；键盘输入字符是<em>先存入缓冲区</em>，当你<em>按下回车</em>时，<code>getchar</code>就会<em>进入缓冲区</em>读取字符，<em>一次</em>只读取<em>第一个字符</em>，我们输入的一串字符被读出来是<code>getchar</code><em>循环读取</em>的结果，而<em>回车键</em>取代了我们输入的<em>第一个字符</em>，我们输入<code>getchar()</code>来<em>清除回车键</em>，达到从<em>第一个字符开始读起</em>的目的</p><h3 id="4-2-2-putchar-输出">4.2.2 putchar()输出</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char a; //声明单个字符变量a    a='A'; //把a赋值为A    putchar(a); //输出A    putchar(0x41); //因为A在ASCII码中十六进制为0x41，所以输出A    putchar('\x41'); //因为'\x41'就相当于十六进制的0x41，所以也输出A}</code></pre><p>(2)特点：<br>①向标准输出设备<strong>只</strong>输出<strong>一个字符</strong><br>②相当于<code>printf("%c",a)</code></p><h1>5.内存分配与释放函数</h1><h2 id="5-1-malloc函数分配动态内存地址">5.1 malloc函数分配动态内存地址</h2><p>(1)用法：</p><pre><code class="language-C">#include"stdlib.h"#include"stdio.h"int main(){    int* n; //声明一个整数型指针变量n    n = (int*) malloc(2*sizeof(int)); //为变量n分配动态内存空间    *n = 5; //把5这个值转成二进制存放在变量n的内存空间里    printf("变量n地址为: %d\n", n);    printf("变量n的值为: %d\n", *n);    return 0;    }</code></pre><p>(2)解释：<br>①使用<code>malloc</code>函数<em>分配动态内存空间</em>时要先引入<code>#include&lt;stdlib.h&gt;</code>头文件<br>②<code>malloc</code>函数的<em>函数原型</em>为<code>void* malloc(unsigned int size)</code>，它根据<em>参数</em>指定的尺寸来分配内存空间，且返回一个<code>void</code>型指针，指向新分配的内空间的<em>初始地址</em>；但如果内存分配失败（内存不足），则函数返回<code>NULL</code><br>③<code>n=(int*)malloc(2*sizeof(int))</code>这段代码中，<code>sizeof(int)</code>是分配一个整数类型所占用的字节数的内存空间，通常为4个字节，所以<code>malloc(2*sizeof(int))</code>表示分配一个大小为<code>2*sizeof(int)</code>字节的内存空间，即分配了8个字节大小的内存空间<br>④<code>n=(int*)malloc(2*sizeof(int))</code>这段代码中，<code>(int*)malloc</code>这样写的原因是<code>malloc</code>函数原本返回的是一个<code>void*</code>类型的指针，但指针变量<code>n</code>是<code>int*</code>型的，所以需要将其<em>强制转换</em>为<code>int*</code>类型，才能够将其赋值给一个<code>int*</code>型即<strong>整型指针变量</strong></p><h2 id="5-2-free函数释放动态分配的内存">5.2 free函数释放动态分配的内存</h2><p>(1)用法：</p><pre><code class="language-C">#include"stdlib.h"#include"stdio.h"int main(){    int* n; //声明一个整数型指针变量n    n = (int*) malloc(2*sizeof(int)); //为变量n分配动态内存空间    *n = 5; //把5这个值转成二进制存放在变量n的内存空间里    printf("变量n地址为: %d\n", n);    printf("变量n的值为: %d\n", *n);    free(n); //释放变量n分配的动态内存    return 0;    }</code></pre><p>(2)解释：<br>①使用<code>free</code>函数<em>释放动态分配的内存</em>时要先引入<code>#include&lt;stdlib.h&gt;</code>头文件<br>②用<code>free</code>函数去释放<strong>要释放的内存的指针</strong>为<code>NULL</code>时，则无事发生；但<strong>释放内存后的指针</strong>不能再<code>free</code>一次，否则会导致程序崩溃或者出现错误<br>③只有使用<code>malloc</code>、<code>calloc</code>、<code>realloc</code>等函数动态分配的内存，才能用<code>free()</code>函数进行释放<br>④<code>free</code>函数的函数原型为<code>void free(void* memblock)</code>，其中<code>memblock</code>参数是一个指针，指向要释放的内存空间，以避免内存泄漏；但<code>memblock</code>指针本身并不会消失，所以一般可以使用<code>free</code>函数后，<code>memblock=NULL</code>使<code>memblock</code>指针变为空指针</p><h1>6. enum枚举类型</h1><p>(1)用法：</p><pre><code class="language-C">#include "stdio.h"enum Weekday { //定义枚举类    Monday,    Tuesday,    Wednesday,    Thursday,    Friday,    Saturday,    Sunday};int main() {    enum Weekday today = Wednesday; //声明enum Weekday类型的today并用Wednesday赋值    printf("今天是星期%d\n", today + 1);    return 0;}</code></pre><p>(2)解释：<br>①枚举类型使用<code>enum</code>关键字进行定义<br>②枚举类型中的常量<em>默认从0开始递增</em>，所以上面的例子中，<code>Monday</code>的值为<code>0</code>，<code>Tuesday</code>的值为<code>1</code>，以此类推<br>③如果需要改变枚举类型中常量的值，可以在定义枚举类型时<em>显式指定</em>常量的值，如<code>Monday = 1</code></p><h1>7. typedef自定义类型与struct结构体</h1><p>(1)用法：</p><pre><code class="language-C">typedef struct Book{ //新的数据类型为struct Bookchar no[20];//ISBNchar name[20];//名字float price;//价格}novel; //别名为novelstruct Book{ //新的数据类型为struct Book   char no[20];//ISBN   char name[20];//名字   float price;//价格};</code></pre><p>(2)解释：<br>①结构体<code>struct</code>用于<strong>定义</strong>一个<strong>新的数据类型</strong>，这个<strong>新的数据类型</strong>可以由<strong>任意的基本数据类型</strong>构成，如<code>int</code>、<code>char</code>、<code>float</code>等<br>②自定义类型<code>typedef</code>一般和结构体<code>struct</code>一起用，只不过在<code>typedef struct Book{};</code>的<code>;</code>前多了一个可以<strong>添加别名</strong>的位置，如上面的<code>novel</code>，这个<strong>别名</strong>用于充当<strong>新的数据类型</strong><code>struct Book</code>来声明变量</p><h1>8. Status用法</h1><p>(1)用法：</p><pre><code class="language-C">#include "stdio.h"typedef enum { //自定义枚举类型    SUCCESS, //成功    ERROR //失败} Status; //别名为StatusStatus foo() { //Status类型的foo函数    return SUCCESS;// 函数逻辑}int main() {    Status result = foo(); //声明一个Status类型的result，用同样Status类型的foo函数赋值    if (result == SUCCESS) {        printf("函数执行成功\n");    } else {        printf("函数执行失败\n");    }    return 0;}</code></pre><p>(2)解释：<br>Status通常是一个自定义的类型（<code>typedef</code>），用于表示函数的返回状态；它通常被定义为一个枚举类型（<code>enum</code>）或整型类型（<code>int</code>），用来表示函数执行的结果，例如：成功、失败或其他状态</p><h1>9. assert函数</h1><p>(1)用法：</p><pre><code class="language-C">#include "assert.h"#include "stdio.h"int main() {    FILE *fp = NULL;    fp = fopen("file.txt", "r");    assert(fp != NULL); //如果文件打开失败，则程序会通过assert断言终止运行    char c = fgetc(fp);    printf("读取字符: %c\n", c);    fclose(fp);    return 0;}</code></pre><p>(2)解释：<br>①<code>assert</code>函数使用时需要调用<code>#include&lt;assert.h&gt;</code>头文件<br>②<code>assert</code>函数是一个调试宏，用于<strong>判断</strong>某个条件<strong>是否成立</strong>；如果条件<strong>不成立</strong>，则输出错误信息并调用<code>abort</code>函数，使程序异常终止；其作用可以在<strong>程序开发</strong>和<strong>调试</strong>过程中帮助我们<strong>快速定位错误</strong>，并且可以<strong>避免</strong>在错误条件下程序继续执行导致更严重的问题<br>③在上面的代码中，如果文件<strong>打开失败</strong>，则<code>fp</code>指向<code>NULL</code>，此时<code>assert(fp != NULL)</code>条件不成立，程序会输出错误信息并终止运行；如果文件成功打开，则会正常读取文件中的字符</p><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>调用系统自带的头文件一般是例如#include&lt;stdio.h&gt;用的尖括号，而如果是调用自己写的头文件一般是用的双引号；上面的代码用的双引号是因为尖括号在代码高亮里显示不出来，暂时无法解决 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章添加脚注和emoji表情的解决方法</title>
      <link href="/CuteFox_Home.github.io/2023/08/14/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%92%8Cemoji%E8%A1%A8%E6%83%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/CuteFox_Home.github.io/2023/08/14/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%92%8Cemoji%E8%A1%A8%E6%83%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.脚注</h1><h2 id="1-1用npm安装markdown-it-footnote插件">1.1用npm安装markdown-it-footnote插件</h2><p>打开命令终端(cmd,PowerShell,Git bash等)，输入<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><pre><code class="language-bash">$ npm install markdown-it-footnote --save</code></pre><h2 id="1-2安装bower插件">1.2安装bower插件</h2><pre><code class="language-bash">$ npm install -g bower</code></pre><h2 id="1-3用bower再次安装markdown-it-footnote插件">1.3用bower再次安装markdown-it-footnote插件</h2><pre><code class="language-bash">$ bower install markdown-it-footnote --save</code></pre><h2 id="1-4卸载hexo默认的渲染引擎">1.4卸载hexo默认的渲染引擎</h2><pre><code class="language-bash">$ npm un hexo-renderer-marked --save</code></pre><h2 id="1-5替换其渲染引擎为hexo-renderer-markdown-it">1.5替换其渲染引擎为hexo-renderer-markdown-it</h2><pre><code class="language-bash">$ npm i hexo-renderer-markdown-it --save</code></pre><h2 id="1-6配置并启用markdown-it-footnote插件">1.6配置并启用markdown-it-footnote插件</h2><p>打开在 hexo网站文件 <em>根目录</em> 下的 <em>_config.yml</em> 文件，在里面手动添加</p><pre><code class="language-yml">markdown:  plugins:    - markdown-it-footnote</code></pre><h1>2.emoji表情</h1><h2 id="2-1安装hexo-filter-emoji插件">2.1安装hexo-filter-emoji插件</h2><p>打开命令终端(cmd,PowerShell,Git bash等)，输入</p><pre><code class="language-bash">$ npm install hexo-filter-emoji</code></pre><h2 id="2-2配置并启用hexo-filter-emoji插件">2.2配置并启用hexo-filter-emoji插件</h2><p>打开在hexo网站文件 <em>根目录</em> 下的 <em>_config.yml</em> 文件，在里面手动添加</p><pre><code class="language-yml"># hexo-filter-emojiemoji:  enable: true  className: github-emoji  styles:  customEmojis:</code></pre><h2 id="2-3emoji表情使用方法">2.3emoji表情使用方法</h2><p>打开<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a>网站，选择自己想要的<em>emoji表情</em>，单击即可复制😋</p><blockquote><p>脚注参考:<a href="https://stydxm.com/2022/09/23/hexo-footnote/">https://stydxm.com/2022/09/23/hexo-footnote/</a><br>emoji表情参考:<a href="https://lamirs.vercel.app/hexo-%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8emoji/">https://lamirs.vercel.app/hexo-配置使用emoji/</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>$符号多数情况下不参与命令，一般是终端自带的 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 脚注 </tag>
            
            <tag> emoji表情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用虚拟机软件安装Linux系统</title>
      <link href="/CuteFox_Home.github.io/2023/08/12/%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/CuteFox_Home.github.io/2023/08/12/%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.下载Linux发行版 <em>.iso</em>文件</h1><ul><li><a href="https://ubuntu.com/download/desktop">Ubuntu</a></li><li><a href="https://www.opensuse.org/">openSUSE</a></li><li><a href="https://www.centos.org/download/">CentOS</a></li><li><a href="https://archlinux.org/download/">Arch</a></li><li><a href="https://fedoraproject.org/">Fedora</a></li><li><a href="https://manjaro.org/download/">Manjaro</a></li><li><a href="https://www.debian.org/distrib/">Debian</a></li></ul><hr><h1>2.安装VMware workstation player软件</h1><p>这里下载的是个人免费版<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <a href="https://www.vmware.com/cn/products/workstation-player.html">https://www.vmware.com/cn/products/workstation-player.html</a></p><hr><h1>3.开启虚拟化技术</h1><h2 id="3-1检查是否开启CPU虚拟化">3.1检查是否开启CPU虚拟化</h2><p>同时按住键盘上<em>ESC+SHIFT+CTRL</em>打开任务管理器，选择<em>性能</em>，再找到<em>CPU</em>，在<em>CPU</em>界面下找到虚拟化，查看是否启用。若未启用，则需开启CPU虚拟化。</p><h2 id="3-2开启CPU虚拟化">3.2开启CPU虚拟化</h2><p>在电脑开机时，长按<em>F1、F2、F8或F11</em><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>进入电脑主板<em>Bios</em>，在<em>Bios</em>中找到高级选项，再往下移至<em>Inter Virtual Technol</em>，按回车键<em>ENTER</em>，选择<em>Enable</em>；继续再高级选项下找<em>VT-d</em>，再按回车键<em>ENTER</em>，选择<em>Enable</em>；最后保存并退出，开机。</p><h2 id="3-3开启虚拟机平台">3.3开启虚拟机平台</h2><p>同时按下<em>WIN+R</em>键打开运行窗口，输入<em>OptionalFeatures</em>，打开windows功能,勾选<em>Windows虚拟机监控程序平台</em>和<em>虚拟机平台</em>，最后重启电脑。</p><hr><h1>4.安装Linux系统</h1><p>打开<em>VMware workstation player</em>软件，选择<em>创建新的虚拟机</em>，在<em>安装程序光盘映像文件</em>中选择下载好的Linux发行版的 <em>.iso</em>文件，然后填写虚拟机的名称，以及该Linux系统的用户名和密码，<em>磁盘空间大小</em>一般分配20G，<em>自定义硬件</em>里一般将<em>内存</em>提至1-2G，<em>处理器核数</em>一般用1-2个，配置基本完成后就可以给安装好Linux系统的虚拟机开机了。</p><hr><h1>5.给虚拟机配置网络</h1><h2 id="5-1查看虚拟机IP地址">5.1查看虚拟机IP地址</h2><p>打开装有Linux系统虚拟机的<em>终端</em>，输入命令<code>ifconfig</code>，在<em>ens33</em>那块找到<em>inet</em>，<em>inet</em>后面的一串数字即为该虚拟机的<em>IPv4地址</em>。</p><h2 id="5-2">5.2</h2><p>在Windows系统同时按住<em>Win+R</em>键输入<em>cmd</em>打开<em>cmd终端</em>，在<em>cmd终端</em>中输入<code>ping 192.168...</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>且保证<em>cmd终端</em>中未显示有<em>数据包</em>丢失。</p><hr><blockquote><p>参考资料:<a href="https://kb.vmware.com/s/article/1003944?lang=zh_cn">https://kb.vmware.com/s/article/1003944?lang=zh_cn</a><br>参考视频:<a href="https://www.bilibili.com/video/BV1h94y1k7Jf?vd_source=5015a9256ea5937110eb7b6ee3e408f7">https://www.bilibili.com/video/BV1h94y1k7Jf?vd_source=5015a9256ea5937110eb7b6ee3e408f7</a></p></blockquote><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>若使用Windows10或11的操作系统，则VMware-workstation-player软件版本尽量在16以上，否则虚拟机开机时会一直蓝屏 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>不同电脑进入Bios的方法不同，具体情况请自行查找 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>ping后面的192.168…为虚拟机的IPv4地址 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仅适用于Windows </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo+Github搭建一个自己的博客</title>
      <link href="/CuteFox_Home.github.io/2023/08/05/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/CuteFox_Home.github.io/2023/08/05/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.准备搭建环境</h1><p>(1)安装适用于Windows系统的Git<br><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>若无法下载，则下载并安装淘宝镜像版的Git<br><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">https://registry.npmmirror.com/binary.html?path=git-for-windows/</a></p><p>(2)安装适用于Windows系统的NodeJs环境(建议使用 Node.js 12.0 及以上版本)<br><a href="https://nodejs.org/zh-cn/download">https://nodejs.org/zh-cn/download</a><br>若无法下载，则下载并安装淘宝镜像版的NodeJs<br><a href="https://registry.npmmirror.com/binary.html?path=node/">https://registry.npmmirror.com/binary.html?path=node/</a></p><p>(3)安装适用于Windows系统的VSCode编译器<br><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p><h5 id="注1：若安装淘宝镜像版nodejs，则输入命令时需用cnpm而非npm"><em>注1：若安装淘宝镜像版nodejs，则输入命令时需用cnpm而非<s>npm</s></em></h5><h5 id="注2：在Windows自带的PowerShell里输入node-v和git-version查看NodeJs和Git是否安装成功"><em>注2：在Windows自带的PowerShell里输入<code>node -v</code>和<code>git version</code>查看NodeJs和Git是否安装成功</em></h5><hr><h1>2.获取SSH公钥</h1><p>(1)创建github账号<br><a href="https://github.com/">https://github.com/</a></p><p>(2)获取本地密钥<br>首先打开 <em>Git Bash</em> ，输入<code>cd ~/.ssh</code>，再输入<code>ls</code>，检查是否有 <em>id_</em> 开头的名字，如果没有则可以创建SSH密钥<br>继续使用 <em>Git Bash</em> 输入<code>ssh-keygen -t ed25519 -C "your_email@example.com"</code><br>一般不设置密码，就一直回车 (<em>enter</em>) 直到出现有图案出现<br>然后再次输入<code>ls</code>，复制有以 <em>id_</em> 开头 <em>pub</em> 结尾的名字，输入<code>cat id_...pub</code>，将得到的SSH公钥内容复制下来</p><p>(3)将SSH公钥绑定gitHub<br>进入github个人页面，点击右上角的头像，在弹出界面找到设置一栏，点击设置再找到 <em>SHH and GPG keys</em><br>点击 <em>SHH and GPG keys</em> ，将复制的SSH公钥内容填进下面方框中，再设置公钥名字并保存</p><h5 id="注1：your-email-example-com替换为自己注册github账号所使用的邮箱"><em>注1：your_email@example.com替换为自己注册github账号所使用的邮箱</em></h5><h5 id="注2：id-…pub替换为自己复制的名字"><em>注2：id_…pub替换为自己复制的名字</em></h5><hr><h1>3.安装Hexo</h1><p>(1)安装 <em>Hexo-CLI</em><br>打开 <em>PowerShell</em> 输入<code>npm install -g hexo-cli</code></p><p>(2)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(3)安装Hexo包并创建文件夹 <em>package</em> ( <em>package</em> 为文件夹名可修改)<br>在 <em>PowerShell</em> 中输入<code>hexo init package</code></p><p>(4)进入文件夹 <em>package</em><br>在 PowerShell* 中输入<code>cd package</code></p><p>(5)再次安装一遍，确保所有的包都安装完成<br>在 <em>PowerShell</em> 中输入<code>npm install</code></p><hr><h1>4.创建网站页面并运行服务器</h1><p>(1)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(2)生成静态网页文件<br>在 <em>PowerShell</em> 中输入<code>hexo g</code></p><p>(3)运行本地服务器<br>在 <em>PowerShell</em> 中输入<code>hexo s</code><br>在返回信息中我们可以得到 <a href="https://localhost:4000">https://localhost:4000</a> 这个端口，输入这个端口链接在浏览器中就能看到网页了</p><hr><h1>5.写作</h1><p>(1)新建一篇文章 <em>title</em> ( <em>title</em> 为标题可修改)<br>在 <em>PowerShell</em> 中输入<code>hexo new "title"</code></p><p>(2)再次生成静态网页文件<br>在 <em>PowerShell</em> 中输入<code>hexo g</code></p><p>(3)再次运行本地服务器<br>在 <em>PowerShell</em> 中输入<code>hexo s</code></p><hr><h1>6.部署网页在github上</h1><p>(1)在github上创建新的仓库<br>点击github右上角的 <em>加号(+)</em> ，选择新建存储库，然后输入自己的项目名字，且在名字后面一定要加上<br><em>.github.io</em> 后缀，还有README初始化也要勾上，最后点击创建即可</p><p>(2)获取SSH链接<br>点击刚刚创建的库上的 <em>code</em> ，选择 <em>SSH</em> ，复制 <em>SSH</em> 下面的内容</p><p>(3)安装插件在本地<br>在 <em>PowerShell</em> 中输入<code>npm install hexo-deployer-git --save</code></p><p>(4)检查插件是否安装成功<br>在 <em>PowerShell</em> 中输入<code>npm list hexo-deployer-git</code></p><p>(5)配置 <em>_config.yml</em> 文件<br>进入 <em>package</em> 文件夹，找到 <em>_config.yml</em> 件，选中它用VSCode打开，往下翻并找到<br><em>deploy:</em> 和 <em>type:</em> ，在 <em>type:</em> 后面写上 <em>git</em> ，并换行写上 <em>repo:</em> ，再在 <em>repo:</em> 后面<br>粘贴上复制好的SSH链接并保存</p><p>(6)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(7)将生成的网站部署到github仓库中<br>在 <em>PowerShell</em> 中输入<code>hexo d</code></p><p>(8)改变部署仓库分支<br>打开 <em>_config.yml</em> 文件，在 <em>repo:</em> 下面写上 <em>branch:</em> ，在 <em>branch:</em> 后面写上想要的分支的名字并保存</p><p>(9)再次部署更新内容到github仓库中<br>在 <em>PowerShell</em> 中输入<code>hexo d</code></p><p>(10)用github页面打开网站<br>在gitHub项目仓库页面的搜索栏下面有一个设置，点击设置并其在左下方找到 <em>页面</em> 一栏，点击页面就能看到<br>有 <em><a href="http://github.io">github.io</a></em> 域名的链接，点击链接即可访问我们创建的网站</p><h5 id="注：如果输入hexo-d-遇到错误，则在输入其之前输入git-config-global-credential-helper-wincred"><em>注：如果输入<code>hexo d </code>遇到错误，则在输入其之前输入<code>git config --global credential.helper wincred</code></em></h5><hr><blockquote><p>参考资料:<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a><br><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p></blockquote><blockquote><p>参考视频:<a href="https://www.youtube.com/watch?v=xvIRGmKWpFM">https://www.youtube.com/watch?v=xvIRGmKWpFM</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 仅适用于Windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
