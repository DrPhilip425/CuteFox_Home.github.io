<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在win11上安装nacos(非dockers环境)</title>
      <link href="/CuteFox_Home.github.io/2025/07/31/%E5%9C%A8win11%E4%B8%8A%E5%AE%89%E8%A3%85nacos-%E9%9D%9Edockers%E7%8E%AF%E5%A2%83/"/>
      <url>/CuteFox_Home.github.io/2025/07/31/%E5%9C%A8win11%E4%B8%8A%E5%AE%89%E8%A3%85nacos-%E9%9D%9Edockers%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1>1.确认版本</h1><p>本教程使用的是<strong>2.4.3</strong>版本</p><h1>2.查询本地IP</h1><pre><code class="language-shell">ipconfig</code></pre><p>找到本机IP：<a href="http://192.168.xxx.xxx">192.168.xxx.xxx</a>，记下来</p><h1>3.解压nacos.zip</h1><h1>4.改properties文件</h1><p>找到<code>D:\nacos\conf\application.properties</code></p><p>①第30行</p><pre><code class="language-properties">### Specify local server's IP:# nacos.inetutils.ip-address=</code></pre><p>改为</p><pre><code class="language-properties">### Specify local server's IP: nacos.inetutils.ip-address=192.168.xxx.xxx</code></pre><hr><p>②第39行</p><pre><code class="language-properties">### Count of DB:# db.num=1</code></pre><p>改为</p><pre><code class="language-properties">### Count of DB: db.num=1</code></pre><hr><p>③第42行</p><pre><code class="language-properties">### Connect URL of DB: db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC db.user.0=nacos db.password.0=nacos</code></pre><p>自行更改nacos所在的数据库配置信息</p><pre><code class="language-properties">### Connect URL of DB: db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC db.user.0=root db.password.0=root</code></pre><hr><p>④第162行</p><pre><code class="language-properties">### The default token (Base64 String):nacos.core.auth.plugin.nacos.token.secret.key=</code></pre><p>自行填充任意基于base64加密的大于等于32位数的密钥key</p><pre><code class="language-properties">### The default token (Base64 String):nacos.core.auth.plugin.nacos.token.secret.key=MTIzNDU2Nzg5MTIzNDU2Nzg5MTIzNDU2Nzg5MTIzNDU2Nzg5</code></pre><hr><p>⑤确保8848端口</p><pre><code class="language-properties">### Default web context path:server.servlet.contextPath=/nacos### Include message fieldserver.error.include-message=ALWAYS### Default web server port:server.port=8848</code></pre><h1>5.改启动和关闭程序</h1><p>找到<code>D:\nacos\bin\startup.cmd</code>和<code>D:\nacos\bin\shutdown.cmd</code></p><p>右键用文本编辑打开<strong>cmd</strong>文件，添加<strong>Java</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>路径</p><pre><code class="language-cmd">set JAVA_HOME="D:\java\jdk-17.0.15+6"</code></pre><p>到下面这段代码的上面</p><pre><code class="language-cmd">if not exist "%JAVA_HOME%\bin\java.exe" echo Please set the JAVA_HOME variable in your environment, We need java(x64)! jdk8 or later is better! &amp; EXIT /B 1set "JAVA=%JAVA_HOME%\bin\java.exe"</code></pre><h1>6.创建nacos数据库</h1><p>在MySQL中新建nacos数据库，新建查询并运行<code> D:\nacos\conf\mysql-schema.sql</code>(即下文)</p><pre><code class="language-mysql">/* * Copyright 1999-2018 Alibaba Group Holding Ltd. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//******************************************//*   表名称 = config_info                  *//******************************************/CREATE TABLE `config_info` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',  `data_id` varchar(255) NOT NULL COMMENT 'data_id',  `group_id` varchar(128) DEFAULT NULL COMMENT 'group_id',  `content` longtext NOT NULL COMMENT 'content',  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',  `src_user` text COMMENT 'source user',  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',  `c_desc` varchar(256) DEFAULT NULL COMMENT 'configuration description',  `c_use` varchar(64) DEFAULT NULL COMMENT 'configuration usage',  `effect` varchar(64) DEFAULT NULL COMMENT '配置生效的描述',  `type` varchar(64) DEFAULT NULL COMMENT '配置的类型',  `c_schema` text COMMENT '配置的模式',  `encrypted_data_key` varchar(1024) NOT NULL DEFAULT '' COMMENT '密钥',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info';/******************************************//*   表名称 = config_info_aggr             *//******************************************/CREATE TABLE `config_info_aggr` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',  `data_id` varchar(255) NOT NULL COMMENT 'data_id',  `group_id` varchar(128) NOT NULL COMMENT 'group_id',  `datum_id` varchar(255) NOT NULL COMMENT 'datum_id',  `content` longtext NOT NULL COMMENT '内容',  `gmt_modified` datetime NOT NULL COMMENT '修改时间',  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段';/******************************************//*   表名称 = config_info_beta             *//******************************************/CREATE TABLE `config_info_beta` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',  `data_id` varchar(255) NOT NULL COMMENT 'data_id',  `group_id` varchar(128) NOT NULL COMMENT 'group_id',  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',  `content` longtext NOT NULL COMMENT 'content',  `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps',  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',  `src_user` text COMMENT 'source user',  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',  `encrypted_data_key` varchar(1024) NOT NULL DEFAULT '' COMMENT '密钥',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta';/******************************************//*   表名称 = config_info_tag              *//******************************************/CREATE TABLE `config_info_tag` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',  `data_id` varchar(255) NOT NULL COMMENT 'data_id',  `group_id` varchar(128) NOT NULL COMMENT 'group_id',  `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id',  `tag_id` varchar(128) NOT NULL COMMENT 'tag_id',  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',  `content` longtext NOT NULL COMMENT 'content',  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',  `src_user` text COMMENT 'source user',  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag';/******************************************//*   表名称 = config_tags_relation         *//******************************************/CREATE TABLE `config_tags_relation` (  `id` bigint(20) NOT NULL COMMENT 'id',  `tag_name` varchar(128) NOT NULL COMMENT 'tag_name',  `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type',  `data_id` varchar(255) NOT NULL COMMENT 'data_id',  `group_id` varchar(128) NOT NULL COMMENT 'group_id',  `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id',  `nid` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'nid, 自增长标识',  PRIMARY KEY (`nid`),  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),  KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation';/******************************************//*   表名称 = group_capacity               *//******************************************/CREATE TABLE `group_capacity` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',  `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群',  `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',  `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量',  `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值',  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',  `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表';/******************************************//*   表名称 = his_config_info              *//******************************************/CREATE TABLE `his_config_info` (  `id` bigint(20) unsigned NOT NULL COMMENT 'id',  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'nid, 自增标识',  `data_id` varchar(255) NOT NULL COMMENT 'data_id',  `group_id` varchar(128) NOT NULL COMMENT 'group_id',  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',  `content` longtext NOT NULL COMMENT 'content',  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',  `src_user` text COMMENT 'source user',  `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip',  `op_type` char(10) DEFAULT NULL COMMENT 'operation type',  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',   `encrypted_data_key` varchar(1024) NOT NULL DEFAULT '' COMMENT '密钥',  PRIMARY KEY (`nid`),  KEY `idx_gmt_create` (`gmt_create`),  KEY `idx_gmt_modified` (`gmt_modified`),  KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造';/******************************************//*   表名称 = tenant_capacity              *//******************************************/CREATE TABLE `tenant_capacity` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',  `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID',  `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',  `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量',  `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数',  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',  `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表';CREATE TABLE `tenant_info` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',  `kp` varchar(128) NOT NULL COMMENT 'kp',  `tenant_id` varchar(128) default '' COMMENT 'tenant_id',  `tenant_name` varchar(128) default '' COMMENT 'tenant_name',  `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc',  `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source',  `gmt_create` bigint(20) NOT NULL COMMENT '创建时间',  `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间',  PRIMARY KEY (`id`),  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),  KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info';CREATE TABLE `users` (`username` varchar(50) NOT NULL PRIMARY KEY COMMENT 'username',`password` varchar(500) NOT NULL COMMENT 'password',`enabled` boolean NOT NULL COMMENT 'enabled');CREATE TABLE `roles` (`username` varchar(50) NOT NULL COMMENT 'username',`role` varchar(50) NOT NULL COMMENT 'role',UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE);CREATE TABLE `permissions` (    `role` varchar(50) NOT NULL COMMENT 'role',    `resource` varchar(128) NOT NULL COMMENT 'resource',    `action` varchar(8) NOT NULL COMMENT 'action',    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE);</code></pre><h1>7.启动单例模式</h1><p>在<code>D:\nacos\bin</code>中打开 <strong>cmd</strong></p><pre><code class="language-cmd">startup.cmd -m standalone</code></pre><h1>8.在IDEA中改配置，注意格式不能错</h1><p>1.给父类<code>pom.xml</code>文件添加依赖</p><pre><code class="language-xml">        &lt;!-- 注册中心 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>2.在<code>application.yml</code>中配置nacos服务地址</p><pre><code class="language-yaml">  # 注册中心服务器地址  cloud:    nacos:      server-addr: 127.0.0.1:8848</code></pre><h2 id="9-建议">9.建议</h2><p>把IDEA该路径<code>D:..\.IntelliJIdea\system</code>文件夹和编写的Java代码文件夹加入Microsoft Defender排除项</p><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>建议jdk8以上 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android6.0的旧手机玩Termux</title>
      <link href="/CuteFox_Home.github.io/2023/10/31/Android6-0%E7%9A%84%E6%97%A7%E6%89%8B%E6%9C%BA%E7%8E%A9Termux/"/>
      <url>/CuteFox_Home.github.io/2023/10/31/Android6-0%E7%9A%84%E6%97%A7%E6%89%8B%E6%9C%BA%E7%8E%A9Termux/</url>
      
        <content type="html"><![CDATA[<h1>1.旧手机安装Termux软件</h1><blockquote><p>因为我用的是旧手机，<strong>Android版本为6.0且没有被root</strong>，所以我选用<em>Termux</em>来模拟<em>Linux环境</em></p></blockquote><p>termux官方的github-actions里给了适合Android5.0和6.0版本的<a href="https://github.com/termux/termux-app/actions/workflows/debug_build.yml?query=branch%3Amaster+event%3Apush">应用压缩包</a><br>我是用的是<a href="https://github.com/termux/termux-app/suites/17389451010/artifacts/993775523">0.118.0通用版的termux</a>，解压缩后就可以得到相应版本的termux安装包</p><h1>2.查看termux官方源给的可以安装的包</h1><pre><code class="language-bash">pkg list-all</code></pre><p>在某个包后面如果出现了<em>installed</em>，则说明这个包<strong>已经被安装了</strong>；第一步先查看官方源给的包的原因是当我们使用命令<code>pkg install 某个package</code>来安装<strong>某个包</strong>时，如果出现了<code>Unable to locate package 某个package</code>，是因为你想安装的<strong>这个包</strong>不在官方给的源里，需要另外去添加<strong>别人的源</strong></p><h1>3.添加源或更换源</h1><pre><code class="language-bash">pkg install vim</code></pre><p>首先得安装<em>vim</em>这个文字编辑器，我这里用的是vim，不会vim语法的可以自行搜索</p><pre><code class="language-bash">pkg install nano</code></pre><p>或者安装<em>nano</em>这个文字编辑器，看自己哪个可以安装或者哪个熟悉就用哪个</p><pre><code class="language-bash">vim $PREFIX/etc/apt/sources.list</code></pre><p>进入官方的源文件，在<em>手机输入法键盘</em>按<code>i</code>即可进入<em>编辑模式</em>，你可以在官方源前面加上<code>#</code>来注释保留，也可以删掉换成其他的源比如换成<em>清华源</em><code>deb https://mirrors.tuna.tsinghua.edu.cn/termux/termux-packages-24 stable main</code>，当然也可以换成其他的源，这个可以自行搜索；<br>更改完成后，先在termux的<em>虚拟键盘</em>上按<code>ESC</code>进入<em>命令模式</em>，再在<em>手机输入法键盘</em>上依次输入<code>:wq</code>即可<strong>保存并退出</strong>vim</p><pre><code class="language-bash">vim $PREFIX/etc/apt/sources.list.d/science.list</code></pre><p><code>science.list</code>也和上面的<code>sources.list</code>差不多，可以换成清华源<code>deb https://mirrors.tuna.tsinghua.edu.cn/termux/science-packages-24 science stable</code>，再保存并退出</p><pre><code class="language-bash">vim $PREFIX/etc/apt/sources.list.d/game.list</code></pre><p><code>game.list</code>也可以换成清华源<code>deb https://mirrors.tuna.tsinghua.edu.cn/termux/game-packages-24 games stable</code>，再保存并退出</p><blockquote><p>因为我在清华源和中科大的源里找不到一些termux官方源有的包，所以我没有更换源，就用的官方源，如果官方源安装不了包可能是网络问题，需要科学上网</p></blockquote><h1>4.给termux更换配色</h1><pre><code class="language-bash">termux-setup-storage #先得让termux获取手机存储权限pkg install curl</code></pre><p>首先安装<code>curl</code>以执行下面命令</p><pre><code class="language-bash">sh -c "$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)" </code></pre><p>然后这个命令会打开一个脚本，这个脚本先会弹出<code>Enter a number, leave blank to not to change: </code>，可以输入数字<code>0-43</code>来选择你想要的<code>色彩</code>，你也可以在全部选择完成后，重新在termux中输入<code>chcolor</code>，它会列出具体的<code>0-43</code>这44种<code>色彩</code>；<br>接着又会出现一个<code>Enter a number, leave blank to not to change: </code>，也可以输入数字<code>0-26</code>来选择你想要的<code>字体</code>，你也可以在全部选择完成后，重新在termux中输入<code>chfont</code>，它会列出具体的<code>0-26</code>这27种<code>字体</code></p><h1>5.给termux更改启动问候语</h1><pre><code class="language-bash">vim $PREFIX/etc/motd</code></pre><p>依旧输入<code>i</code>进行编辑，例如你可以复制粘贴国光大佬的</p><pre><code> _____                              |_   _|__ _ __ _ __ ___  _   ___  __  | |/ _ \ '__| '_ ` _ \| | | \ \/ /  | |  __/ |  | | | | | | |_| |&gt;  &lt;   |_|\___|_|  |_| |_| |_|\__,_/_/\_\</code></pre><p>也可以试试我的，然后保存退出后重进termux就可以了</p><pre><code>      /\     __       ~~  ____   ____     //\\    ||       ||   ||   / __ \    //——\\   ||____   ||   ||  | \__\ \   //    \\  |_____|  ||   ||   \____/\\    </code></pre><h1>6.安装编译环境</h1><h2 id="6-1安装Clang">6.1安装Clang</h2><pre><code class="language-bash">pkg install clang</code></pre><p>安装完clang后就能在termux写<em>C和C++语言</em>，例如</p><pre><code class="language-bash">vim hello.c</code></pre><pre><code class="language-C">#include&lt;stdio.h&gt;  int main(){    printf("Hello friends!");    return 0;}</code></pre><p>先创建一个<em>C语言的文件</em>，再写入上面内容并保存退出</p><pre><code class="language-bash">clang hello.c -o hellols</code></pre><p>然后编译这个C语言文件并列出当前目录的文件有哪些，输入<code>ls</code>后你就可以看到有一个<code>hello</code>的文件</p><pre><code class="language-bash">./hello</code></pre><p>这样就能运行编译后的hello文件，然后你会看见<code>Hello friends!</code>输出在屏幕上了</p><h2 id="6-2安装python">6.2安装python</h2><pre><code class="language-bash">pkg install python -ypython -V #查看python的版本</code></pre><p>这里默认安装的是<em>python3</em>而不是<em>python2</em>，如果需要安装<em>python2</em>，则输入下面即可</p><pre><code class="language-bash">pkg install python2 -y</code></pre><h2 id="6-3安装nodejs">6.3安装nodejs</h2><pre><code class="language-bash">pkg install nodejs-lts #lts为长期支持版本</code></pre><blockquote><p>注意别用<code>pkg install nodejs</code>，不然你会发现你用<code>npm</code>的时候下不了一些<code>node_modules</code>；如果安装了就<code>pkg uninstall nodejs</code>，再重新安装<code>nodejs-lts</code></p></blockquote><h2 id="6-4安装http-server">6.4安装http-server</h2><pre><code class="language-bash">npm install -g http-server</code></pre><p>然后运行<code>http-server</code></p><pre><code class="language-bash">http-server</code></pre><p>你可以看到它给出了一个<code>http:127.0.0.1:8080</code>的<em>url</em>，然后你用手机的浏览器访问这个<em>url</em>就能看到你<em>termux的文件夹</em>的内容了；接着在<em>termux</em>中按一下<em>虚拟键盘</em>上的<code>CTRL</code>和你<em>手机输入法键盘</em>上的<code>c</code>即可退出</p><h2 id="6-5安装MariaDB-MySQL">6.5安装MariaDB(MySQL)</h2><pre><code class="language-bash">pkg install mariadbmysql --version #查看mysql版本</code></pre><pre><code class="language-bash">nohup mysqld &amp; #用Linux自带的nohup启动</code></pre><p>mysql安装好就能启动，<strong>不需要</strong>初始化！能启动成功说明mysql已经安装好了</p><pre><code class="language-bash">kill -9 `pgrep mysql` #关掉mysql的进程</code></pre><h1>7.安装Aria2来下载东西</h1><h2 id="7-1安装aria2">7.1安装aria2</h2><pre><code class="language-bash">pkg install aria2aria2c -v #查看aria2的版本</code></pre><blockquote><p>要注意的是<em>aria2</em>的命令是<code>aria2c</code>而不是<code>aria2</code></p></blockquote><h2 id="7-2创建aria2的配置文件、数据文件和日志文件">7.2创建aria2的配置文件、数据文件和日志文件</h2><pre><code class="language-bash">touch aria2.conf #配置文件touch aria2.session #数据文件touch aria2.log #日志文件</code></pre><h3 id="7-2-1自定义aria2的配置文件">7.2.1自定义aria2的配置文件</h3><pre><code class="language-bash">readlink -f aria2.session #获取aria2.session文件的完整路径，并记下来readlink -f aria2.log #获取aria2.log文件的完整路径，并记下来readlink -f aria2.conf #获取aria2.conf文件的完整路径，并记下来</code></pre><p>上面两个文件<code>aria2.session</code>和<code>aria2.log</code>的路径要记住，因为后面配置<code>aria2.conf</code>的时候需要用到</p><pre><code class="language-bash">vim aria2.conf</code></pre><p>进入我们之前新建的<code>aria2.conf</code>文件，复制粘贴下面的内容</p><pre><code>##===================================#### 文件保存相关 ####===================================### 文件保存目录dir=[下载文件夹位置]# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16Mdisk-cache=16M# 断点续传continue=true#日志保存log=[日志文件位置/aria2.log]# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项file-allocation=prealloc##===================================#### 下载连接相关 ####===================================### 最大同时下载任务数, 运行时可修改, 默认:5max-concurrent-downloads=10# 同一服务器连接数, 添加时可指定, 默认:1# 官方的aria2最高设置为16, 如果需要设置任意数值请重新编译aria2max-connection-per-server=16# 整体下载速度限制, 运行时可修改, 默认:0（不限制）max-overall-download-limit=0# 单个任务下载速度限制, 默认:0（不限制）max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0（不限制）max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0（不限制）max-upload-limit=0# 禁用IPv6, 默认:falsedisable-ipv6=false# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5# 建议同max-connection-per-server设置为相同值split=16##===================================#### 进度保存相关 ####===================================### 从会话文件中读取下载任务input-file=[数据文件保存位置/aria2.session]# 在Aria2退出时保存错误的、未完成的下载任务到会话文件save-session=[数据文件保存位置/aria2.session]# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0save-session-interval=60##===================================#### RPC相关设置 ####此部分必须启用，否则无法使用WebUI##===================================### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许外部访问, 默认:falserpc-listen-all=true# RPC端口, 仅当默认端口被占用时修改rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=# 启动SSL# rpc-secure=true# 证书文件, 如果启用SSL则需要配置证书文件, 例如用https连接aria2# rpc-certificate=# rpc-private-key=##===================================#### BT/PT下载相关 ####===================================### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:truefollow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=true# 打开IPv6 DHT功能, PT需要禁用enable-dht6=true# DHT网络监听端口, 默认:6881-6999dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:falsebt-enable-lpd=true# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=true# 每个种子限速, 对少种的PT很有用, 默认:50Kbt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件force-save=true# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true# 单个种子最大连接数, 默认:55 0表示不限制bt-max-peers=0# 最小做种时间, 单位:分# seed-time = 60# 分离做种任务bt-detach-seed-only=true#BT Tracker List ;下载地址：https://cdn.jsdelivr.net/gh/XIU2/TrackersListCollection/best_aria2.txt#页面地址：https://github.com/XIU2/TrackersListCollection/blob/master/README-ZH.mdbt-tracker=http://all4nothin.net:80/announce.php,http://kinorun.com:80/announce.php,http://masters-tb.com:80/announce.php,http://mediaclub.tv:80/announce.php,http://milanesitracker.tekcities.com:80/announce,http://nyaa.tracker.wf:7777/announce,http://open.acgnxtracker.com:80/announce,http://openbittorrent.com:80/announce,http://opentracker.xyz:80/announce,http://share.camoe.cn:8080/announce,http://t.nyaatracker.com:80/announce,http://torrent-team.net:80/announce.php,http://torrentzilla.org:80/announce,http://torrentzilla.org:80/announce.php,http://tr.cili001.com:8070/announce,http://tracker.files.fm:6969/announce,http://tracker.gbitt.info:80/announce,http://tracker.ipv6tracker.ru:80/announce,http://tracker.tfile.me:80/announce,http://tracker.torrentyorg.pl:80/announce,http://vps02.net.orel.ru:80/announce,http://www.all4nothin.net:80/announce.php,https://1337.abcvg.info:443/announce,https://carbon-bonsai-621.appspot.com:443/announce,https://tr.ready4.icu:443/announce,https://tr.torland.ga:443/announce,https://tracker.imgoingto.icu:443/announce,https://tracker.kuroy.me:443/announce,https://tracker.lilithraws.cf:443/announce,https://tracker.nitrix.me:443/announce,https://tracker.parrotsec.org:443/announce,https://tracker.tamersunion.org:443/announce,https://trackme.theom.nz:443/announce,udp://9.rarbg.com:2810/announce,udp://abufinzio.monocul.us:6969/announce,udp://bt1.archive.org:6969/announce,udp://bt2.archive.org:6969/announce,udp://code2chicken.nl:6969/announce,udp://discord.heihachi.pw:6969/announce,udp://engplus.ru:6969/announce,udp://escorts.subventas.com:53/announce,udp://exodus.desync.com:6969/announce,udp://fe.dealclub.de:6969/announce,udp://ipv6.tracker.monitorit4.me:6969/announce,udp://ipv6.tracker.zerobytes.xyz:16661/announce,udp://jeremylee.sh:6969/announce,udp://mail.realliferpg.de:6969/announce,udp://movies.zsw.ca:6969/announce,udp://open.demonii.com:1337/announce,udp://open.tracker.cl:1337/announce,udp://opentor.org:2710/announce,udp://p4p.arenabg.com:1337/announce,udp://retracker.hotplug.ru:2710/announce,udp://thetracker.org:80/announce,udp://tracker-de.ololosh.space:6969/announce,udp://tracker.0x.tf:6969/announce,udp://tracker.altrosky.nl:6969/announce,udp://tracker.auctor.tv:6969/announce,udp://tracker.beeimg.com:6969/announce,udp://tracker.birkenwald.de:6969/announce,udp://tracker.bitsearch.to:1337/announce,udp://tracker.blacksparrowmedia.net:6969/announce,udp://tracker.dler.com:6969/announce,udp://tracker.haynet.io:6969/announce,udp://tracker.jordan.im:6969/announce,udp://tracker.leech.ie:1337/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.monitorit4.me:6969/announce,udp://tracker.ololosh.space:6969/announce,udp://tracker.openbittorrent.com:6969/announce,udp://tracker.opentrackr.org:1337/announce,udp://tracker.pomf.se:80/announce,udp://tracker.theoks.net:6969/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.zerobytes.xyz:1337/announce,udp://tracker0.ufibox.com:6969/announce,udp://tracker1.bt.moack.co.kr:80/announce,udp://tracker2.dler.com:80/announce,udp://tracker2.dler.org:80/announce,udp://u.wwwww.wtf:1/announce,udp://udp-tracker.shittyurl.org:6969/announce,udp://vibe.sleepyinternetfun.xyz:1738/announce,udp://www.torrent.eu.org:451/announce,wss://tracker.openwebtorrent.com:443/announce</code></pre><p>修改上面的<code>[下载文件夹位置]</code>，去掉<code>[]</code>把它换成由<code>/</code>组成的你想放在安卓内存中的位置如<code>/storage/emulated/0/Dowmload</code>；修改<code>[日志文件位置/aria2.log]</code>，去掉<code>[]</code>把它换成由<code>/</code>组成的刚刚获取的<code>touch aria2.log</code>文件的完整路径；修改<code>[数据文件保存位置/aria2.session]</code>，去掉<code>[]</code>把它换成由<code>/</code>组成的刚刚获取的<code>aria2.session</code>文件的完整路径；然后保存并退出</p><h2 id="7-3启动aria2的rpc服务">7.3启动aria2的rpc服务</h2><pre><code class="language-bash">aria2c --conf-path=[aria2.conf文件路径/aria2.conf] #注意要删除[]，aria2.conf文件路径为我们刚刚获取的路径</code></pre><p>启动aria2的rpc服务后termux可能输入不了命令了，这时可以选择<strong>从左边向右滑动屏幕</strong>新建一个<em>termux会话窗口</em>或直接退出termux</p><h3 id="7-3-1把aria2的rpc服务放入后台启动">7.3.1把aria2的rpc服务放入后台启动</h3><pre><code class="language-bash">aria2c --conf-path=[aria2.conf文件路径/aria2.conf] -D #在启动aria2的基础上加一个-D即可</code></pre><h3 id="7-3-2实现打开termux后其后台自动启动aria2的rpc服务">7.3.2实现打开termux后其后台自动启动aria2的rpc服务</h3><pre><code class="language-bash">readlink -f .zshrc #获取.zshrc文件的完整路径vim /data/data/com.termux/files/home/.zshrc #打开.zshrc文件，/data/data/com.termux/files/home路径用你刚刚获取的，我的路径是这样的:/data/data/com.termux/files/home</code></pre><p>用vim打开<code>.zshrc</code>文件后，添加下面内容到最后一行，然后保存并退出</p><pre><code>aria2c --conf-path=[aria2.conf文件路径/aria2.conf] -D</code></pre><h3 id="7-3-3自定义短命令后台启动aria2的rpc服务">7.3.3自定义短命令后台启动aria2的rpc服务</h3><p>和上面一样打开<code>.zshrc</code>文件，把下面内容添加到刚刚添加的那行的上一行即<strong>倒数第二行</strong></p><pre><code>alias aria2c-s='aria2c --conf-path=[aria2.conf文件路径/aria2.conf] -D' </code></pre><p>上面的<code>aria2c-s</code>可以<strong>自定义</strong>要后台启动aria2的rpc服务的<em>短命令</em>，我改成的是<code>aria2c-s</code></p><h2 id="7-4安装并启动webui-aria2本地管理服务器">7.4安装并启动webui-aria2本地管理服务器</h2><h3 id="7-4-1安装git">7.4.1安装git</h3><pre><code class="language-bash">pkg install git</code></pre><h3 id="7-4-2克隆webui-aria2项目">7.4.2克隆webui-aria2项目</h3><pre><code class="language-bash">git clone https://github.com/ziahamza/webui-aria2.git</code></pre><h3 id="7-4-3启动webui-aria2本地管理服务器">7.4.3启动webui-aria2本地管理服务器</h3><pre><code class="language-bash">cd webui-aria2 #进入webui-aria2文件夹node node-server.js #启动webui-aria2</code></pre><p>启动<code>webui-aria2</code>完成后会看到termux已提示有<code>localhost:8888</code>了，然后我们打开浏览器输入<code>127.0.0.1:8888</code>即可看到<code>webui-aria2的本地管理服务器GUI</code></p><h2 id="7-5把aria2作为服务器来下载内容">7.5把aria2作为服务器来下载内容</h2><blockquote><p>因为本人没有申请<code>公网IP</code>，所以只能借助<code>内网穿透</code>试试看了，我目前只试了<code>cpolar</code>这个内网穿透的服务，因为可以直接在termux上操作（比较方便）；但还是可以去试试其他延迟比较低的内网穿透服务，我个人就不在这里推荐了，因为免费的服务它的延迟可能都那样（确信</p></blockquote><h3 id="7-5-1创建sources-list-d文件夹">7.5.1创建sources.list.d文件夹</h3><pre><code class="language-bash">mkdir -p $PREFIX/etc/apt/sources.list.d</code></pre><h3 id="7-5-2添加cpolar源">7.5.2添加cpolar源</h3><pre><code class="language-bash">echo "deb [trusted=yes] http://termux.cpolar.com termux extras" &gt;&gt; $PREFIX/etc/apt/sources.list.d/cpolar.list</code></pre><h3 id="7-5-3更新库">7.5.3更新库</h3><pre><code class="language-bash">pkg update</code></pre><h3 id="7-5-4安装cpolar">7.5.4安装cpolar</h3><pre><code class="language-bash">pkg install cpolar</code></pre><h3 id="7-5-5安装termux服务">7.5.5安装termux服务</h3><pre><code class="language-bash">pkg install termux-services</code></pre><blockquote><p>安装完termux服务后记得退出termux重新进一次才能生效</p></blockquote><h3 id="7-5-6启动和关闭cpolar服务">7.5.6启动和关闭cpolar服务</h3><pre><code class="language-bash">sv up cpolar #启动sv down cpolar #关闭</code></pre><h3 id="7-5-7设置开机自启cpolar服务">7.5.7设置开机自启cpolar服务</h3><pre><code class="language-bash">sv-enable cpolar</code></pre><h3 id="7-5-8进入cpolar的GUI界面">7.5.8进入cpolar的GUI界面</h3><p>在浏览器中输入<code>127.0.0.1:9200</code>即可打开该页面，打开后会有一个登录界面，用邮箱去<strong>注册</strong>一个新的账户，然后选择<strong>免费的套餐</strong>就可以用cpolar的内网穿透服务了</p><h3 id="7-5-9创建8888端口的隧道">7.5.9创建8888端口的隧道</h3><p>①点击cpolar的GUI界面左边导航栏的<code>隧道管理</code>，然后选择<code>创建隧道</code>；<br>②<code>隧道名字</code>任意取即可；<br>③<code>协议</code>选择<code>http</code>；<br>④<code>本地地址</code>填入<code>8888</code>（也就是我们<code>webui-aria2的本地管理服务器GUI</code>的端口号）；<br>⑤然后<code>域名类型</code>选择<code>随机域名</code>（如果自己有多的域名也好像可以选择自定义域名，不过我没试过；选这个<code>随机域名</code>有个<strong>缺点</strong>，就是说你创建的这个<code>公网隧道链接</code>可能过了一段时间就用不了，得重新刷新这个界面才会显示新的<code>公网隧道链接</code>）；<br>⑥<code>地区</code>选择<code>China Top</code>就好了，因为选其他的的话，如果没有开会员，可能用不了或延时比较高<br>⑦点击<code>创建</code>即可</p><h3 id="7-5-10查找公网隧道链接">7.5.10查找公网隧道链接</h3><p>点击cpolar的GUI界面左边导航栏的<code>状态</code>，然后选择<code>在线隧道列表</code>，在右边列表的<code>公网地址</code>那一列即可看到以<code>http</code>和<code>https</code>开头的就是我们<code>webui-aria2的本地管理服务器GUI</code>的<code>公网隧道链接</code>了</p><h3 id="7-5-11通过其他设备访问公网隧道链接">7.5.11通过其他设备访问公网隧道链接</h3><p>打开其他设备的浏览器，输入刚刚创建的<code>公网隧道链接</code>即可（虽然但是，内网穿透服务的延迟太高效果可能也不好；还有值得注意的一点是，<code>安装termux本机</code>的<code>8888</code>端口<strong>只是</strong><code>aria2</code>的<code>GUI界面</code>，还要确保<code>aria2</code>的<code>rpc</code>服务能够连上才能通过其他设备远程使用<code>安装termux本机</code>上的<code>aria2</code>来下载东西）</p><h1>8.安装kali-nethunter系统</h1><h2 id="8-1安装wget">8.1安装wget</h2><pre><code class="language-bash">pkg install wget</code></pre><h2 id="8-2安装kali官网的脚本">8.2安装kali官网的脚本</h2><pre><code class="language-bash">wget -O install-nethunter-termux https://offs.ec/2MceZWr</code></pre><h2 id="8-3给kali脚本执行权限并运行">8.3给kali脚本执行权限并运行</h2><pre><code class="language-bash">chmod +x install-nethunter-termux ./install-nethunter-termux</code></pre><p>安装完成后会有<code>kali的图标</code>和<code>命令行提示</code>出现，输入<code>nh</code>即可打开<code>kali-nethunter的终端</code>，输入<code>exit</code>即可退出</p><blockquote><p>安装过程有点漫长，毕竟超过1GB了，如果像我一样安装<code>原版kali</code>且手机<code>没有被root</code>可能会遇到它一直在<code>extracting rootfs</code>即<code>提取root文件</code>，那得继续等，直到它提取失败后，问是否要重试，我直接选的否，因为我实在不想折腾刷机这块了；如果手机已经被root了，那应该畅通无阻，除非不会科学上网</p></blockquote><h2 id="8-4开启kex-VNC-服务进行远程连接kali桌面">8.4开启kex(VNC)服务进行远程连接kali桌面</h2><h3 id="8-4-1创建连接密码">8.4.1创建连接密码</h3><pre><code class="language-bash">nh kex passwd</code></pre><p>然后会弹出提示输入一次，再验证输入一次即可</p><h3 id="8-4-2下载远程连接软件–VNC-Viewer或NetHunter-KeX">8.4.2下载远程连接软件–VNC Viewer或NetHunter KeX</h3><ul><li><a href="https://www.realvnc.com/en/connect/download/viewer/">VNC-Viewer</a></li><li><a href="https://store.nethunter.com/en/packages/com.offsec.nethunter.kex/">NetHunter KeX</a></li></ul><h3 id="8-4-3启动kex服务">8.4.3启动kex服务</h3><pre><code class="language-bash">nh kex &amp;</code></pre><p>启动后会开启<code>5901端口</code></p><blockquote><p>可能会有警告<code>no matching vnc server running for this user</code>，但好像可以正常使用，因为我安装了<code>nmap</code>，用<code>nmap 127.0.0.1</code>扫描主机号后发现确实有<code>5901端口</code></p></blockquote><h3 id="8-4-4用远程连接软件连接5901端口">8.4.4用远程连接软件连接5901端口</h3><p>打开<code>VNC Viewer</code>或<code>NetHunter KeX</code>，在<em>主机地址</em>那填上<code>127.0.0.1</code>，<em>端口号</em>填<code>5901</code>，<code>VNC Viewer</code>连接后还需要输入刚刚在termux创建连接时的密码，而<code>NetHunter KeX</code>则是<em>主机地址和端口号以及密码</em>都要填才能连接</p><blockquote><p>如果你和我一样在这出现了<strong>连接上了</strong>但只有<em>报错提示</em>的话，可以参考下<a href="https://bbs.x10001.com/forum-post/1534.html">这篇文章</a>，虽然我没成功，因为termux的官方源里没有<code>rinetd</code>这个包</p></blockquote><h1>9.安装Ubuntu或其他Linux发行版</h1><blockquote><p>直接用上国光大佬写的脚本</p></blockquote><h2 id="9-1安装proot来模拟root">9.1安装proot来模拟root</h2><pre><code class="language-bash">pkg install proot</code></pre><h2 id="9-2克隆Linux发行版安装脚本项目">9.2克隆Linux发行版安装脚本项目</h2><pre><code class="language-bash">git clone https://github.com/sqlsec/termux-install-linux</code></pre><h2 id="9-3运行Linux发行版安装脚本">9.3运行Linux发行版安装脚本</h2><pre><code class="language-bash">cd termux-install-linux python termux-linux-install.py</code></pre><p>直接选择数字安装或卸载想要安装的Linux发行版即可，这点毫无压力</p><h2 id="9-4启动Ubuntu终端">9.4启动Ubuntu终端</h2><pre><code class="language-bash">cd ~/Termux-Linux/Ubuntu./start-ubuntu.sh</code></pre><p>输入<code>exit</code>即可退出<code>Ubuntu终端</code></p><h1>10.通过SSH用电脑连接手机的termux</h1><h2 id="10-1查看自己的IP地址">10.1查看自己的IP地址</h2><pre><code class="language-bash">ifconfig </code></pre><p>在<code>wlan0</code>下面，以<code>192.168</code>开头的就是自己的IP地址，然后记下来</p><h2 id="10-2查看自己的用户名">10.2查看自己的用户名</h2><pre><code class="language-bash">whoami</code></pre><p><code>u0_</code>开头的这个就是，也记下来</p><h2 id="10-3安装openSSH">10.3安装openSSH</h2><pre><code class="language-bash">pkg install opensshpasswd</code></pre><p>安装完成后输入<code>passwd</code>，填写两次连接时的密码</p><h2 id="10-4安装nmap">10.4安装nmap</h2><pre><code class="language-bash">pkg install nmap</code></pre><h2 id="10-5电脑上安装xshell">10.5电脑上安装xshell</h2><ul><li><a href="https://www.netsarang.com/zh/xshell/">xshell</a></li></ul><h2 id="10-6手机上termux开启ssh">10.6手机上termux开启ssh</h2><pre><code class="language-bash">sshd</code></pre><h2 id="10-7电脑xshell连接手机termux">10.7电脑xshell连接手机termux</h2><p>在xshell左上角点击<em>新建会话</em>的图标，主机号输入之前查询的自己的IP地址，端口号填<code>8022</code>，之后会弹出验证用户名，输入之前查询的用户名即可，完成后就能在电脑上敲命令执行termux的任务了！</p><hr><br><blockquote><p>参考资料1：<a href="https://www.sqlsec.com/2018/05/termux.html">Termux 高级终端安装使用配置教程</a><br>参考资料2：<a href="https://www.bilibili.com/read/cv14084579/">优雅地使用完美版Termux-Aria2服务器（带本地GUI管理）以及ipv6的公网访问</a><br>参考资料3：<a href="https://blog.csdn.net/weixin_42599499/article/details/111185609">Termux的安装、换源、基本库安装、基本操作讲解以及Termux的使用心得</a><br>参考资料4：<a href="https://www.cpolar.com/blog/install-mysql-on-android-termux-and-use-cpolar-for-secure-remote-access">Android Termux安装MySQL，内网穿透实现公网远程访问</a></p></blockquote><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Termux </tag>
            
            <tag> Aria2 </tag>
            
            <tag> cpolar </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> Kali-Nethunter </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 电脑SSH远程手机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/10/06/Java%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/10/06/Java%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>1.基本结构</h1><br><h2 id="1-1文件名与类名">1.1文件名与类名</h2><pre><code class="language-Java">public class HelloWorld{    public static void main(String[] args){        System.out.println("hello,world!你好，世界！");    }}</code></pre><p>①<code>public class 类名</code>这个<code>public</code>只能有<strong>一个</strong><br>②<code>文件名.java</code>这个<em>文件名</em>要和<code>public class 类名</code>的<em>类名</em><strong>一样</strong>；就如上面代码中<em>类名</em>是<code>HelloWorld</code>，则该<code>.java</code>文件的<em>文件名</em>也必须是<code>HelloWorld</code></p><br><h2 id="1-2main程序执行的入口">1.2<code>main</code>程序执行的入口</h2><pre><code class="language-Java">public class HelloWorld{    public static void main(String[] args){        System.out.println("hello,world!你好，世界！");    }}class HelloChina{    public static void main(String a[]){        System.out.println("hello,world!你好，中国！");    }}</code></pre><p>①<code>public static void main(String[] args)</code>是一个<strong>可执行的</strong>Java程序<strong>必须</strong>有的，因为它是执行语句的<strong>入口</strong><br>②<code>public static void main(String[] args)</code>其中的<code>String[] args</code>可以写成<code>String arg[]</code>，<code>arg</code>也可以改成<strong>任意</strong>可表示<strong>数组</strong>的符号如<code>a</code>等；有<code>public</code>是因为它<strong>权限最大</strong>，有<code>static</code>是因为它<strong>与类相关</strong>，有<code>void</code>是因为它<strong>在栈帧最底部</strong>不需要返回值<br>③<strong>一个</strong>Java程序里可以有多个<code>main</code></p><br><h1>2.输出与输入</h1><br><h2 id="2-1输出">2.1输出</h2><pre><code class="language-Java">public class PrintTest{    public static void main(String[] args){    System.out.print(); //只输出，不换行    System.out.print(""+"\n"); //先输出后换行    System.out.println(); //先输出后换行    System.out.println("abc123"); //双引号里写字符串    System.out.println(123+4); //整数直接计算    System.out.println(0.1+0.2); //输出不是0.3，而是0.30000000000000004，因为现代编译器基本采用IEEE 754标准，所以不能实现每一个十进制小数对应一个二进制小数    System.out.println("Stu"+"dent"); //+(加号)为连接符    int a=1;    int b=1;    System.out.println(a==b); //==(连等号)为判断是否相等的符号    }}</code></pre><br><h2 id="2-2输入">2.2输入</h2><pre><code class="language-Java">import java.util.Scanner; //导入Java的util包里的Scanner类public class ScanTest{    public static void main(String[] args){        Scanner n=new Scanner(System.in); //创建Scanner类型的对象n，并使n能够获取控制台输入的功能即Scanner(System.in)        String name=n.next(); //创建String类型的对象name，把对象n的next()方法赋值给name，并开始输入name的值        System.out.println("name:"+name); //输出刚刚输入的name    }}</code></pre><br><h1>3.基本数据类型</h1><br><h2 id="3-1-byte">3.1 byte</h2><pre><code class="language-Java">{    byte b1=-128;    byte b2=127;    System.out.println(b1+"\n"+b2);}</code></pre><p>①<em>byte</em>类型的<strong>范围</strong>是<code>-128~127</code>(即<code>-2^7~2^7-1</code>)<br>②<strong>1</strong>个<em>byte</em>占<strong>1</strong>个字节(<code>Byte</code>)，<strong>8</strong>位(<code>bit</code>)</p><br><h2 id="3-2-short">3.2 short</h2><pre><code class="language-Java">{    short s1=-32768;    short s2=32767;    System.out.println(s1+"\n"+s2);}</code></pre><p>①<em>short</em>类型的<strong>范围</strong>是<code>-32768~32767</code>(即<code>-2^15~2^15-1</code>)<br>②<strong>1</strong>个<em>short</em>占<strong>2</strong>个字节(<code>Byte</code>)，<strong>16</strong>位(<code>bit</code>)</p><br><h2 id="3-3-int">3.3 int</h2><pre><code class="language-Java">{    int i1=-2147483648;    int i2=2147483647;    System.out.println(i1+"\n"+i2);}</code></pre><p>①<em>int</em>类型的<strong>范围</strong>是<code>-2147483648~2147483647</code>(即<code>-2^31~2^31-1</code>)<br>②<strong>1</strong>个<em>int</em>占<strong>4</strong>个字节(<code>Byte</code>)，<strong>32</strong>位(<code>bit</code>)</p><br><h2 id="3-4-long">3.4 long</h2><pre><code class="language-Java">{    long l1=-9223372036854775808L;    long l2=9223372036854775807L;    System.out.println(l1+"\n"+l2);}</code></pre><p>①<em>long</em>类型的<strong>范围</strong>是<code>-9223372036854775808~9223372036854775807</code>(即<code>-2^63~2^63-1</code>)<br>②<em>long</em>类型在<strong>数字的末尾</strong>要加上<code>L或l</code><br>③<strong>1</strong>个<em>long</em>占<strong>8</strong>个字节(<code>Byte</code>)，<strong>64</strong>位(<code>bit</code>)</p><br><h2 id="3-5-float">3.5 float</h2><pre><code class="language-Java">{    float f1=9.999999F;     float f2=9999999F;    float f3=f2+1;    System.out.println(f1); //9.999999    System.out.println(f2); //9999999.0    System.out.println(f3); //1.0E7，这里的E7指的是10^7即10的7次方    float f4=-9999999F;    float f5=-(f4-1);    System.out.println(f4); //-9999999.0    System.out.println(f5); //-1.0E7    float f6=123123123f; //前7位数不会丢失精度，但从第8位开始就可能会出现精度丢失的情况    float f7=f6+1;    System.out.println("f6=" + f6); //f6=1.2312312E8    System.out.println("f7=" + f7); //f7=1.2312312E8    System.out.println(f6 == f7); //返回true，因为精度丢失了，它们输出一样的结果    }</code></pre><p>①<em>float</em>类型的<strong>范围</strong>比较特殊，正常来说<strong>前7位</strong>都是<strong>正常的</strong>，超过7位后会出现<code>E</code>来表示<strong>科学计数法</strong>；然后在<strong>前8位</strong>中有一部分也是正常的，但到了<strong>后面的部分</strong>会出现<strong>精度丢失</strong>的现象<br>②<em>float</em>类型在<strong>数字的末尾</strong>要加上<code>F或f</code><br>③<strong>1</strong>个<em>float</em>占<strong>4</strong>个字节(<code>Byte</code>)，<strong>32</strong>位(<code>bit</code>)<br>④<em>Java</em>中默认<strong>小数</strong>为<em>double</em>类型，所以如果要使用<em>float</em>类型就需要加上<code>F或f</code>或者<strong>强制转换</strong>成<em>float</em>类型</p><br><h2 id="3-6-double">3.6 double</h2><pre><code class="language-Java">    double d1=0.0000001d;    System.out.println(d1); //1.0E-7，即1*(10^-7)</code></pre><p>①<em>double</em>类型的<strong>范围</strong>要比<em>float</em>类型的要广很多，能精确到<code>15~16</code>位，具体<strong>有效位数</strong>可以自行查找；但是和<em>float</em>类型一样，到了<strong>后面的部分</strong>也会出现<strong>精度丢失</strong>的现象<br>②<em>double</em>类型在<strong>数字的末尾</strong>要加上<code>D或d</code><br>③<strong>1</strong>个<em>double</em>占<strong>8</strong>个字节(<code>Byte</code>)，<strong>64</strong>位(<code>bit</code>)</p><br><h2 id="3-7-char">3.7 char</h2><pre><code class="language-Java">{    char a1='a';    System.out.println("a1="+a1); //a1=a    char a2='1';    System.out.println("a2="+a2); //a2=1    char b1='\u0042';    System.out.println("b1="+b1); //b1=B    char b2='\t';    System.out.println("I love"+b2+"you"); //I loveyou    char b3='\n';    System.out.println(b3+"baby"); //(换行) baby    char c1=1;    System.out.println("c1="+c1); //c1=SOH，SOH(Start Of Headling)是ASCII码的第1个    char c2=48;    System.out.println("c2="+c2); //c2=0，ASCII码的第48个为0    System.out.println("c1+c2="+(c1+c2)); //49，1+48    System.out.println("a2+c1="+(a2+c1)); //50，49+1，a2的'1'为ASCII码的第49个    System.out.println("a2+c2="+(a2+c2)); //97，49+48}</code></pre><p>①<em>char</em>类型<strong>只能</strong>写入<strong>1个字符</strong>，字符表示<em>Unicode（万国码）<em>编码表中的每1个符号，每个符号使用</em>单引号</em>(<code>''</code>)引起来，其中<strong>前128个符号</strong>和<em>ASCII表</em>相同，且这个字符可以是<em>转义字符</em>，如上面的<code>'\u0042'</code>表示转义成<em>Unicode</em>的第42个即<em>大写的B</em>，<code>'\t'</code>表示转义成<em>制表符</em>(即4个空格)，<code>'\n'</code>表示转义成<em>换行符</em>(即换1行)</p><table><thead><tr><th>Unicode转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\u000a</td><td>换行符 <code>\n</code></td></tr><tr><td>\u000d</td><td>回车符 <code>\r</code></td></tr><tr><td>\u007b</td><td>大括号左半部 <code>{</code></td></tr><tr><td>\u007d</td><td>大括号右半部 <code>}</code></td></tr><tr><td>\u0008</td><td>退格符 <code>\b</code></td></tr><tr><td>\u0009</td><td>制表符 <code>\t</code></td></tr><tr><td>\u0022</td><td>双引号半边 <code>"</code></td></tr><tr><td>\u0027</td><td>单引号半边 <code>'</code></td></tr><tr><td>\u002b</td><td>加号 <code>+</code></td></tr><tr><td>\u003b</td><td>分号 <code>;</code></td></tr><tr><td>\u005c</td><td>反斜杠 <code>\</code></td></tr><tr><td>\u0041 ~ \u005a</td><td>字符 <code>A~Z</code></td></tr><tr><td>\u0061 ~ \u007a</td><td>字符 <code>a~z</code></td></tr></tbody></table><p>②<em>char</em>类型的变量的值如果<strong>不</strong>带上<em>单引号</em>(<code>''</code>)，则<strong>只能写入数字</strong>(可以是1个，也可以是多个)，表示直接把写入的<strong>变量的值</strong>视为<strong>ASCII码对应的十进制数字</strong>，如上面<code>char c2=48;</code>意思是将<em>ASCII码</em>的<code>第48个</code>(即是数字<code>0</code>)赋值给<code>c2</code>，所以<code>System.out.println("c2="+c2);</code>这个的结果是<code>c2=0</code>；而在<code>System.out.println("a2+c1="+(a2+c1));</code>中，结果之所以是<code>50</code>的原因是<code>a2</code>和<code>c1</code>在<code>println()</code>中进行的是<em>ASCII码的值</em>的相加运算，因为<code>a2='1'</code>，所以<code>'1'</code>在<em>ASCII码中的值</em>是<code>49</code>，而<code>c1=1</code>，<code>1</code>本来代表的就是<em>ASCII码的值</em>为<code>1</code>，所以<code>50=49+1</code>，<code>System.out.println("c1+c2="+(c1+c2));</code>和<code>System.out.println("a2+c2="+(a2+c2));</code>同理<br>③<strong>1</strong>个<em>char</em>占<strong>2</strong>个字节(<code>Byte</code>)，<strong>16</strong>位(<code>bit</code>)，它的取值范围是<code>0~65535</code></p><br><h2 id="3-8-boolean">3.8 boolean</h2><pre><code class="language-Java">    boolean isMan=true;    if(isMan){        System.out.println("请进男厕");    }    else {        System.out.println("请进女厕");    }</code></pre><p>①<strong>1</strong>个<em>boolean</em>占<strong>1</strong>位，有<code>true</code>和<code>false</code>这2个值，一个表示<code>真</code>，一个表示<code>假</code>，一般用于表示<strong>逻辑运算</strong><br>②<em>boolean</em>类型<code>true</code>和<code>false</code>都<strong>不谈</strong>字节大小，但<strong>实际上</strong>会被转换成<code>1</code>和<code>0</code>，所以占<strong>4</strong>字节(<code>Byte</code>)</p><br><h1>4.引用数据类型</h1><br><h2 id="4-1-String">4.1 String</h2><pre><code class="language-Java">    String str2="";    String str1="HelloChina!"; //String类型变量用""赋值，String类，属于引用数据类型，即是字符串    System.out.println(str1); //HelloChina!    int i2=128;      //String str=str1+i2-3; //报错，因为String类型表示字符串，-表示减法，所以+被视为了加法而非连接    boolean isMan=true;    //String str=isMan+i2+str1; //报错，因为布尔类型isMan开头会+会被视为加法而非连接，是错的，应该把str1放前面    String str=str2+i2; //String类型做连接运算后还是String类型    System.out.println(str); //128    String str3=i2+""; //i2=128被放进""里了得到了str3    System.out.println(str3); //128    int num=Integer.parseInt(str3); //用Integer.parseInt()把str3里的数字取出来    System.out.println(num-1); //127，128-1的结果    String str4=3.2f+"";    System.out.println(str4); //3.2    //int num0=Integer.parseInt(str4); //取不出来str4，因为Integer.parseInt()取的是纯数字的字符串    //System.out.println(num0-1);    System.out.println(3+4+"Hello"); //7Hello，遇上了"Hello"是字符串，所以后面所有只能做连接运算    System.out.println("Hello"+3+4); //Hello34    System.out.println('a'+1+"Hello"); //98Hello，先'a'+1是ASCII运算，再遇上"Hello"做连接运算    System.out.println("Hello"+'a'+1); //Helloa1</code></pre><p>①<em>String</em>类型变量用<code>""</code>赋值<br>②如果用<strong>连接运算</strong>的表达式来给<em>String</em>类型变量赋值，则首先不能出现<code>-</code>，其次<em>boolean</em>的变量不能放在<code>=</code>后的第一个，然后要么<code>=</code>后面有<em>String</em>类型的变量，要么有<code>""</code></p><br><h1>5.关键字</h1><br><h2 id="5-1-this">5.1 this</h2><p><em>this</em>用于解决变量冲突问题(区分实例变量和局部变量)，当局部变量和成员变量同名时，用<em>this. XXX</em>来指代本类中的的成员变量<em>private XXX</em></p><pre><code class="language-java">public class Course{    private String name;    public void setName(String name){        this.name = name;    }}</code></pre><br><h2 id="5-2-static">5.2 static</h2><p><em>static</em>用于修饰成员变量和方法(区分实例对象)，一般于<em>public</em>搭配使用，且修饰后属于整个类(非实例对象)，会被类的所有对象共享，所以它随着类的加载而加载，也只能被类调用，而且因为共享，如果有值有变动所有的都会一起变动</p><pre><code class="language-java">public class Course{    public static String name;}// 测试类public class test{    public static void main(String[] args){    Course.name = "计算机组成原理";    }}</code></pre><br><h2 id="5-3-super">5.3 super</h2><p>在子类中用于访问父类的成员变量、方法、构造函数，因为Java的就近原则，只有自己类中没有的才去访问父类，且子类中与父类同名的属性和方法会被子类自己的覆盖掉，所以说用<em><a href="http://super.XXX">super.XXX</a></em>可以用于区分是子类的成员还是父类的成员</p><pre><code class="language-java">//父类class Animal {  protected String type="动物";}//子类class Dog extends Animal {  public String type="哺乳动物";  public void printType() {    System.out.println("我是 " + type); //我是哺乳动物    System.out.println("我是一只 " + super.type); //我是一只动物  }}//主函数class Main {  public static void main(String[] args) {    Dog dog1 = new Dog();    dog1.printType();  }}</code></pre><br><h2 id="5-4-final">5.4 final</h2><p>用于修饰变量(类属性、对象属性、局部变量、形参)、方法(类方法、对象方法)、类，修饰后不能改变，其也不能被重写、继承等，因为<em>fin</em>了</p><pre><code class="language-java">public class Main {   public static void main(String[] args) {       String a = "xiaomeng2";       final String b = "xiaomeng";       String d = "xiaomeng";       String c = b + 2;       String e = d + 2;       System.out.println((a == c)); //true       System.out.println((a == e)); //false   }}</code></pre><p><a href="https://blog.csdn.net/qq_42651904/article/details/87708198">深入理解final关键字（详解）-CSDN博客</a></p><br><h2 id="5-5-instanceof">5.5 instanceof</h2><p>①类型检查：为了向下转型/强制转换时，确保对象是特定的子类或者实例</p><p>②条件逻辑：根据对象的具体类型执行特定行为</p><p>③多态行为：在多态情况下，根据实际对象类型执行特定行为</p><p>④格式：<code>if(对象 instanceof 类型)</code></p><pre><code class="language-java">public class demo{    public static void main(String args[]){        //判断是否符合类型if (obj instanceof String) {    //然后强制转换    String s = (String) obj;    //然后才能使用        s.stringMethod();        }        if (obj instanceof String s) {        // JDK16之后，如果类型匹配，则可以直接使用s}    }}</code></pre><br><h1>6.JavaBean</h1><p>就是封装类，该私有私有，该暴露暴露，为了安全性考虑，满足：</p><p>①成员变量全部私有，提供其getter/setter方法</p><p>②需要一个无参构造器，有参可选</p><br><h1>7.方法重写与方法重载的区别</h1><p>重写多用于重写接口中的方法，重载多用于写同一个类中要实现的同一类型方法</p><table><thead><tr><th style="text-align:left"><strong>特征</strong></th><th style="text-align:left"><strong>方法重写 (Override)</strong></th><th style="text-align:left"><strong>方法重载 (Overload)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义位置</strong></td><td style="text-align:left"><strong>子类中</strong></td><td style="text-align:left"><strong>同一个类中</strong> (或父子类之间，但本质在同一个类)</td></tr><tr><td style="text-align:left"><strong>目的</strong></td><td style="text-align:left">提供父类方法的<strong>特定实现</strong>，实现<strong>运行时多态</strong></td><td style="text-align:left">提供处理<strong>不同类型/数量参数</strong>的<strong>同名方法</strong>，<strong>编译时多态</strong></td></tr><tr><td style="text-align:left"><strong>参数列表</strong></td><td style="text-align:left"><strong>必须完全相同</strong> (类型、顺序、数量)</td><td style="text-align:left"><strong>必须不同</strong> (类型、顺序、数量至少一项不同)</td></tr><tr><td style="text-align:left"><strong>返回类型</strong></td><td style="text-align:left"><strong>必须相同或协变</strong> (Java 5+，子类重写方法的返回类型可以是父类方法返回类型的子类型)</td><td style="text-align:left"><strong>可以不同</strong> (与参数列表不同无关)</td></tr><tr><td style="text-align:left"><strong>访问修饰符</strong></td><td style="text-align:left"><strong>不能比父类方法更严格</strong> (可以相同或更宽松)</td><td style="text-align:left"><strong>没有限制</strong> (可以任意)</td></tr><tr><td style="text-align:left"><strong>抛出异常</strong></td><td style="text-align:left"><strong>可以抛出相同的异常、子类异常或不抛出</strong>；<strong>不能抛出新的或更宽泛的检查型异常</strong></td><td style="text-align:left"><strong>没有限制</strong> (可以抛出不同的异常)</td></tr><tr><td style="text-align:left"><strong>静态性</strong></td><td style="text-align:left"><strong>不能重写静态方法</strong> (只能隐藏)</td><td style="text-align:left"><strong>可以重载静态方法</strong></td></tr><tr><td style="text-align:left"><strong>调用时机</strong></td><td style="text-align:left"><strong>运行时决定</strong> (基于对象的实际类型 - 动态绑定)</td><td style="text-align:left"><strong>编译时决定</strong> (基于引用类型和参数 - 静态绑定)</td></tr><tr><td style="text-align:left"><strong><code>@Override</code>注解</strong></td><td style="text-align:left"><strong>强烈建议使用</strong> (编译器检查是否符合重写规则)</td><td style="text-align:left"><strong>不能使用</strong> (语法错误)</td></tr><tr><td style="text-align:left"><strong>继承关系</strong></td><td style="text-align:left"><strong>必须存在于父子类之间</strong></td><td style="text-align:left"><strong>不要求继承关系</strong> (同一个类内即可)</td></tr><tr><td style="text-align:left"><strong>核心多态性</strong></td><td style="text-align:left"><strong>运行时多态 (动态多态)</strong></td><td style="text-align:left"><strong>编译时多态 (静态多态)</strong></td></tr></tbody></table><br><h1>8.构造器的执行</h1><p>子类一定要先执行父类或更祖宗的无参构造器！若父类手动给出有参构造器，但没有补无参构造器，子类则会报错</p><br><h1>9.静态代码块与代码块执行顺序</h1><p>在VM中加载*.class*</p><p>①静态代码块/静态属性初始化</p><p>②普通代码块/普通属性初始化</p><p>③类中的构造方法</p><p>④继承关系中：父类静态代码块&gt;子类静态代码块&gt;父类普通代码块&gt;父类构造方法&gt;子类普通代码块&gt;子类构造方法</p><p>⑤实例方法和静态方法(非静态代码块)，不会被VM自动执行，只有被调用时执行</p><br><h1>10.多态</h1><p>一个方法不同实现，其好处：</p><p>①用统一的方法调用不同对象的特定行为</p><p>②动态扩展功能：子类重写父类方法，做到同一方法，不同实现</p><br><h1>11.抽象</h1><p>①抽象类不能被实例化</p><p>②继承抽象类的子类必须实现父类中的抽象方法，否则也必须被定义为抽象类</p><p>③有抽象方法一定是抽象类，抽象类中不一定要有抽象方法</p><p>④抽象方法不能用<em>final</em>修饰</p><p>⑤抽象方法不能被<em>static</em>修饰，因为<em>static</em>属于类，非对象，而抽象方法实现多态，不同对象实现方法不一样</p><p>⑥抽象方法不能被<em>private</em>修饰，因为<em>private</em>只能在父类的内部使用，而抽象方法需要在子类中被重写</p><p>⑦抽象类不能被实例化，但抽象类有构造器，用于初始化抽象类字段，为子类构造器提供基础</p><br><h1>12.接口</h1><p>①对外提供一组公共行为规范的标准，在Java中是一个抽象类型，非类，是抽象方法的集合，也无法被实例化，但可以被实现</p><p>②一个实现接口的类，如果没有实现接口中的所有方法，就必须声明为抽象类</p><p>③接口是隐式抽象，其访问修饰符只能是<em>public</em>或<em>default</em>，<em>abstract</em>关键字可以省略</p><pre><code class="language-java">public abstract interface A{}; //√public interface A{}; //√</code></pre><p>④接口中的方法也是隐式抽象，其修饰符只能是<em>public abstract</em>，<em>public</em>和<em>abstract</em>关键字都可以省略</p><pre><code class="language-java">public interface A{    public abstract void method1(); //√    void method2(); //√}</code></pre><p>⑤接口中的变量会被隐式定义为<em>public static final</em>，<em>public</em>、<em>static</em>和<em>final</em>关键字都可以被省略</p><pre><code class="language-java">public interface A{public static final Integer VAR_1 = 10; //√    Integer VAR_2 = 10; //√}</code></pre><p>⑥JDK8之后，用<em>default</em>修饰可以在接口中添加一个有实现的默认方法，它也可以被子类重写，但如果没有被子类重写，则使用这个有实现的默认方法，默认方法会默认加上<em>public</em>修饰符，且只有使用接口的(实现类)子类对象调用，被多个(实现类)子类共享</p><pre><code class="language-java">public interface MyInterf{    default void defMethod(){System.out.println("有实现的默认方法");            }}</code></pre><p>⑦JDK8之后，用<em>static</em>修饰可以在接口中添加一个属于接口的可以直接用接口调用的静态方法，且它不能被子类重写</p><pre><code class="language-java">public interface MyInterf{    static void staMethod(){System.out.println("属于接口的静态方法");            }}</code></pre><p>⑧JDK9之后，用<em>private</em>定义私有方法，以减少多个默认方法的重复逻辑，但因为私有，所以只能接口内自己调用</p><pre><code class="language-java">public interface MyInterf{    default void defMethod1(){//System.out.println("有实现的默认方法1");        commonMethod();    }    default void defMethod2(){//System.out.println("有实现的默认方法2");        commonMethod();    }    private void commonMethod(){        System.out.println("通用方法");    }}</code></pre><p>⑨JDK17之后，用<em>sealed</em>密封一个类或者接口，再用<em>permits</em>列出所有允许继承或实现的子类，并用<em>non-sealed</em>解封</p><pre><code class="language-java">//密封继承public abstract sealed class Animal permits Dog,Cat{    //...}//密封实现public sealed interface IRun permits Bus,Car{    //...}//解封public non-sealed class Bus implements IRun{    //...}</code></pre><br><h1>13.数组</h1><p>①存放相同类型的元素</p><p>②空间连续的，且定长的</p><p>③每个空间有自己的编号，起始位置编号为0，即数组的下标</p><p>④格式：<code>T[] 数组名 = new T[]</code></p><pre><code class="language-java">public class demo{    public static void main(String[] args){        double[] b = {1.0，2.0，3.0};        //普通for循环遍历，取的是地址        for(int i = 0;i&lt;b.length;i++){            b[i] *= 10; //b中的值改变了        }        for(int i = b.length -1;i&gt;=0;i--){            System.out.println(b[i]);}        //增强for循环遍历，从b中取所有值作e，非地址for(double e : b){    e *= 10; //b中的原始值并没有改变            //System.out.println(e);}        for(double e : b){            System.out.println(e);        }    }}</code></pre><br><h1>14.ArrayList动态数组</h1><p>①动态数组，可根据需求自动扩展或缩小</p><p>②格式：<code>ArrayList&lt;T&gt; 数组名 = new ArrayList&lt;&gt;()</code>，T为引用类型</p><p>③ArrayList的用法：</p><pre><code class="language-java">public class demo{    public static void main(String[] args){        ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); //size=0        a.add(1); //插入1进数组a，长度+1,size=1        a.add(10); //插入10进数组a，长度又+1，size=2        //a.get(2); //获取值错误，下标越界，没有为2的下标        a.add(1,20); //插入20在下标为1的地址，长度又+1，size=3，且原本下标为1的10向后进一位变到下标为2的位置        a.set(1,30); //修改下标为1的元素的值为30        a.remove(1); //按下标删除，删掉下标为1的元素20，长度-1，size=2，且原本下标为2的10向前退一位变到下标为1的位置，若想删除删掉对象为1的元素，得进行装箱处理a.remove(Integer.valueOf(1))        ArrayList&lt;String&gt; b = new ArrayList&lt;&gt;(); //size=0        b.add("A"); //添加“A”进数组b，长度+1，size=1        b.add("B"); //添加“B”进数组b，长度又+1，size=2        b.remove("B"); //按对象删除，删掉对象为“B”的元素，长度-1，size=1    }}</code></pre><hr><pre><code class="language-java">public class demo{    public static void main(String[] args){        ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); //size=0，这size就是整个数组的长度        a.add(1); //插入1进数组a，长度+1,size=1        a.add(10); //插入10进数组a，长度又+1，size=2a.addAll(List.of(10,20,30,40,50)); //将这个集合加到a现有集合后面        int k = a.indexOf(10); //查找第一次出现10的下标位置k        List&lt;Integer&gt; a1 = a.subList(k,a.size()); //截取从下标位置k开始到下标位置为整个数组的长度-1(即.size()方法)的数组作为a1        for(int i =0;i&lt;a.size();i++){            if(a.contains(30)){ //判断是否存在元素为30                a.remove(i); //从i=0开始删            }        }        for(int x: a){System.out.println(x); //10,20,40,50                    }    }}</code></pre><p>④ArrayList扩容机制：</p><ol><li><p>初始容量默认为10</p></li><li><p>当size超过当前容量时扩容</p></li><li><p>默认增长因子为1.5倍，所以每次扩容为原来的1.5倍</p></li><li><p>扩容策略：</p><ul><li>创建新数组：扩容1.5倍</li><li>复制元素：旧的复制到新的</li><li>更新引用：内部数组更新为新数组，若判断已经达到最大值，将不再扩容</li></ul></li></ol><br><h1>15.二维数组(不常用)</h1><p>格式：<code>T[][] 数组名 = new T[R][C]</code></p><pre><code class="language-java">public class demo{    public static void main(String args[]){int[ ][ ] array1 = new int[2][3];        int[ ][ ] array2 = new int[ ][ ]{{1,2,3},{4,5,6}};        int[ ][ ] array3 ={{1,2,3},{4,5,6}};        int[ ][ ] array4 = new int[2][ ]; //列可以不写，由元素实际长度决定        int[] a = {10,11,12};        int[] b = {20,21,22,23};        array4[0] = a;        array4[1] = b;        array1[0] = a;        array1[1] = b; //√        for(int i = 0;i&lt;array4.length;i++){            for(int j = 0;j&lt;array4.length;j++){    //i:0 j:0-&gt;3----i:2 j:3                System.out.print(array4[i][j]+"\t");            }        }        System.out.println();     }}</code></pre><br><h1>16.Arrays类(操作数组)</h1><p>所有方法都是静态方法，方便使用方法调用数组，用法：</p><ul><li><code>Arrays.toString(Object[] a,Object key)</code> 将数组转换成<em>String</em>类型输出</li><li><code>Arrays.deepToString(Object[][] a,Object key)</code> 打印多维数组</li><li><code>Arrays.sort(Object[] a)</code> 对指定数组元素升序排列</li><li><code>Arrays.equals(long[] a1,long[] a2)</code> 判断指定的两个<em>long</em>型数组是否相等</li><li><code>Arrays.fill(int[] a,int val)</code> 将指定的<em>int</em>值分配给指定<em>int</em>型数组指定范围内的每一个元素</li><li><code>Arrays.binarySearch(Object[] a,Object key)</code> 用二分查找在给定数组中搜寻查找对象，但调用前数组需排序好</li></ul><br><h1>17.List集合</h1><ol><li><p>List接口特点：</p><ul><li>有序性：按照插入的顺序存储</li><li>允许重复：允许存储重复的元素</li><li>索引访问：提供了用索引访问的方法，如get(int index)</li></ul></li><li><p>List接口常用实现类：</p><ul><li><p>ArrayList类：随机访问快，插入、删除慢</p></li><li><p>LinkedList类：插入、删除快，随机访问慢(链表)</p></li><li><p>Vector类：线程安全，同步开销，性能低</p></li><li><p>Stack类：继承Vector类，多些栈操作(后进先出)的方法</p></li></ul></li></ol><hr><p>List是Collection接口的子接口，拥有Collection所有方法外，还有一些对索引操作的方法</p><ul><li><code>void add(int index, E element);</code> 将元素element插入到List集合的index处；</li><li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c);</code> 将集合c所有的元素都插入到List集合的index起始处；</li><li><code>E remove(int index);</code> 移除并返回index处的元素；</li><li><code>int indexOf(Object o);</code> 返回对象o在List集合中第一次出现的位置索引；</li><li><code>int lastIndexOf(Object o);</code> 返回对象o在List集合中最后一次出现的位置索引；</li><li><code>E set(int index, E element);</code> 将index索引处的元素替换为新的element对象，并<code>返回被替换的旧元素</code>；</li><li><code>E get(int index);</code> 返回集合index索引处的对象；</li><li><code>List&lt;E&gt; subList(int fromIndex, int toIndex);</code> 返回从索引fromIndex（包含）到索引toIndex（不包含）所有元素组成的子集合；</li><li><code>void sort(Comparator&lt;? super E&gt; c)</code> 根据Comparator参数对List集合元素进行排序；</li><li><code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code> 根据operator指定的计算规则重新设置集合的所有元素。</li><li><code>ListIterator&lt;E&gt; listIterator();</code> 返回一个ListIterator对象，该接口继承了Iterator接口，在Iterator接口基础上增加了以下方法，具有向前迭代功能且可以增加元素:<br><code>bookean hasPrevious()</code> 返回迭代器关联的集合是否还有上一个元素；<br><code>E previous();</code> 返回迭代器上一个元素；<br><code>void add(E e);</code>在指定位置插入元素；</li></ul><br><h1>18.Set集合</h1><ol><li><p>set接口特点：</p><ul><li>不允许重复元素(去重复，核心是*equals()*方法)<ul><li>equals(Object obj)：这是Object类的方法，默认实现是比较两个对象的内存地址，但可以被重写</li><li>==运算符：比较两个对象的内存地址是否相同，如果两个引用指向同一个对象实例，则<em>true</em></li><li>hashCode()：该方法返回对象的哈希码(整数值)，用于快速比较，如果两个对象相等(用<em>equals</em>)，则应该有相同的哈希码</li></ul></li><li>大多数实现不保证元素顺序(除了<em>LinkedHashSet</em>和<em>TreeSet</em>)</li></ul></li><li><p>set实现类：</p><ul><li><p>HashSet，基于哈希表的Set实现，高性能，快速查找、添加、删除</p><pre><code class="language-java">public class demo{    public static void main(String args[]){Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();    hashSet.add("apple");    hashSet.add("banana");    hashSet.add("null"); //允许一个null元素    System.out.print(hashSet); //不保证顺序，所以不能用普通for循环靠索引访问    //增强for循环取值    for(String s; hashSet){        System.out.print(s);}}</code></pre><hr></li><li><p>LinkedHashSet，继承HashSet，有双向链表来记录插入顺序</p><pre><code class="language-java">public class demo{    public static void main(String args[]){LinkedHashSet&lt;String&gt; hashSet = new LinkedHashSet&lt;&gt;();    hashSet.add("apple");    hashSet.add("apple");    hashSet.add("banana");    hashSet.add("null"); //允许一个null元素    System.out.print(hashSet); //有序且去重    //增强for循环取值    for(String s; hashSet){        System.out.print(s);}}</code></pre><hr></li><li><p>TreeSet，实现SortedSet接口，底层使用红黑树结构，保证对数级别的性能</p><pre><code class="language-java">public class demo{    public static void main(String args[]){Set&lt;String&gt; hashSet = new TreeSet&lt;&gt;();    hashSet.add("a");    hashSet.add("c");    hashSet.add("c");    hashSet.add("b");    System.out.print(hashSet); //按自然数排序    //增强for循环取值    for(String s; hashSet){        System.out.print(s);}}</code></pre><br><h1>19.Map集合(标识作用)</h1><ul><li>Map顶层接口=Entry接口+Map自身接口方法<ul><li>Entry接口={Key: Value}</li><li>Map其子接口：<ul><li>HashMap：有个<em>LinkedHashMap</em>子类，记录了插入顺序，但效率比<em>HashMap</em>低</li><li>HashTable：同步的，线程安全的，且不允许<em>null</em>作为<em>Key</em>和<em>Value</em></li><li>TreeMap：基于红黑树，自然顺序排序</li></ul></li><li>Map其常用子集合：<ul><li>keySet：遍历所有<em>Key</em></li><li>values：遍历所有<em>Value</em></li><li>entrySet：遍历所有<em>K-V</em></li></ul></li></ul></li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]){Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //Key为字符串，Value为整型        map.put("red",1);        map.put("blue",2);        map.put("green",3);        System.out.println(map); //无序输出                int x = map.get("blue"); //根据Key查找        System.out.println(X); //输出2        //keySet遍历所有Key，性能较差，但是方便        for(String key : map.keySet()){ //从所有Key中取Key            System.out.println(key + ":" + map.get(key)); //得到所有Key后，再通过Key取得所有Value        }        //entrySet遍历所有K-V，效率最高，推荐使用        for(Map.Entry&lt;String,Integer&gt; entry : map.entrySet()){ //从所有K-V中取K-V            System.out.println(entry.getKey() + ":" + entry.getValue());        }                //查单词重复次数        String[] words = {"the","day","is","sunny","the","the","sunny","is"}; //单词数组        Map&lt;String,Integer&gt; times = new HashMap&lt;&gt;();        for(String word : words){ //从单词数组中遍历所有单词作为word也是Key            if(times.containsKey(word)){ //判断word/Key是否出现                int count = times.get(word) + 1;                 times.put(word,count); //如果单词已经出现过一次，则Value+1            }else {                times.put(word,1); //单词没有出现过，就Value=1            }        }        System.out.println(times);}}</code></pre><br><h1>20.集合排序</h1><ol><li><p><code>Collections.sort()</code>方法：</p><ul><li>Java集合框架的静态方法，属于接口，不能用类调用</li><li>只传入待排序的集合，则默认自然排序(升序)</li><li>传入待排序的集合和比较器，则按比较器规则排序，可用于对象排序(见 <em>3.Comparator<t>接口</t></em> )</li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]){List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        numbers.add(3);        numbers.add(1);        numbers.add(4);        numbers.add(2);        numbers.add(5);        Collections.reverse(numbers);  //反转        System.out.println(numbers); //5,2,4,1,3        Collections.sort(numbers);  //升序        System.out.println(numbers); //1，2，3，4，5}}</code></pre></li><li><p>Comparable<t>接口</t></p><ul><li>String等八种封装类已经实现了Comparable接口，所以<code>Collections.sort()</code>可以直接对基本数据类型数据升序</li><li>但要对象排序，就得重写Comparable接口的<code>compareTo(T o)</code>方法</li></ul><pre><code class="language-java">@Datapublic class Student implements Comparable&lt;Student&gt;{    private Integer sno;    private String sname;    private Double score;    public Student(Integer sno,String sname,Double score){        this.sno = sno;        this.sname = sname;        this.score = score;    }    @Override    public String toString(){        return "Student{" +            "sno" + sno +            ", sname='" + sname + '\'' +            ", score=" + score +             '}';    }    //重写compareTo(T o)方法    @Override    public int compareTo(Student o){        if(this.sno &gt; o.sno){            return 1;  //大于0        }else if(this.sno &lt; o.sno){            return -1; //小于0        }         return 0; //等于0    }/* 我们添加了4个Student对象，按照学号（sno）进行比较，添加顺序是：1002, 1003, 1004, 1001 插入过程：   - 首先添加1002（作为根节点）   - 添加1003：与1002比较，1003&gt;1002，所以放在1002的右子树   - 添加1004：先与1002比较（1004&gt;1002），转向右子树（1003），再与1003比较（1004&gt;1003），所以放在1003的右子树   - 添加1001：与1002比较，1001&lt;1002，所以放在1002的左子树   最终，树的结构如下：        1002       /    \    1001    1003              \               1004 但是，TreeSet在遍历时是按照二叉搜索树的中序遍历（左-根-右），所以遍历顺序是：1001 -&gt; 1002 -&gt; 1003 -&gt; 1004。 因此，输出顺序为：   Student{sno=1001, sname='lucy', score=74.0}   Student{sno=1002, sname='jack', score=88.0}   Student{sno=1003, sname='rose', score=65.5}   Student{sno=1004, sname='lily', score=89.0}    注意：虽然我们添加的顺序是1002、1003、1004、1001，但输出时却是按学号升序排列，这就是TreeSet自动排序的效果。 另外，如果两个对象的compareTo方法返回0，TreeSet会认为它们是相等的，不会添加新对象。例如，如果试图添加一个学号相同的Student对象，它将被视为重复元素，不会被加入集合。关键特性1. 动态排序：每次调用add()都会触发compareTo()比较，立即调整树结构保持有序2. 去重机制：当compareTo()返回0时，视为逻辑相等（即使对象地址不同），拒绝插入3. 性能保障：红黑树保证插入/查找/删除的时间复杂度为O(log n)，远优于线性排序。*/}</code></pre><pre><code class="language-java">public class demo{    public static void main(String args[]){Set&lt;Student&gt; students = new TreeSet&lt;&gt;(); //将Student对象存放在Set集合     // List&lt;Student&gt; students = new ArrayList&lt;&gt;(); //错误，因为ArrayList没有TreeSet里的自带排序功能，重写Comparable接口的compareTo(T o)方法后，还需要调用Collections.sort(students)方法才能实现排序         students.add(new Student(1002,"jack",88.0));        students.add(new Student(1003,"rose",65.5));        students.add(new Student(1004,"lily",89.0));        students.add(new Student(1001,"lucy",74.0));        //展示排序后的stu        for(Student stu ; students){            System.out.println(stu.toString());}}}</code></pre></li><li><p>Comparator<t>接口</t></p><ul><li>需要创建单独排序类(比较器)，然后重写<code>compare(T o1,T o2)</code>方法或用匿名内部类实现</li></ul><pre><code class="language-java">//商品类@Datapublic class Sku{    private String name;    private Integer num;    private Double price;    @Override    public String toString(){        return "Sku{" +            "name" + name +            ", num='" + num + '\'' +            ", price=" + price +             '}';    }}</code></pre><pre><code class="language-java">//比较器SkuComparatorpublic class SkuComparator implements Comparator&lt;Sku&gt;{public final static String ASC = "asc";    public final static String DEC = "dec";    private String sortField; //排序字段    private String sort; //升序或降序    //构造器1：只有字段，无选择    public SkuComparator(String sortField){        this.sortField = sortField;        this.sort = ASC; //默认升序    }    //构造器2：自主选择升序类型    public SkuComparator(String sortField,String sort){        this.sortField = sortField;        this.sort = sort;    }    //重写compare(T o1,T o2)方法    @Override    public int compare(Sku o1,K,Sku o2){        switch(sortField){            case "name":                if(this.sort.equals(ASC)){                    return o1.getName().compareTo(o2.getName());                }else{                    return o2.getName().compareTo(o1.getName());                }            case "num":                if(this.sort.equals(ASC)){                    return o1.getNum()-o2.getNum();                }else{                    return o2.getNum()-o1.getNum();                }            case "price":                if(this.sort.equals(ASC)){                    return (int)(o1.getPrice()-o2.getPrice());                }else{                    return (int)(o2.getPrice()-o1.getPrice());                }            default: return 0;        }}}</code></pre><pre><code class="language-java">//测试public class demo{    public static void main(String args[]){        //商品数量升序Set&lt;Sku&gt; skus = new TreeSet&lt;&gt;(new SkuComparator("num"));        skus.add(new Sku("A",100,200.0));        skus.add(new Sku("C",50,1200.0));        skus.add(new Sku("D",150,120.0));        skus.add(new Sku("B",200,1000.0));        System.out.println(skus);        //价格降序Set&lt;Sku&gt; skus1 = new TreeSet&lt;&gt;(new SkuComparator("price",SkuComparator.DEC));        skus1.add(new Sku("A",100,200.0));        skus1.add(new Sku("C",50,1200.0));        skus1.add(new Sku("D",150,120.0));        skus1.add(new Sku("B",200,1000.0));        System.out.println(skus1);        //List集合价格降序        SkuComparator comparator2 = new SkuComparator("price",SkuComparator.DEC);List&lt;Sku&gt; skus2 = new ArrayList&lt;&gt;();        skus2.add(new Sku("A",100,200.0));        skus2.add(new Sku("C",50,1200.0));        skus2.add(new Sku("D",150,120.0));        skus2.add(new Sku("B",200,1000.0));        Collections.sort(skus2,comparator2); //必须加入比较器comparator2!        System.out.println(skus2);}}</code></pre><pre><code class="language-java">//匿名内部类，无比较器public class demo{    public static void main(String args[]){List&lt;Sku&gt; skus = new ArrayList&lt;&gt;();        skus.add(new Sku("A",100,200.0));        skus.add(new Sku("C",50,1200.0));        skus.add(new Sku("D",150,120.0));        skus.add(new Sku("B",200,1000.0));        //直接new一个Comparator&lt;T&gt;接口，重写compare(T o1,T o2)方法        Collections.sort(skus,new Comparator&lt;Sku&gt;(){            @Override            public int compare(Sku o1,K,Sku o2){                return (int)(o1.getPrice()-o2.getPrice());            }        });        System.out.println(skus);}}</code></pre><br></li></ol><h1>21.内部类</h1><p>类的五大成分(成员变量、构造器、方法、代码块、内部类)之一</p><ol><li><p>成员内部类：定义在外部类成员位上，与成员变量/方法平级，调用成员内部类的对象时要：</p><pre><code class="language-java">Train train = new Train(); //创建类实例对象trainTrain.Seat seat = train.getInnerInstance(); //把实例对象train调用的getInnerInstance()方法赋值给成员内部类Seat创建的seatseat.occpuy(); //用seat调用成员内部类Seat方法occpuy()</code></pre></li><li><p>静态内部类：</p><ul><li>定义在外部类成员位上，被<em>static</em>修饰，属于整个外部类，所以没有外部类实例的<em>this</em>引用，它只能访问外部类的静态成员</li><li>若外部类的成员和成员内部类的成员同名，则遵循就近原则，在成员内部类中访问的是自己成员内部类中的成员，如想访问外部类的同名成员，则用<em>外部类名.静态成员名</em></li><li>若要在其他类中创建静态内部类的实例，则要保证这个静态内部类的在其他类中是可见的</li><li>静态内部类在编译后生成一个独立的类文件，其命名通常为<em>外部类名$静态内部类名.class</em></li></ul></li><li><p>局部内部类：</p><ul><li>定义在一个局部位置，如方法、方法的参数、构造器或代码块内部，类似方法的局部变量，作用域仅限自己的代码块中</li><li>可以直接访问外部类的所有成员，也可以通过<em>this</em>引用访问外部类的成员</li></ul><pre><code class="language-java">public class OuterClass{    private String outerField = "outer";    public void fun(){        //局部内部类        class LocalInnerClass{            public void foo(){                System.out.println(outerField); //直接访问                System.out.println(OuterClass.this.outerField); //通过外部类的this引用访问            }        }    }}</code></pre></li><li><p>匿名内部类：没有名字的内部类(见 <em>3.Comparator<t>接口</t></em>)</p><br></li></ol><h1>22.枚举类</h1><p>定义一组固定命名的常量，其构造器是私有的，不能创建对象，每个常量就是一个实例</p><pre><code class="language-java">//创建public  enum ColorE{    RED("红色",1),    BLUE("蓝色",2),    YELLOW("黄色",3);    private String desc;    private Integer value;    //自定义构造器    ColorE(String desc,Integer value){        this.desc = desc;        this.value = value;    }    }//返回名称System.out.println(ColorE.RED.name());//返回枚举对象的序号System.out.println(ColorE.RED.ordinal()); //输出0//返回名称对应的枚举对象System.out.println(ColorE.valueOf("RED")); //输出RED</code></pre><br><h1>23.泛型</h1><ol><li>上界约束：用<em>extends</em>，表示该泛型必须是其子类或实现了某个接口，没指定则默认约束是<em>Object</em></li></ol><p><code>&lt;T extends Number&gt; //类型参数T必须是Number类型或其子类</code></p><ol start="2"><li>下界约束：用<em>super</em>，表示该泛型必须是其超类或其接口的实现类</li></ol><p><code>&lt;T super Integer&gt; //类型参数T必须是Integer类型或者其父类</code></p><br><h1>24.函数式接口与Lambda表达式</h1><ol><li><p>函数式接口：只有一个抽象方法，可用于匿名；只是一个形式，只要有返回值即可</p></li><li><p>Lambda表达式：</p><ul><li>只有函数式接口的变量或者函数式接口才能赋值为Lambda表达式</li><li>形参类型可以全部不写</li><li>只有一个形参，类型可不写，<code>()</code>也可以不写</li><li>若Lambda表达式方法体只有一行代码，则可不写<code>{}</code>和<code>;</code>，若这行是<code>return</code>语句，则也不写<code>return</code></li></ul><pre><code class="language-java">//函数式接口public Double compute(Double x,Double y){    return x*y;}//Lambda表达式(x,y)-&gt;x*y//Lambda方法引用Function&lt;String,Integer&gt; strToInt = s -&gt; Integer.parseInt(s);//方法引用运算符::Function&lt;String,Integer&gt; strToInt1 = Integer::parseInt;//引用String的无参构造器Function&lt;String,Integer&gt; strObj = (s) -&gt; new String(s);//用方法引用运算符Function&lt;String,Integer&gt; strObj1 = String::new;</code></pre><br><h1>25.内存管理机制</h1><h3 id="25-1-Java内存区域">25.1 Java内存区域</h3><ol><li>方法区(元空间，一般放在堆里)<ul><li>功能：用于存储类的结构信息<ul><li>类的元数据(对数据的描述：全限定类名、父类名、接口列表等)：结构、方法、字段等</li><li>常量池：编译时生成的字面常量、符号引用</li><li>静态变量：因为静态变量属于类，所以随着类加载同时加载，所有实例共享</li><li>JIT(即时编译器)编译后的机器代码</li></ul></li><li>共享性：全局共享，所有线程都能访问</li><li>生命周期：JVM启动时创建，JVM销毁时销毁</li><li>避免内存溢出：使用本地内存，非JVM堆内存，避免了类的元数据过多而溢出</li></ul></li><li>堆(Heap)<ul><li>功能：Java最大的内存区域，用于存放所有对象实例(new)和引用数据类型(类、接口、数组、集合)</li><li>共享性：所有线程共享，需要同步机制管理堆内存的访问</li><li>生命周期：不会被释放，当对象不再被引用时，GC(垃圾收集器)会定期回收</li><li>内存泄漏(Memory Leak)：内存没有正确释放，导致GC无法回收</li><li>内存溢出：<code>OutOfMemoryError</code>错误，因为内存泄漏或内存设置太小导致的，用<code>-Xms</code>和<code>-Xmx</code>检查最小/最大堆空间</li></ul></li><li>栈(Stack)<ul><li>功能：每个线程创建一个虚拟机栈，用于存储局部变量表、操作数栈、动态链接、方法出口(返回值)等信息</li><li>独立性：每个线程的栈是隔离的</li><li>生命周期：线程创建时创建，线程结束时销毁(自动释放)</li><li>过程：一个方法创建一个栈帧，先进压在底部，当前操作数栈计算后，将得到的帧数据压入发起调用的操作数栈(有return的情况)，若遇到异常则查表，表中没有处理方法则结束当前方法，抛出异常</li><li>调整栈：<code>Java -Xss 1m demo_1</code> (demo_1设置为1MB栈大小)</li></ul></li><li>程序计数器(Program Counter Register)<ul><li>功能：用于记录程序下一条要执行的字节码行号</li><li>独立性：每个线程的PCR互不干扰</li></ul></li><li>本地方法栈<ul><li>功能：用于执行本地方法(非Java语言)，通过JNI(Java Native Interface)与Java代码交互</li></ul></li></ol><br><h3 id="25-2-String类的一些方法">25.2 String类的一些方法</h3><ol><li><p>String类</p><p>一个String对象最多存储2^32-1个字节(占4GB)的文本内容，它的内容是定长的，不可改变且能共享</p><pre><code class="language-java">//String源码public final class String{    private final byte[] value;    private final byte coder;}</code></pre></li><li><p>创建字符串</p><pre><code class="language-java">//常用1String str = "Hello";//常用2String str = new String("Hello");//字符数组构造char[] array = {'a','b','c'};String str = new String(array);//提取数组中一部分创建char[] array = {'a','b','c','d','e'};String str = new String(array,1,3); //bcd</code></pre></li><li><p>比较字符串</p><pre><code class="language-java">String str1 = "hello";String str2 = "Hello";String str3 String str = new String("Hello");= "hell";String str4 = new String("hello");System.out.println(str1 == str4); //false，new后开辟新的地址System.out.println(str1.equals(str4)); //true，String类重写了equals方法，内容相同即相同System.out.println(str1.compareTo(str3)); //1，compareTo方法按字典依次比较，如果字符不等则返回两个字符的大小差值，如果前几个都相等，只是长度不同，则返回两个字符串的长度差值System.out.println(str1.compareToIgnoreCase(str2)); //0，compareTo方法</code></pre></li><li><p>查找字符串</p><ul><li><code>charAt(int index)</code>：返回index位置的字符，若index为负或越界，则抛出异常<code>IndexOutOfBoundsException</code></li><li><code>indexOf(String str)</code>：返回str第一次出现的位置，没有则返回-1</li><li><code>contains(String str)</code>：判断一个字符串是否包含另一个字符串</li><li><code>startsWith(String str)</code>：判断前缀</li><li><code>endsWith(String str)</code>：判断后缀</li></ul></li><li><p>拆分与连接字符串</p><ul><li><code>split()</code>方法：将字符串以指定格式全部拆分成字符串数组</li><li><code>str1.concat(str2)</code>方法：将两个字符串连成一个字符串</li><li><code>String.join("","",...)</code>方法：静态，将多个字符串以指定格式连成一个字符串</li><li><code>+</code>：连接两个字符串，并传入新的地址</li></ul></li><li><p>截取字符串</p><pre><code class="language-java">String str = "hello word";System.out.println(str.substring(2)); //llo wordSystem.out.println(str.substring(2,8)); //llo wo</code></pre></li><li><p>字符串去左右空格，留中间空格</p><pre><code class="language-java">String str = " hello word ";System.out.println(str.trim()); //hello word</code></pre></li><li><p>格式化字符串：<code>format</code>方法</p></li><li><p>可变长度字符串类</p><ul><li><p><code>StingBuilder</code>类：线程不安全，效率快，适用单线程</p></li><li><p><code>StringBuffer</code>类：线程安全，效率低，适用多线程</p><pre><code class="language-java">StringBuilder sb = new StirngBuilder("Hello");String s = "Hello";sb.append("WorldWaWa"); //HelloWorldWaWa，在Hello后面追加WorldWawa，原地址没变，还有预留位置sb.insert(0,"Ni:"); //Ni:HelloWorldWaWa，在下标为0的位置插入Ni:,原地址没变sb.insert(8," "); //Ni:Hello WorldWaWa，在下标为8-1的位置插入空格,原地址没变sb.delete(14,sb.length()); //Ni:Hello World，删除从下标14到sb.length()-1之间的字符System.out.println(sb.toString()); //"Ni:Hello World"，用toString()转换成String类型</code></pre></li></ul></li></ol><br><h3 id="25-3-字符串常量池">25.3 字符串常量池</h3><ul><li><p>字符串常量池属于常量池，放在方法区里，方法区一般又放在堆里，所以字符串常量是共享的，又因为String源码里value是用final修饰的，所以字符串常量是不可变的</p></li><li><p>当常量池中已经存在一个与其值相同的字符串，则不会开辟空间来存储它，而是直接将地址赋值给这个新的字符串</p></li></ul><pre><code class="language-java">String s1 = "abc";String s2 = "abc";System.out.println(s1==s2); //true，因为s1和s2都是常量池中的地址</code></pre><ul><li>如果是用new关键字创建的字符串，会分别在常量池和堆中创建对象，即常量池一个，堆一个；若常量池中已经存在，则只在堆里创建</li></ul><pre><code class="language-java">String s3 = new String("abc");String s4 = new String("abc");System.out.println(s3==s4); //false，因为s3和s4都是堆里的地址，虽然常量池中地址相同，但堆中不一样</code></pre><ul><li>String对象调用<code>intern()</code>方法时则是返回该对象常量池中的地址</li></ul><pre><code class="language-java">String s5 = new String("qwe");String s6 = "qwe";String s7 = s5.intern();System.out.println(s5==s6); //false，因为s5是堆里的地址，s6是常量池中的地址System.out.println(s6==s7); //true，因为s6和s7都是常量池中的地址</code></pre><br><h3 id="25-4-值传递与引用传递">25.4 值传递与引用传递</h3><ol><li>值传递：形参是基本数据类型，用实际参数的值初始化自己的存储单元，是和实际参数不同的栈，不影响实际参数</li><li>引用传递：形参是引用数据类型，传的是地址，指向同一个地址空间，会影响实际参数</li></ol><br><h3 id="25-5-可变参数">25.5 可变参数</h3><hr><pre><code class="language-java">public class demo{    public static void main(String args[]){int m = add(1,2);        int n = add(1,2,3);        int k = add(1,2,3,4,5);        System.out.println(String.format("m=%d,n=%d,k=%d",m,n,k));}    static int add(int x,int... a){        int sum = 0;        for(int i=0;i&lt;a.length;i++){            sum += a[i];        }        return sum;    }}</code></pre><hr><p>注：①可变参数在方法内部被当作数组来处理</p><p>​②可变参数的实参可以是数组</p><p>​③一个方法只能有一个可变参数</p><p>​④可变参数可以和其他参数一起使用，但可变参数必须在末尾</p><br><h3 id="25-6-GC机制">25.6 GC机制</h3><ol><li><p>新生代：堆内存中，存放新创建的对象</p><ul><li><p>Young GC</p></li><li><p>标记-清除算法：①所有对象放入<em>Eden</em>区，若<em>Eden</em>满了则标记需要的对象，放入<em>Survivor</em>区1，清空<em>Eden</em>区==&gt;②<em>Eden</em>区又满了则标记需要的对象，将该对象和<em>Survivor</em>区1中的对象放入<em>Survivor</em>区2中，清空<em>Eden</em>区和<em>Survivor</em>区1==&gt;③以此重复交换<em>Survivor</em>区1和<em>Survivor</em>区2</p></li></ul></li><li><p>老年代：堆内存中，存放新时代中多次存活(默认15次，可修改上限)的对象</p><ul><li><p>Full GC：</p><p>①剩余存活的对象&gt;新生代的<em>Survivor</em>+老年代</p><p>②空间分配担保失败</p><p>③执行<code>System.gc()</code>时，但不一定立即触发</p></li></ul></li></ol><br><h1>26.递归</h1><ol><li>递归简洁，但性能消耗大，效率低，要求高性能情况下应用循环迭代</li><li>递归两步骤<ul><li>找递归终止条件</li><li>把一个问题拆分成多个子问题，再调用自身处理子问题</li></ul></li></ol><pre><code class="language-java">public class demo{    static int f(int n){        //终止条件        if(n==1) return 1;        //调用自己        return n*f(n-1);    }    public static void main(String args[]){int x = f(5);        System.out.println(x);}}</code></pre><pre><code class="language-java">//斐波那契数列//循环public class demo{    public static void main(String args[]){int f1 = 1,f2 = 1;        System.out.println(f1);        System.out.println(f2);        for(int i =2;i&lt;20;i++){            int f3 = f1 + f2;            System.out.println(f3);            f1 = f2;            f2 = f3;        }}}//数组public class demo{    public static void main(String args[]){int[] f = new int[20];        f[0] = 1;        f[1] = 1;        for(int i =2;i&lt;20;i++){        f[i] = f[i-1]+f[i-2];            System.out.println(f[i]);}}}//递归public class demo{    int f(int n){        //终止条件        if(n==1 || n==2) return 1;        //调用自己        return f(n-1)+f(n-2);    }    public static void main(String args[]){int x = f(5);        System.out.println(x);}}</code></pre><br><h1>27.反射</h1><ol><li><p>机制：在运行状态下，动态获取任意一个类的属性、方法或任意一个对象的方法和属性</p></li><li><p>原理：①在程序中创建对象(<code>new</code>)==&gt;②JVM到本地磁盘找需要加载的类(<code>Xxx.class</code>)==&gt;③通过类加载器<em>classLoader</em>加载到内存中，创建类对象，一个类有且仅有一个<em>class</em>对象,<em>class</em>对象中包含了类的信息==&gt;④在内存中创建对象空间</p></li><li><p>类：</p><p>①全限定类名：<code>包名.类名</code></p><p>②Class类的加载：</p><ul><li>通过类名加载：<code>Class&lt;?&gt; xX = Class.forname(全限定类名)</code></li><li>通过字节码文件加载(<strong>推荐使用</strong>)：<code>Class&lt;?&gt; xX = 类名.class</code></li><li>通过类实例加载：<code>Class&lt;?&gt; xX = 类实例名.getClass()</code></li></ul><p>③Class类的常用方法：</p><ul><li><p>创建类的实例(无参构造器，已过时)：<code>newInstance()</code></p></li><li><p>获得类的加载器：<code>getClassLoader()</code></p></li><li><p>获取类的包：<code>getPackage()</code></p></li><li><p>获取类的名字：<code>getSimpleName()</code></p></li><li><p>获取当前类父类的名字：<code>getSuperclass()</code></p></li><li><p>获取当前类实现类或者接口：<code>getInterfaces()</code></p></li><li><p>获取所有共有的属性对象：<code>getFields()</code></p></li><li><p>获取某个共有的属性对象：<code>getField(String name)</code></p></li><li><p>获取所有属性对象(包括私有)：<code>getDeclaredFields()</code></p></li><li><p>获取某个属性对象(包括私有)：<code>getDeclaredField(String name)</code></p></li><li><p>获取所有共有的方法(包括父类)：<code>getMethods()</code></p></li><li><p>按名称和参数类型获取某个共有的方法：<code>getMethod()</code></p></li><li><p>获取本类声明的所有方法(包括私有)：<code>getDeclaredMethods()</code></p></li><li><p>按名称和参数类型获取本类声明的某个方法(包括私有)：<code>getDeclaredMethod()</code></p></li><li><p>获取该类的所有的公有构造器：<code>getConstructors()</code></p></li><li><p>获取该类中与类型参数匹配的公有构造器：<code>getConstructor(Class... &lt;?&gt; parameterTypes)</code></p></li><li><p>获取该类的所有构造器：<code>getDeclaredConstructors</code></p></li><li><p>获取该类中与类型参数匹配的构造器(包括私有)：<code>getDeclaredConstructor(Class... &lt;?&gt; parameterTypes)</code></p></li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]) throws Exception{        //1.加载Student类Class&lt;?&gt; clazz = Student.class        //2.创建类实例        Object o = clazz.getDeclaredConstructor(String.class,String.class)            .newInstance("1001","李四");        //3.调用方法        System.out.println(o.toString());}}</code></pre><p>④Method类：反射中的一个内部类，用于表示类中的方法，通过Method类动态访问和修改类的方法</p><ul><li>调用方法：<code>invoke(Object obj,Object... args)</code></li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]) throws Exception{        //1.加载Student类Class&lt;?&gt; clazz = Student.class        //2.调用无参构造器，创建Student类实例        Object student = clazz.getDeclaredConstructor().newInstance();        //3.已知方法名，获取setId、setName、concat方法        Method setId = clazz.getDeclaredMethod("setId",String.class);        Method setName = clazz.getDeclaredMethod("setName",String.class);        Method concat = clazz.getDeclaredMethod("concat",Long.class,String.class);        //4.实例对象执行方法        setId.invoke(student,"1001");        setId.invoke(student,"李四");        String stuinfo = (String) concat.invoke(student,1002L,"李四")；        //5.输出        System.out.println(student.toString());        System.out.println(stuinfo);}}</code></pre><p>④Field类：反射中的一个内部类，用于表示类中的字段，通过Field类动态访问和修改类的字段</p><pre><code class="language-java">public class demo{    public static void main(String args[]) throws Exception{        //1.加载Student类Class&lt;?&gt; clazz = Student.class        //2.调用无参构造器，创建Student类实例        Object student = clazz.getDeclaredConstructor().newInstance();        //3.已知属性名，获取id、name属性        Field id = clazz.getDeclaredField("id");        Field name = clazz.getDeclaredField("name");        //4.给属性赋值        id.setAccessible(true); //解除属性的保护        id.set(student,"1001");        name.setAccessible(true); //解除属性的保护        name.set(student,"李四");        //5.输出        System.out.println(id.get(student)+"\t"+name.get(student));}}</code></pre></li><li><p>用法：</p><p>①创建<code>test.properties</code>，在里面只写：</p><pre><code class="language-properties">id:1001name:aaa</code></pre><p>②通过反射动态获取实例对象属性：</p><pre><code class="language-java">public class demo{    public static void main(String args[]) throws Exception{        //1.加载Student类Class&lt;?&gt; clazz = Student.class        //创建Student类的实例        Object student = clazz.getDeclaredConstructor().newInstance();         //2.读取文件内容        File file =             new File("E:\\java\\demo\\src\\main\\java\\com\\text\\test.properties");        FileInputStream in = new FileInputStream(file);        int c;        StringBuilder sb = new StringBuilder();        while ((c=in.read()) != -1){            sb.append((char)c);        }        System.out.println(sb.toString());        //3.分割文件内容        String[] lines = sb.toString().split("\r\n"); //将读取出的文件内容按回车、换行分割放入lines里        for(String line : lines){            String[] kv = line.split(":"); //从lines里读取每一个line按“：”进行分割再放入kv里            // System.out.println(kv[0]+"--"+kv[1]); //每次按“：”分割后的第一个和第二个之间用“--”连接            Field field = clazz.getDeclaredField(kv[0]); //根据属性名kv[0]的内容来获取属性field            field.setAccessible(true); //解除属性的保护            field.set(student,kv[1]); //给实例student的属性field赋值kv[1]        }System.out.println(student.toString());}}</code></pre><p>通过反射动态获取实例对象方法：</p><pre><code class="language-java">public class demo{    public static void main(String args[]) throws Exception{        //1.加载Student类Class&lt;?&gt; clazz = Student.class        //创建Student类的实例        Object student = clazz.getDeclaredConstructor().newInstance();         //2.读取文件内容        File file =             new File("E:\\java\\demo\\src\\main\\java\\com\\text\\test.properties");        FileInputStream in = new FileInputStream(file);        int c;        StringBuilder sb = new StringBuilder();        while ((c=in.read()) != -1){            sb.append((char)c);        }        System.out.println(sb.toString());        //3.分割文件内容        String[] lines = sb.toString().split("\r\n"); //将读取出的文件内容按回车、换行分割放入lines里        for(String line : lines){            String[] kv = line.split(":"); //从lines里读取每一个line按“：”进行分割再放入kv里            // System.out.println(kv[0]+"--"+kv[1]); //每次按“：”分割后的第一个和第二个之间用“--”连接            // Field field = clazz.getDeclaredField(kv[0]); //根据属性名kv[0]的内容来获取属性field            // field.setAccessible(true); //解除属性的保护            // field.set(student,kv[1]); //给实例student的属性field赋值kv[1]            String fieldName = kv[0].substring(0,1).toUpperCase()+kv[0].substring(1); //将属性名首字母大写并连接首字母后面的字母            Method method = clazz.getDeclareMethod("set"+fieldName,String.class);            method.invoke(student,kv[1]); //执行实例student里的setfieldName方法并赋值kv[1]        }System.out.println(student.toString());}}</code></pre><br><h1>28.注解</h1><ol><li><p>注解/元数据，是JDK1.5之后的一个特性，与类、接口、枚举在同一个层次，且可以声明在包、类、字段、方法、局部变量、方法参数等前面，对这些元素进行说明</p></li><li><p>作用：</p><p>①编写文档：用代码里标识的元数据生成文档</p><p>②代码分析：用代码里标识的元数据对代码进行分析</p><p>③编译检查：用代码里标识的元数据让编译器实现编译检查</p></li><li><p>自定义注解：</p><p>①元注解控制注解的行为：</p><pre><code class="language-java">@Target(ElementType.METHOD) //注解只标记在方法上/*作用域(ElementType)标记位置TYPE  类、接口、枚举METHOD  方法FIELD  字段(包括枚举类常量)PARAMETER  方法参数CONSTRUCTOR  构造器LOCAL_VARIABLE  局部变量(编译后不保留)ANNOTATION_TYPE  其他注解PACKAGE  包声明(需在package-info,java)*/@Retention(RetentionPolicy.RUNTIME) //运行时保留@Documented //包含在Javadoc中</code></pre><p>②注解体：</p><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation{    //定义属性：类比接口中的方法需要实现，该属性也需要赋值；属性类型只能是基本数据类型、枚举、String、Class、其他注解或者它们的数组；若整个注解只有一个属性，则赋值时可省略其属性名    // String value(); //必须赋值的属性    String value() default "";    int priority() default 1; //带默认值的属性}</code></pre><pre><code class="language-java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Logger{    String value() default "log";    String level() default "INFO";}</code></pre><pre><code class="language-java">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ExceptionHandler{    String value() default "error";    String message() default "内部错误";}</code></pre><pre><code class="language-java">@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface NotNull{    String message() default "字段不能为空";}</code></pre><p>③注解体的实现(通过反射)：</p><pre><code class="language-java">public class User{    @NotNull(message = "用户名不能为空")    private String username;    @NotNull(message = "昵称不能为空")    private String nickName;//空值检查，@NotNull注解的实现@ExceptionHandler(value = "warring",message = "数据检查异常")public void validate() throws Exception{    //遍历所有字段    for(Field field : this.getClass().getDeclaredField()){        if(field.isAnnotationPresent(NotNull.class)){ //判断字段上是否有@NotNull注解，若有则进行空值检查            field.setAccessible(true);            //判断字段是否为空值            if(field.get(this) == null){                NotNull notNull = field.getAnnotation(NotNull.class);                throw new Exception(notNull.message());                }            }        }    }}</code></pre><br><h1>29.Stream流</h1><ol><li><p>Stream是处理集合的关键抽象概念，能执行复杂的查找(替代遍历)、过滤、映射数据等，其提供的API能对集合数据操作，类似SQL查询数据库</p></li><li><p>特点：</p><ul><li>不是数据结构，不会保存数据</li><li>不会修改原来的数据，而是将数据保存到另一个对象</li><li>惰性求值(懒加载)，只对操作进行记录，不会立即执行，要等到执行终止操作时才会进行实际的计算</li></ul></li><li><p>创建流</p><p>①用Collection下的<code>stream()</code>和<code>parallelStream()</code>方法将<strong>集合</strong>转换成流</p><pre><code class="language-java">List&lt;String&gt; list = new ArrayList();Stream&lt;String&gt; stream = list.stream(); //获取一个顺序流Stream&lt;String&gt; parallelStream = list.parallelStream(); //获取一个并行流</code></pre><p>②用Arrays中的<code>stream()</code>方法，将<strong>数组</strong>转换成流</p><pre><code class="language-java">Integer[] nums = new Integer[10];Stream&lt;Integer&gt; stream = Arrays.stream(nums);</code></pre><p>③用Stream中的静态方法<code>of()</code>、<code>iterate()</code>、<code>generate()</code>创建流</p><pre><code class="language-java">Stream&lt;Integer&gt; stream1 = Stream.of(1,2,3,4,5,6); //将of()里的内容转换成流对象Stream&lt;Integer&gt; stream2 = Stream.iterate(0,(x)-&gt;x+2).limit(6); //从0开始，每个元素+2迭代，截取6个元素stream2.forEach(System.out::println); //遍历打印stream2中的元素0,2,4,6,8,10Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(2); //生成随机数流对象，截取2个元素Stream3.forEach(System.out::println);</code></pre><p>④用BufferedReader下的<code>lines()</code>方法，将<strong>文件</strong>每行内容转换成流</p><pre><code class="language-java">BufferedReader reader = new BufferedReader(new FileReader("D:\\test\\test.txt"));Stream&lt;String&gt; lineStream = reader.lines();lineStream.forEach(System.out::println);</code></pre><p>⑤用Pattern(正则表达式)下的<code>splitAsStream()</code>方法，将<strong>字符串</strong>分割成流</p><pre><code class="language-java">Pattern pattern = Pattern.compile(","); //创建一个","的正则表达式模式Stream&lt;String&gt; stringStream = pattern.splitaAsStream("a,b,c"); //传入("a,b,c")并按正则表达式模式来分割字符串，返回一个Stream&lt;String&gt;类型数据stringStream.forEach(System.out::println); //a b c</code></pre></li><li><p>方法链</p><p>一种编程技术，基本思想是一个方法调用后立即调用另一个方法，将多个方法链在一起</p><pre><code class="language-java">//正常写法Stream&lt;Integer&gt; stream2 = Stream.iterate(0,(x)-&gt;x+2).limit(6); stream2.forEach(System.out::println); //方法链写法Stream.iterate(0,(x)-&gt;x+2).limit(6).forEach(System.out::println); </code></pre></li><li><p>操作流 Stream API</p><p>①筛选与切片</p><ul><li>filter：过滤流中的某些元素</li><li>limit(n)：截取前n个元素</li><li>skip(n)：跳过前n个元素，配合<code>limit(n)</code>实现分页</li><li>distinct：用流中元素的<code>hashCode()</code>和<code>equals()</code>去除重复元素</li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]){        //创建集合List&lt;Integer&gt; list = List.of(6,4,6.7,3,9,8,10);        //将集合转换成流，再筛选其中x&gt;5的元素(过滤x&lt;5的元素)，再遍历打印        list.stream().filter(x-&gt;x&gt;5).forEach(System.out::println);        Stream&lt;Integer&gt; stream = Stream.of(6,4,6,7,9,8,10,12,14,14);        Stream&lt;Integer&gt; newStream = Stream.filter(s-&gt;s&gt;5) //6 6 7 9 8 10 12 14 14            .distinct() //去重，6 7 9 8 10 12 14            .skip(2) //跳过前两个元素，9 8 10 12 14            .limit(2) //截取前两个元素，9 8        newStream.forEach(System.out::println); //9 8    }}</code></pre><p>②映射：对流里的每一个元素进行处理</p><ul><li>map：接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个<strong>新的元素</strong>，可用于数据类型转换(一进一出)</li><li>flatMap：接收一个函数作为参数，将流中的每一个值替换成另一个流，然后把所有流连接成一个流(一进多出)</li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]){List&lt;String&gt; list = Arrays.asList("a,b,c","10,20,30");//将每个元素转换成一个新的且不带逗号的元素，一进一出        Stream&lt;String&gt; s1 = list.stream().map(s-&gt;s.replaceAll(",","")); //replaceAll方法替换所有s1.forEach(System.out::println); //abc 102030，list里两个出来两个        //将逗号分隔的每个数据打印出来，一进多出        Stream&lt;String&gt; s3 = list.stream().flatMap(s-&gt;{            //将每个元素转换成一个stream            String[] split = s.split(","); //[a,b,c] [10,20,30]            Stream&lt;String&gt; s2 = Arrays.stream(split);            return s2; //a b c 10 20 30，list里两个，分割出来六个        });}}</code></pre></li><li><p>排序</p><ul><li>sorted()：自然排序，流中元素需实现Comparable接口</li><li>sorted(Comparator com)：定制排序，自定义Comparator比较器</li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]){        //自然排序List&lt;String&gt; list = Arrays.asList("aa","ff","dd");        //String类自身已经实现Comparable接口        list.stream().sorted().forEach(System.out::println);        //定制排序List&lt;Sku&gt; skus = new ArrayList&lt;&gt;();        skus.add(new Sku("A",100,200.0));        skus.add(new Sku("C",50,1200.0));        skus.add(new Sku("D",150,120.0));        skus.add(new Sku("B",200,1000.0));        //先按价格降序，价格相同则数量升序        skus.stream().sorted(        (o1,o2)-&gt;{                if(o2.getPrice() - o1.getPrice() == 0){                    return o2.getNum() - o1.getNum();                }                return (int)(o2.getPrice() - o1.getPrice());            }        ).forEach(System.out::println);}}</code></pre></li><li><p>消费</p><p>peek：得到流中的每一个元素，且能修改元素的值，但生成还是一个新的对象</p><pre><code class="language-java">public class demo{    public static void main(String args[]){        //定制排序List&lt;Sku&gt; skus = new ArrayList&lt;&gt;();        skus.add(new Sku("A",100,200.0));        skus.add(new Sku("C",50,1200.0));        skus.add(new Sku("D",150,120.0));        skus.add(new Sku("B",200,1000.0));        //先按价格降序，价格相同则数量升序        skus.stream().sorted(        (o1,o2)-&gt;{                if(o2.getPrice() - o1.getPrice() == 0){                    return o2.getNum() - o1.getNum();                }                return (int)(o2.getPrice() - o1.getPrice());            }        ).forEach(System.out::println);        //将数量&gt;=150的商品降价10%        skus.stream().filter(e -&gt; e.getNum() &gt;= 150)            .peek(e -&gt; e.setPirce(e.getPrice()*(1-0.1)))            .forEach(System.out::println);        //生成订单集合，订单：商品名称、数量、价格、金额        skus.stream().map(sku-&gt;{            double amount = sku.getNum()*sku.getPrice();            Order order = new Order(            sku.getName(),                sku.getNum(),                sku.getPrice(),                amount            );            return order;        }).forEach(System.out::println);}}</code></pre></li><li><p>匹配、聚合</p><ul><li>allMatch</li><li>noneMatch</li><li>anyMatch</li><li>findFirst</li><li>findAny</li><li>count</li><li>max</li><li>min</li></ul></li><li><p>规约</p><ul><li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code>：第一次执行时，accumulator函数的第一个参数为流中的第一个元素，第二个参数为流中的第二个元素；第二次执行时，第一个参数为第一次函数执行的结构，第二个参数为流中的第三个元素；依此类推</li></ul><pre><code class="language-java">public class demo{    public static void main(String args[]){List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);        Integer v = list.stream().reduce((x1,x2)-&gt;x1+x2).get(); //1+2=3--&gt;3+3=6...        System.out.println(v); //55}}</code></pre><ul><li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></li><li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</code></li></ul><hr></li><li><p>收集</p></li></ol><ul><li>collect：接收一个Collector实例，将流中元素收集成另一个数据结构，以<strong>二次利用</strong></li></ul><pre><code class="language-java">public class demo{ public static void main(String args[]){     //定制排序   List&lt;Sku&gt; skus = new ArrayList&lt;&gt;();     skus.add(new Sku("A",100,200.0));     skus.add(new Sku("C",50,1200.0));     skus.add(new Sku("D",150,120.0));     skus.add(new Sku("B",200,1000.0));          //先按价格降序，价格相同则数量升序     skus.stream().sorted(     (o1,o2)-&gt;{             if(o2.getPrice() - o1.getPrice() == 0){                 return o2.getNum() - o1.getNum();             }             return (int)(o2.getPrice() - o1.getPrice());         }     ).forEach(System.out::println);          //生成订单集合，订单：商品名称、数量、价格、金额     List&lt;Order&gt; orders = skus.stream().map(sku-&gt;{         double amount = sku.getNum()*sku.getPrice();         Order order = new Order(         sku.getName(),             sku.getNum(),             sku.getPrice(),             amount         );         return order;     }).collect(Collectors.toList()); //收集商品集合，转换成订单集合，以对订单进行二次计算     orders.forEach(System.out::println); //再打印          //将数量&gt;=150的商品降价10%     List&lt;Sku&gt; sku1 = skus.stream().filter(e -&gt; e.getNum() &gt;= 150)         .peek(e -&gt; e.setPirce(e.getPrice()*(1-0.1)))         .collect(Collectors.toList()); //收集所有降价的商品成一个变量sku1，以用于二次计算     sku1.forEach(System.out::println); //再打印}}</code></pre><ol start="11"><li><p>Optional类</p><p>​在Stream API中，有很多方法如max、min、reduce，返回值是Optional；</p><p>​在Java中尝试访问空引用的属性调用空引用的方法是会报空指针异常，因此项目中会有很多条件判空，较为冗杂，所以Optional类引入了一种显式的方式来处理可能为空的对象，强制在可能为空的情况下进行显示;</p><p>​Optional类似容器，可以包含各种类型的值，也可以是null，Optional类提供了许多方法以方便操作内部的值，常用的如get、orElse、orElseGet、orElseThrow等</p><p>​</p><p>①构建Optional对象</p><ul><li>empty()：构建一个空的Optional对象</li><li>of(T value)：构建一个非空的Optional对象，如果为空则报错</li><li>ofNullable(T value)：构建一个Optional对象，允许为空</li></ul><hr><pre><code class="language-java">//1.构建一个空的Optional对象Optional&lt;Object&gt; empty = Optional.empty();Optional&lt;Object&gt; ob = Optional.ofNullable(null);//2.构建一个非空的Optional对象Optional&lt;Object&gt; oa = Optional.of("123");Optional&lt;Object&gt; oc = Optional.ofNullable("123");</code></pre><hr><p>②访问Optional的值</p><ul><li>get()：取值，若取值对象为null，则报异常</li><li>orElse()：用于获取值或者在值为空的情况下提供一个默认值</li><li>orElseGet()：提供默认值的工厂</li><li>orElseThrow()：用于Optional对象中的值为空时抛出一个指定的异常</li></ul><pre><code class="language-java">Sku sku = null;Optional&lt;Sku&gt; op = Optional.ofNullable(sku);// String name = op.get().getName(); //异常String name1 = op.orElse(new Sku("A",100,200.0)).getName();System.out.println(name1); //AString name2 = op.orElseGet(()-&gt;new Sku("B",100,200.0)).getName();System.out.println(name2); //Bop.orElseThrow(()-&gt;new Exception("对象为空")).getName();String name = op.get().getName(); //抛出"对象为空"异常</code></pre><p>③空检查</p><br></li></ol></li></ol></li></ol></li></ol></li></ul></li></ol><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/C-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/C-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>1.关于<code>#include&lt;iostream&gt;</code></h1><p><em>C++语言</em>里<code>#include&lt;iostream&gt;</code>用于<em>引入标准输入输出流</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>即<code>cin(输入)</code>和<code>cout(输出)</code>，例如：</p><pre><code class="language-C++">#include"iostream"using namespace std;int main(){    int j; //声明整数j                                               cin &lt;&lt; j; //从键盘输入一个整数作为j的值                int i=1; //声明整数i的值为1    cout &lt;&lt; "输出的内容" &lt;&lt; i &lt;&lt; endl; //输出i的值}</code></pre><p>而<code>std::cout</code>与<code>cout</code>的区别是：<br><code>std</code>是一个<em>命名空间（namespace）</em>，<code>::</code>是<em>作用域</em>运算符，<code>cout</code>是<em>std空间</em>中的一个<em>函数名</em>，所以使用<code>cout</code>时，<strong>必须</strong>有使用std命名空间的说明<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，有两种说明方式（<code>cin</code>同理），如下：<br>①方式一：每次使用时都对cout说明</p><pre><code class="language-C++">#include"iostream"int main(){    std::cout&lt;&lt;"Input two numbers:";}</code></pre><p>②方式二：在主函数前说明一下，后面就可以直接使用cout</p><pre><code class="language-C++">#include"iostream"using namespace std;int main(){    cout &lt;&lt; "Input two numbers:";}</code></pre><h1>2.关于#pragma once</h1><p><em>C++语言</em>里<code>#pragma once</code>是用于<em>预编译</em>，为了<em>避免</em> <strong>同一个头文件</strong>被<code>include</code>多次，这里所说的<strong>同一个文件</strong>是指<strong>物理上</strong>的<em>一个文件</em>，而不是指<strong>内容相同</strong>的<em>两个文件</em></p><h1>3.关于<code>#include&lt;cstdlib&gt;</code></h1><p><em>C++语言</em>里<code>#include&lt;cstdlib&gt;</code>相当于<em>C语言</em>中<code>#include&lt;stdlib.h&gt;</code>的增强版，它包含了<em>C标准库的通用工具函数</em>，如<code>malloc</code>和<code>free</code>函数等</p><h1>4. nullptr关键字</h1><p>①在<em>C++11</em>之前，通常使用<code>0</code>或<code>NULL</code>来表示<strong>指针为空</strong>；在<em>C++11</em>中，引入了<code>nullptr</code><em>关键字</em>，它被定义为<code>std::nullptr_t</code><em>数据类型</em>的字面值<em>常量</em>，用于表示<strong>空指针</strong><br>②<em>C++11</em>中，初始化指针变量时，可以将其初始化为<code>nullptr</code>，如：<code>int *p = nullptr</code>，这种方式可以避免由于误解空指针的含义而导致的错误<br>③在<em>C++11</em>之后，<strong>不推荐</strong>使用<code>0</code>或<code>NULL</code>来表示<strong>空指针</strong>，因为它们在语义上<strong>不够明确</strong>，容易产生歧义；此外，对于<em>整型变量和指针类型变量</em> <strong>混用时</strong>，可能会导致一些问题<br>④由于<code>nullptr</code>是一个<strong>关键字</strong>，在进行初始化时<strong>不能</strong>将其改成其他字符，否则将会导致编译错误</p><h1>5. new关键字</h1><p>①<code>new</code>是<em>C++语言</em>中的一个<strong>关键字</strong>，用于在<strong>堆区</strong> <em>动态分配内存</em>并<em>返回其地址（即指针）</em>，可以使用<code>new</code>关键字<em>实例化一个类对象</em>、*分配一个数组或在堆区中动态分配内存等<br>②对于<strong>基本数据类型</strong>，使用<code>new</code>时可以<strong>指定初值</strong>，例如：</p><pre><code class="language-C++">int *p = new int(10);  //分配4个字节的内存，初始化为10，返回指向该内存的指针</code></pre><p>③对于<strong>自定义类型</strong>，需要通过<strong>构造函数</strong>来初始化对象，例如：</p><pre><code class="language-C++">class MyClass {public:    MyClass() { cout &lt;&lt; "MyClass Constructor" &lt;&lt; endl; }};MyClass *obj = new MyClass();  //动态分配内存并调用构造函数，返回指向该对象的指针</code></pre><p>④需要注意的是，在使用<code>new</code>关键字<strong>动态分配内存</strong>时，如果程序出现<strong>异常终止</strong>，可能会导致<strong>内存泄漏</strong>，所以在<strong>动态分配内存</strong>后应<strong>必须手动</strong>使用<code>delete</code>关键字<strong>释放内存</strong>，或使用<strong>智能指针</strong>等方式来<strong>自动管理内存</strong></p><h1>6.指向常量对象的常量指针(如：const double *point)</h1><pre><code class="language-C++">#include "iostream"using namespace std;int main() {    const double pi = 3.14;    const double *point = &amp;pi; //指向常量对象的常量指针    //不能通过指针point来修改pi的值    cout &lt;&lt; "pi的原始值：" &lt;&lt; pi &lt;&lt; endl;  //输出为 pi的原始值：3.14    //*point = 3.1415;  //错误：指针point指向的对象是常量，不能修改其值    //但是指针point自身的值可以修改，即可以指向其他的常量对象    const double anotherPi = 3.1415926;    point = &amp;anotherPi;  //可以修改指针point指向的其他对象的地址    cout &lt;&lt; "anotherPi的值：" &lt;&lt; *point &lt;&lt; endl;  //输出为 anotherPi的值：3.14159    return 0;}</code></pre><h1>7.指向常量的常量指针(如：double* const point)</h1><pre><code class="language-C++">#include "iostream"using namespace std;int main() {    double a = 1.0, b = 2.0;    double* const point = &amp;a;  //指向常量的常量指针    //指针point指向的对象是变量，可以通过指针point来修改该对象的值    cout &lt;&lt; "a的原始值：" &lt;&lt; a &lt;&lt; endl;  //输出为 a的原始值：1    *point = 3.0;    cout &lt;&lt; "a改变后的值：" &lt;&lt; a &lt;&lt; endl;  //输出为 a的改变后的值：3    //但是指针point自身的值不能修改，即不能指向其他的对象    //point = &amp;b;  //错误：指针point是常量，其地址不能改变    return 0;}</code></pre><h1>8.内联函数</h1><p>①内联函数是一种<strong>特殊的函数</strong>，它的<strong>函数体</strong>通常比较<strong>短小</strong>，并<strong>被频繁使用</strong>；在编译时，编译器将在<strong>每个</strong>调用处<strong>直接</strong>把内联函数的代码<strong>嵌入</strong>到调用该函数的地方，这样可以<strong>减少</strong>函数调用的<strong>开销</strong>，<strong>提高</strong>程序的执行<strong>效率</strong><br>②内联函数是对<strong>函数调用机制</strong>的<strong>优化</strong>，它并<strong>不影响</strong>函数的<strong>本质</strong>，且仍然<strong>遵循</strong>函数的<strong>语法</strong><br>③内联函数的<strong>局限性</strong>：内联函数过多会导致可执行程序的<strong>体积增大</strong><br>④内联函数<strong>不能</strong>被<strong>递归</strong>调用，因为递归需要在<strong>函数栈中</strong>存储<strong>每次</strong>调用的<strong>数据</strong>和<strong>返回地址</strong>，而内联函数的代码是在调用点<strong>直接嵌入</strong>到程序中的，<strong>没有函数栈</strong><br>⑤在<em>C++语言</em>中，用关键字<code>inline</code>来声明一个<em>内联函数</em>，如下：</p><pre><code class="language-C++">#include "iostream"using namespace std;//声明内联函数addinline int add(int a, int b) {    return a + b;}int main() {    int a = 3, b = 4;    int sum = add(a, b); // 调用内联函数add    cout &lt;&lt; "sum = " &lt;&lt; sum &lt;&lt; endl;    return 0;}</code></pre><h1>9.构造函数与内联函数</h1><p>①构造函数的<strong>调用时机</strong>和普通函数<strong>不同</strong>，构造函数在<strong>对象</strong>被<strong>创建</strong>时被调用，而<strong>不是</strong>通过<strong>函数名</strong>进行<strong>显式调用</strong><br>②<strong>构造函数</strong>可以<strong>被声明</strong>为<strong>内联函数</strong>，因为它们<strong>经常</strong>被用来<strong>创建类的对象</strong>，并且它们的<strong>函数体</strong>通常比较<strong>短小</strong><br>③将构造函数声明为内联函数<strong>并不是必须的</strong>，<strong>只有</strong>当构造函数的<strong>函数体</strong>非常<strong>简短</strong>并且在程序中被<strong>频繁</strong>使用时才可以考虑使用内联函数，<strong>如果</strong>构造函数的<strong>函数体很长</strong>，则声明为内联函数会<strong>增加可执行文件的大小</strong>而会<strong>适得其反</strong>，不过由于<strong>编译器</strong>会<strong>根据具体情况决定</strong>是否将函数展开成内联函数，所以在实际上，将构造函数声明为内联函数<strong>可能</strong>并<strong>不能</strong>真正地<strong>提高程序的执行效率</strong></p><h1>10.析构函数（析构方法）</h1><pre><code class="language-C++">#include "iostream"#include "cstring"class Person {public:    // 构造函数    Person(const char* name, int age) {        m_name = new char[strlen(name) + 1];        strcpy(m_name, name);        m_age = age;    }    // 析构函数    ~Person() {        std::cout &lt;&lt; "释放 " &lt;&lt; m_name &lt;&lt; " 所占用的内存" &lt;&lt; std::endl;        delete[] m_name;    }    // 成员函数    void printInfo() {        std::cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt; ", 年龄：" &lt;&lt; m_age &lt;&lt; std::endl;    }private:    char* m_name;    int m_age;};int main() {    // 创建一个 Person 对象    Person* person = new Person("Jack", 25);    // 使用对象的成员函数    person-&gt;printInfo();    // 释放对象所占用的内存    delete person;    return 0;}</code></pre><p>①析构函数（析构方法）写法为<code>~类名() {}</code><br>②析构函数是一种<strong>特殊的</strong>成员函数，当一个对象被销毁时，如：一个局部变量离开了作用域、一个对象被<code>delete</code>掉等，就会执行析构函数<br>③析构函数通常用于<strong>释放对象所占用的资源</strong>，如：释放动态分配的内存、关闭打开的文件、断开网络连接等，但由于<em>C++语言</em>没有<strong>垃圾回收机制</strong>，因此需要<strong>手动释放资源</strong>，否则可能会导致<strong>程序崩溃</strong>或<strong>资源泄漏</strong>等问题</p><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>C++的I/O发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>用于避免导致全局命名冲突问题 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo页脚插入网站运行时间和不蒜子统计</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E9%A1%B5%E8%84%9A%E6%8F%92%E5%85%A5%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E9%A1%B5%E8%84%9A%E6%8F%92%E5%85%A5%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>1.网站页脚插入网站运行时间</h1><p>找到博客主题文件夹对应的页脚渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>footer.ejs</code>文件，把下面代码插入到<code>&lt;/footer&gt;</code>之前，然后在<code>var grt= new Date("08/10/2020 00:00:00")</code>把<code>08/10/2020 00:00:00</code>修改为自己的建站时间</p><pre><code>&lt;div&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt;    var now = new Date();     function createtime() {         var grt= new Date("08/10/2020 00:00:00");//在此处修改你的建站时间        now.setTime(now.getTime()+250);         days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);         hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);         if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);         mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}         seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);         snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}         document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 ";         document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";     } setInterval("createtime()",250);&lt;/script&gt;&lt;/div&gt;</code></pre><h1>2.不蒜子脚本使用</h1><p>找到博客主题文件夹对应的页脚渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>footer.ejs</code>文件，把下面代码插入到<code>&lt;/footer&gt;</code>之前；然后<code>&lt;script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</code>这行代码里<code>src=""</code>后面要填的就是不蒜子<strong>最新的</strong>脚本域名，可以在不蒜子官方网址查询</p><pre><code>&lt;div class="busuanzi-count"&gt;    &lt;script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;    &lt;span class="site-uv"&gt;      &lt;i class="fa fa-user"&gt;&lt;/i&gt;      总访客 &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 人      &lt;span class="post-meta-divider"&gt; | &lt;/span&gt;    &lt;/span&gt;    &lt;span class="site-uv"&gt;      &lt;i class="fa fa-eye"&gt;&lt;/i&gt;      访问量 &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次    &lt;/span&gt;&lt;/div&gt;</code></pre><blockquote><p>不蒜子官方网址:<a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a><br>参考文章1:<a href="https://blog.csdn.net/qq_39720594/article/details/105411030">https://blog.csdn.net/qq_39720594/article/details/105411030</a><br>参考文章2:<a href="https://blog.csdn.net/wangqingchuan92/article/details/126346205">https://blog.csdn.net/wangqingchuan92/article/details/126346205</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 网站运行时间统计 </tag>
            
            <tag> 访问量统计 </tag>
            
            <tag> 总访客数统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插入彩色滚动文字</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E6%8F%92%E5%85%A5%E5%BD%A9%E8%89%B2%E6%BB%9A%E5%8A%A8%E6%96%87%E5%AD%97/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E6%8F%92%E5%85%A5%E5%BD%A9%E8%89%B2%E6%BB%9A%E5%8A%A8%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1>一段代码搞定</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前，也可以是其他位置；其中<code>var l = " Hi. "</code>的<code>Hi.</code>，<code>return r + "."</code>里的<code>.</code>，还有<code>o = []</code>中<code>[]</code>里的文字都可以自行修改</p><pre><code>&lt;p style="text-align:center" id="saintwei"&gt;&lt;/p&gt;&lt;script&gt;   var saintwei = function (r) {       function t() {           return b[Math.floor(Math.random() * b.length)]       }       function e() {           return String.fromCharCode(94 * Math.random() + 33)       }       function n(r) {           for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) {               var l = document.createElement("span");               l.textContent = e(), l.style.color = t(), n.appendChild(l)           }           return n       }       function i() {           var t = o[c.skillI];           c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)       }       var l = " Hi. ",           o = ["Welcome to my blog", "世界本就如此艰难，何必还要让它更艰难呢", "你若盛开，蝴蝶自来；你若精彩，天自安排", "Are You OK", "转身变成一只猫"].map(function (r) {               return r + "."           }),           a = 2,           g = 1,           s = 5,           d = 75,           b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],           c = {               text: "",               prefixP: -s,               skillI: 0,               skillP: 0,               direction: "forward",               delay: a,               step: g           };       i()   };   saintwei(document.getElementById('saintwei'));&lt;/script&gt;</code></pre><blockquote><p>参考文章:<a href="https://blog.csdn.net/qq_25896347/article/details/117968673">https://blog.csdn.net/qq_25896347/article/details/117968673</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 彩色滚动文字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo标题搞怪特效</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E6%A0%87%E9%A2%98%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E6%A0%87%E9%A2%98%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h1>1.直接法（已成功）</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前；其中离开本网站和回到本网站的<strong>表情和中文</strong>可以自行更改</p><pre><code>&lt;script type="text/javascript"&gt;    var OriginTitile=document.title,st;document.addEventListener("visibilitychange",function(){        document.hidden?(document.title="o(இ௰இ)怎么就走了！",clearTimeout(st)):(document.title="☆*o(≧▽≦)o*☆欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))    })&lt;/script&gt;</code></pre><h1>2.借用法（未实践）</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前；目的是借用别人写好的<code>js</code>文件链接，但不能修改里面的<strong>表情和中文</strong>，且这个链接的存在和消亡取决于发这个链接的作者o(≧口≦)o</p><pre><code>&lt;script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.5/source/js/FunnyTitle.js"&gt;&lt;/script&gt;</code></pre><blockquote><p>参考资料:<a href="https://blog.csdn.net/victoryxa/article/details/105841309/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8--blog-86065141.235%5Ev38%5Epc_relevant_sort&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11">https://blog.csdn.net/victoryxa/article/details/105841309/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8--blog-86065141.235^v38^pc_relevant_sort&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 标题搞怪特效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Aplayer插件在Hexo上插入音乐</title>
      <link href="/CuteFox_Home.github.io/2023/08/30/%E7%94%A8Aplayer%E6%8F%92%E4%BB%B6%E5%9C%A8Hexo%E4%B8%8A%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/"/>
      <url>/CuteFox_Home.github.io/2023/08/30/%E7%94%A8Aplayer%E6%8F%92%E4%BB%B6%E5%9C%A8Hexo%E4%B8%8A%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h1>1.安装hexo-tag-aplayer插件</h1><pre><code class="language-bash">$ npm install --save hexo-tag-aplayer</code></pre><h2 id="2-使用">2.使用</h2><h3 id="2-1-Aplayer播放器基本格式">2.1 Aplayer播放器基本格式</h3><p>在每篇文章即<code>.md</code>文件中的正文中添加如下内容：</p><pre><code class="language-md">{% aplayer title author music-url [picture-url, lrc:lrc-url, width:xx%, autoplay, narrow] %}</code></pre><p>但如果无法直接在标签参数中加入空格，则直接将参数用<strong>双引号</strong>括起来使用，如下：</p><pre><code class="language-md">{% aplayer "title" "author" "music-url" "picture-url" "lrc:lrc-url" "width:xx%" "autoplay" "narrow" %}</code></pre><p>其中，<code>{% aplayer %}</code>是<strong>必须</strong>写上的格式，其他<strong>标签参数</strong>具体如下：</p><ul><li><code>title</code>：歌曲的标题（必选）</li><li><code>author</code>：歌曲的作者（必选）</li><li><code>music-url</code>：歌曲本体的URL地址（必选）</li><li><code>picture-url</code>：歌曲封面的URL地址（可选）</li><li><code>lrc-url</code>：歌词的URL地址（可选）</li><li><code>width:xx%</code>：宽度（可选，默认100%）</li><li><code>autoplay</code>：自动播放（可选，移动端暂不支持）</li><li><code>narrow</code>：袖珍风格播放器（可选）<br>若在网站根目录下的<code>config.yml</code>文件中将<code>post_asset_folder</code>设为<code>true</code>，即开启了Hexo的文章资源文件夹功能，则可以将歌曲本体、歌曲封面、歌词放入<strong>与文章同名</strong>的对应的资源文件夹中，然后直接引用，如下：</li></ul><pre><code class="language-md">{% aplayer "Running In The Dark" "MONKEY MAJIK" "Running In The Dark.mp3" "Running In The Dark.jpg" "lrc:Running In The Dark.txt" %}</code></pre><p>效果如下<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found (Running In The Dark.jpg)");</script><p>除了单曲，还支持列表模式，具体可参照<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8">播放列表</a></p><h3 id="2-2-MeingJS播放器">2.2 MeingJS播放器</h3><p>介绍：MetingJS是基于Meting API的APlayer衍生播放器<br>功能：将支持对于QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放<br>①在网站根目录下的<code>config.yml</code>文件中添加如下：</p><pre><code class="language-yml">aplayer:  meting: true</code></pre><p>②在每篇文章即<code>.md</code>文件中的正文中添加如下内容：</p><pre><code class="language-md">{% meting "2068111443" "netease" "song" "theme:#7777" "mutex:true" "listmaxheight:340px" "preload:auto" %}</code></pre><p>效果如下：</p>    <div id="aplayer-JFRGXNAi" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2068111443" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#7777"></div><p>其中，<code>{% meting %}</code>是<strong>必须</strong>写上的格式，其他<strong>标签参数</strong>具体如下：</p><ul><li><code>2068111443</code>是歌曲ID（必选），如网易云音乐分享歌曲链接的时<code>https://music.163.com/song?id=2068111443&amp;userid=</code>中<code>2068111443</code>就是该歌曲的ID</li><li><code>netease</code>是网易云音乐平台（必选），也可以换成其他音乐平台如：<code>tencent</code>，<code>kugou</code>，<code>xiami</code>，<code>baidu</code>等</li><li><code>song</code>是歌曲的类型（必选），单曲是<code>song</code>，歌单是<code>playlist</code>(效果可以参考我的<a href="https://drphilip425.github.io/CuteFox_Home.github.io/about/">About</a>)，专辑是<code>album</code>，还有<code>search</code>和<code>artist</code></li><li><code>theme:#7777</code>是播放器主题色（可选），具体喜欢的RGB颜色请自行查找并更改</li><li><code>mutex:true</code>意思是选择<code>true</code>时，如果<strong>同页面</strong>有其他aplayer播放，<strong>该播放器</strong>会暂停</li><li><code>listmaxheight:340px</code>意思是播放列表的最大长度默认为<code>340px</code></li><li><code>preload:auto</code>意思是音乐文件预载入模式为<code>auto</code>，可以改为<code>none</code>或<code>metadata</code><br>更多标签参数请看<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD">选项列表</a></li></ul><p>③非post（正文）页面使用问题<br>如果在非post（正文）页面中无法使用Aplayer播放器，可以试试在<code>.md</code>文件添加<code>{% aplayer %}</code>或<code>{% meting %}</code>之前添加如下内容：</p><pre><code>&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"&gt;&lt;/script&gt;</code></pre><blockquote><p>hexo-tag-aplayer官方中文文档:<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md</a><br>参考文章:<a href="https://blog.csdn.net/hushhw/article/details/88092728">https://blog.csdn.net/hushhw/article/details/88092728</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>不知道是不是主题原因，我用F12查看发现我的歌曲本体和歌词都没成功上传，暂时没得到解决 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Aplayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/08/26/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/08/26/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>1.基本格式</h1><pre><code class="language-C">#include "stdio.h"...//函数体int main(){ ...//主函数}</code></pre><h2 id="1-1简单实例">1.1简单实例</h2><pre><code class="language-C">#include "stdio.h"void prinHello(){    printf("Hello World!");}int main(){    prinHello();    return 0;}</code></pre><h2 id="1-2具体讲解">1.2具体讲解</h2><p>(1)<code>#include</code>意思为<strong>导入</strong>，<code>stdio</code>为<strong>标准输入和输出</strong>，而<code>.h</code>为<strong>头文件</strong>，所以<code>#include"stdio.h"</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的意思是<strong>导入一个标准输入和输出的头文件</strong>，这个<strong>头文件</strong>通常是<strong>系统自带的库里的文件</strong>，而导入的<strong>头文件不同</strong>，能使用该文件里的<strong>函数就不同</strong></p><p>(2)①在<strong>函数体</strong>中<code>void</code>表示<strong>没有返回值</strong>，如需有返回值则将<code>void</code>改为<strong>具体的返回值类型</strong>，且在<code>{}</code>写上<code>retrun 返回值</code>；<br>②<code>prinHello</code>为<strong>函数名</strong>，函数名<strong>只能</strong>用<em>字母、下划线、数字表示</em>，<strong>不能</strong>使用<s>关键字</s>，且<strong>必须</strong>以<em>字母或下划线</em>开头，<strong>不能</strong>以<s>数字</s>开头；<br>③<code>()</code>里可以写形式参数（简称“形参”），形参用<code>数据类型 声明的变量</code>表示，也可以不添加形参表示<strong>空参</strong>，但在调用空参函数时还是需要<strong>在函数名后面</strong>加上<code>()</code>；<br>④<strong>函数具体内容</strong>写在<code>{}</code>里面，可以一个<code>{}</code>内嵌入许多<code>{}</code>，每一个语句写完都要用<code>;</code>隔开；<br>⑤<code>printf()</code>是<strong>系统自带的函数</strong>，表示把输入的内容<strong>打印</strong>在输出窗口，调用时在<code>printf</code>的<code>()</code>里添加<code>""</code>，并在<code>""</code>里输入想要打印的内容即可</p><p>(3)①<code>int main()</code>是<strong>主函数的入口</strong>，其<code>{}</code>写入<strong>主函数执行语句</strong>，因为C语言<strong>从上到下</strong>编译的特性，普通函数<strong>只能</strong>写在主函数<strong>上面</strong>，且主函数<strong>只有</strong>一个；<br>②<code>prinHello()</code>是一个<strong>调用</strong>上面已经写好的<strong>函数</strong>的语句；<code>return 0</code>表示<strong>返回值为0</strong>，即退出程序</p><h1>2.数据类型与格式符</h1><p>(1)数据类型与它的格式符<strong>一一对应</strong>，数据类型声明变量，格式符放在输入输出语句中<br>(2)常见的有:int–%d，double–%lf，float–%f，char–%c，long–%ld，short–%hd，unsigned int–%u …</p><h1>3.输出对齐与保留小数位数</h1><p>如<code>print("%10.2lf",a)</code>中<code>10</code>表示<strong>向右对齐</strong>10个位置，同理<code>-10</code>表示<strong>向左对齐</strong>10个位置，而<code>.2</code>表示<strong>保留小数后2位</strong></p><h1>4.非格式化输入和输出</h1><h2 id="4-1-gets-输入与puts-输出">4.1 gets()输入与puts()输出</h2><h3 id="4-1-1-gets-输入">4.1.1 gets()输入</h3><p>(1)用法：</p><pre><code class="language-C">int main(){ char arr[10],*s; //声明一个字符数组变量，即字符串和一个字符串指针 gets(arr); //从键盘上输入字符串，直到回车结束   gets(s); //从键盘上输入字符串，直到回车结束}</code></pre><p>(2)特点：<br>①<code>gets()</code>是从<em>键盘输入字符串</em> <strong>开始</strong>到<em>按下回车</em> <strong>结束</strong>，其中直到<em>回车</em>前<strong>有空格也行</strong>，且<em>回车</em> <strong>不包含</strong>在字符串内<br>②<code>gets(arr)</code>其中<code>arr</code>可以是<strong>字符串数组名</strong>，也可以是<strong>字符串指针</strong>，如果不是<em>字符串</em>而是<em>单个字符</em>，则<strong>编译</strong>可能不报错，<strong>但</strong> <strong>运行</strong>会报错</p><h3 id="4-1-2-puts-输出">4.1.2 puts()输出</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char arr[]="Hello World!"; //声明一个字符串arr并给该字符串赋值    puts(arr); //输出arr内容到屏幕    char* s; //声明一个字符串指针s    s="Hi! World"; //给s赋值    puts(s); //输出s指向的内容到屏幕    puts("Hello China!"); //直接输出括号里的内容}</code></pre><p>(2)特点：<br>①输出完字符串后会<strong>自动换行</strong><br>②<strong>只能</strong>输出<em>字符串</em>，<strong>不能</strong>输出<em>运算结果</em><br>③可以<strong>直接</strong>在<code>puts()</code>里写入要输出的字符串</p><h2 id="4-2-getchar-输入与putchar-输出">4.2 getchar()输入与putchar()输出</h2><h3 id="4-2-1-getchar-输入">4.2.1 getchar()输入</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char a; //声明一个单个字符变量a    a=getchar(); //从键盘上读取输入的单个字符赋值给a}</code></pre><p>(2)特点：<br>①无论从键盘上输入多少个字符，<code>getchar()</code>只读取输入的<strong>第一个字符</strong>作为返回值<br>②从<em>键盘输入字符</em> <strong>开始</strong>到<em>按下回车</em> 才<strong>结束</strong></p><p>(3)解释：<br><code>getchar()</code>是<code>stdio.h</code>中的<em>库函数</em>，它的作用是从<code>stdio</code>流中读入<strong>一个字符</strong>；键盘输入字符是<em>先存入缓冲区</em>，当你<em>按下回车</em>时，<code>getchar</code>就会<em>进入缓冲区</em>读取字符，<em>一次</em>只读取<em>第一个字符</em>，我们输入的一串字符被读出来是<code>getchar</code><em>循环读取</em>的结果，而<em>回车键</em>取代了我们输入的<em>第一个字符</em>，我们输入<code>getchar()</code>来<em>清除回车键</em>，达到从<em>第一个字符开始读起</em>的目的</p><h3 id="4-2-2-putchar-输出">4.2.2 putchar()输出</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char a; //声明单个字符变量a    a='A'; //把a赋值为A    putchar(a); //输出A    putchar(0x41); //因为A在ASCII码中十六进制为0x41，所以输出A    putchar('\x41'); //因为'\x41'就相当于十六进制的0x41，所以也输出A}</code></pre><p>(2)特点：<br>①向标准输出设备<strong>只</strong>输出<strong>一个字符</strong><br>②相当于<code>printf("%c",a)</code></p><h1>5.内存分配与释放函数</h1><h2 id="5-1-malloc函数分配动态内存地址">5.1 malloc函数分配动态内存地址</h2><p>(1)用法：</p><pre><code class="language-C">#include"stdlib.h"#include"stdio.h"int main(){    int* n; //声明一个整数型指针变量n    n = (int*) malloc(2*sizeof(int)); //为变量n分配动态内存空间    *n = 5; //把5这个值转成二进制存放在变量n的内存空间里    printf("变量n地址为: %d\n", n);    printf("变量n的值为: %d\n", *n);    return 0;    }</code></pre><p>(2)解释：<br>①使用<code>malloc</code>函数<em>分配动态内存空间</em>时要先引入<code>#include&lt;stdlib.h&gt;</code>头文件<br>②<code>malloc</code>函数的<em>函数原型</em>为<code>void* malloc(unsigned int size)</code>，它根据<em>参数</em>指定的尺寸来分配内存空间，且返回一个<code>void</code>型指针，指向新分配的内空间的<em>初始地址</em>；但如果内存分配失败（内存不足），则函数返回<code>NULL</code><br>③<code>n=(int*)malloc(2*sizeof(int))</code>这段代码中，<code>sizeof(int)</code>是分配一个整数类型所占用的字节数的内存空间，通常为4个字节，所以<code>malloc(2*sizeof(int))</code>表示分配一个大小为<code>2*sizeof(int)</code>字节的内存空间，即分配了8个字节大小的内存空间<br>④<code>n=(int*)malloc(2*sizeof(int))</code>这段代码中，<code>(int*)malloc</code>这样写的原因是<code>malloc</code>函数原本返回的是一个<code>void*</code>类型的指针，但指针变量<code>n</code>是<code>int*</code>型的，所以需要将其<em>强制转换</em>为<code>int*</code>类型，才能够将其赋值给一个<code>int*</code>型即<strong>整型指针变量</strong></p><h2 id="5-2-free函数释放动态分配的内存">5.2 free函数释放动态分配的内存</h2><p>(1)用法：</p><pre><code class="language-C">#include"stdlib.h"#include"stdio.h"int main(){    int* n; //声明一个整数型指针变量n    n = (int*) malloc(2*sizeof(int)); //为变量n分配动态内存空间    *n = 5; //把5这个值转成二进制存放在变量n的内存空间里    printf("变量n地址为: %d\n", n);    printf("变量n的值为: %d\n", *n);    free(n); //释放变量n分配的动态内存    return 0;    }</code></pre><p>(2)解释：<br>①使用<code>free</code>函数<em>释放动态分配的内存</em>时要先引入<code>#include&lt;stdlib.h&gt;</code>头文件<br>②用<code>free</code>函数去释放<strong>要释放的内存的指针</strong>为<code>NULL</code>时，则无事发生；但<strong>释放内存后的指针</strong>不能再<code>free</code>一次，否则会导致程序崩溃或者出现错误<br>③只有使用<code>malloc</code>、<code>calloc</code>、<code>realloc</code>等函数动态分配的内存，才能用<code>free()</code>函数进行释放<br>④<code>free</code>函数的函数原型为<code>void free(void* memblock)</code>，其中<code>memblock</code>参数是一个指针，指向要释放的内存空间，以避免内存泄漏；但<code>memblock</code>指针本身并不会消失，所以一般可以使用<code>free</code>函数后，<code>memblock=NULL</code>使<code>memblock</code>指针变为空指针</p><h1>6. enum枚举类型</h1><p>(1)用法：</p><pre><code class="language-C">#include "stdio.h"enum Weekday { //定义枚举类    Monday,    Tuesday,    Wednesday,    Thursday,    Friday,    Saturday,    Sunday};int main() {    enum Weekday today = Wednesday; //声明enum Weekday类型的today并用Wednesday赋值    printf("今天是星期%d\n", today + 1);    return 0;}</code></pre><p>(2)解释：<br>①枚举类型使用<code>enum</code>关键字进行定义<br>②枚举类型中的常量<em>默认从0开始递增</em>，所以上面的例子中，<code>Monday</code>的值为<code>0</code>，<code>Tuesday</code>的值为<code>1</code>，以此类推<br>③如果需要改变枚举类型中常量的值，可以在定义枚举类型时<em>显式指定</em>常量的值，如<code>Monday = 1</code></p><h1>7. typedef自定义类型与struct结构体</h1><p>(1)用法：</p><pre><code class="language-C">typedef struct Book{ //新的数据类型为struct Bookchar no[20];//ISBNchar name[20];//名字float price;//价格}novel; //别名为novelstruct Book{ //新的数据类型为struct Book   char no[20];//ISBN   char name[20];//名字   float price;//价格};</code></pre><p>(2)解释：<br>①结构体<code>struct</code>用于<strong>定义</strong>一个<strong>新的数据类型</strong>，这个<strong>新的数据类型</strong>可以由<strong>任意的基本数据类型</strong>构成，如<code>int</code>、<code>char</code>、<code>float</code>等<br>②自定义类型<code>typedef</code>一般和结构体<code>struct</code>一起用，只不过在<code>typedef struct Book{};</code>的<code>;</code>前多了一个可以<strong>添加别名</strong>的位置，如上面的<code>novel</code>，这个<strong>别名</strong>用于充当<strong>新的数据类型</strong><code>struct Book</code>来声明变量</p><h1>8. Status用法</h1><p>(1)用法：</p><pre><code class="language-C">#include "stdio.h"typedef enum { //自定义枚举类型    SUCCESS, //成功    ERROR //失败} Status; //别名为StatusStatus foo() { //Status类型的foo函数    return SUCCESS;// 函数逻辑}int main() {    Status result = foo(); //声明一个Status类型的result，用同样Status类型的foo函数赋值    if (result == SUCCESS) {        printf("函数执行成功\n");    } else {        printf("函数执行失败\n");    }    return 0;}</code></pre><p>(2)解释：<br>Status通常是一个自定义的类型（<code>typedef</code>），用于表示函数的返回状态；它通常被定义为一个枚举类型（<code>enum</code>）或整型类型（<code>int</code>），用来表示函数执行的结果，例如：成功、失败或其他状态</p><h1>9. assert函数</h1><p>(1)用法：</p><pre><code class="language-C">#include "assert.h"#include "stdio.h"int main() {    FILE *fp = NULL;    fp = fopen("file.txt", "r");    assert(fp != NULL); //如果文件打开失败，则程序会通过assert断言终止运行    char c = fgetc(fp);    printf("读取字符: %c\n", c);    fclose(fp);    return 0;}</code></pre><p>(2)解释：<br>①<code>assert</code>函数使用时需要调用<code>#include&lt;assert.h&gt;</code>头文件<br>②<code>assert</code>函数是一个调试宏，用于<strong>判断</strong>某个条件<strong>是否成立</strong>；如果条件<strong>不成立</strong>，则输出错误信息并调用<code>abort</code>函数，使程序异常终止；其作用可以在<strong>程序开发</strong>和<strong>调试</strong>过程中帮助我们<strong>快速定位错误</strong>，并且可以<strong>避免</strong>在错误条件下程序继续执行导致更严重的问题<br>③在上面的代码中，如果文件<strong>打开失败</strong>，则<code>fp</code>指向<code>NULL</code>，此时<code>assert(fp != NULL)</code>条件不成立，程序会输出错误信息并终止运行；如果文件成功打开，则会正常读取文件中的字符</p><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>调用系统自带的头文件一般是例如#include&lt;stdio.h&gt;用的尖括号，而如果是调用自己写的头文件一般是用的双引号；上面的代码用的双引号是因为尖括号在代码高亮里显示不出来，暂时无法解决 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章添加脚注和emoji表情的解决方法</title>
      <link href="/CuteFox_Home.github.io/2023/08/14/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%92%8Cemoji%E8%A1%A8%E6%83%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/CuteFox_Home.github.io/2023/08/14/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%92%8Cemoji%E8%A1%A8%E6%83%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>1.脚注</h1><h2 id="1-1用npm安装markdown-it-footnote插件">1.1用npm安装markdown-it-footnote插件</h2><p>打开命令终端(cmd,PowerShell,Git bash等)，输入<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><pre><code class="language-bash">$ npm install markdown-it-footnote --save</code></pre><h2 id="1-2安装bower插件">1.2安装bower插件</h2><pre><code class="language-bash">$ npm install -g bower</code></pre><h2 id="1-3用bower再次安装markdown-it-footnote插件">1.3用bower再次安装markdown-it-footnote插件</h2><pre><code class="language-bash">$ bower install markdown-it-footnote --save</code></pre><h2 id="1-4卸载hexo默认的渲染引擎">1.4卸载hexo默认的渲染引擎</h2><pre><code class="language-bash">$ npm un hexo-renderer-marked --save</code></pre><h2 id="1-5替换其渲染引擎为hexo-renderer-markdown-it">1.5替换其渲染引擎为hexo-renderer-markdown-it</h2><pre><code class="language-bash">$ npm i hexo-renderer-markdown-it --save</code></pre><h2 id="1-6配置并启用markdown-it-footnote插件">1.6配置并启用markdown-it-footnote插件</h2><p>打开在 hexo网站文件 <em>根目录</em> 下的 <em>_config.yml</em> 文件，在里面手动添加</p><pre><code class="language-yml">markdown:  plugins:    - markdown-it-footnote</code></pre><h1>2.emoji表情</h1><h2 id="2-1安装hexo-filter-emoji插件">2.1安装hexo-filter-emoji插件</h2><p>打开命令终端(cmd,PowerShell,Git bash等)，输入</p><pre><code class="language-bash">$ npm install hexo-filter-emoji</code></pre><h2 id="2-2配置并启用hexo-filter-emoji插件">2.2配置并启用hexo-filter-emoji插件</h2><p>打开在hexo网站文件 <em>根目录</em> 下的 <em>_config.yml</em> 文件，在里面手动添加</p><pre><code class="language-yml"># hexo-filter-emojiemoji:  enable: true  className: github-emoji  styles:  customEmojis:</code></pre><h2 id="2-3emoji表情使用方法">2.3emoji表情使用方法</h2><p>打开<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a>网站，选择自己想要的<em>emoji表情</em>，单击即可复制😋</p><blockquote><p>脚注参考:<a href="https://stydxm.com/2022/09/23/hexo-footnote/">https://stydxm.com/2022/09/23/hexo-footnote/</a><br>emoji表情参考:<a href="https://lamirs.vercel.app/hexo-%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8emoji/">https://lamirs.vercel.app/hexo-配置使用emoji/</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>$符号多数情况下不参与命令，一般是终端自带的 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 脚注 </tag>
            
            <tag> emoji表情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用虚拟机软件安装Linux系统</title>
      <link href="/CuteFox_Home.github.io/2023/08/12/%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/CuteFox_Home.github.io/2023/08/12/%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>1.下载Linux发行版 <em>.iso</em>文件</h1><ul><li><a href="https://ubuntu.com/download/desktop">Ubuntu</a></li><li><a href="https://www.opensuse.org/">openSUSE</a></li><li><a href="https://www.centos.org/download/">CentOS</a></li><li><a href="https://archlinux.org/download/">Arch</a></li><li><a href="https://fedoraproject.org/">Fedora</a></li><li><a href="https://manjaro.org/download/">Manjaro</a></li><li><a href="https://www.debian.org/distrib/">Debian</a></li></ul><hr><h1>2.安装VMware workstation player软件</h1><p>这里下载的是个人免费版<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <a href="https://www.vmware.com/cn/products/workstation-player.html">https://www.vmware.com/cn/products/workstation-player.html</a></p><hr><h1>3.开启虚拟化技术</h1><h2 id="3-1检查是否开启CPU虚拟化">3.1检查是否开启CPU虚拟化</h2><p>同时按住键盘上<em>ESC+SHIFT+CTRL</em>打开任务管理器，选择<em>性能</em>，再找到<em>CPU</em>，在<em>CPU</em>界面下找到虚拟化，查看是否启用。若未启用，则需开启CPU虚拟化。</p><h2 id="3-2开启CPU虚拟化">3.2开启CPU虚拟化</h2><p>在电脑开机时，长按<em>F1、F2、F8或F11</em><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>进入电脑主板<em>Bios</em>，在<em>Bios</em>中找到高级选项，再往下移至<em>Inter Virtual Technol</em>，按回车键<em>ENTER</em>，选择<em>Enable</em>；继续再高级选项下找<em>VT-d</em>，再按回车键<em>ENTER</em>，选择<em>Enable</em>；最后保存并退出，开机。</p><h2 id="3-3开启虚拟机平台">3.3开启虚拟机平台</h2><p>同时按下<em>WIN+R</em>键打开运行窗口，输入<em>OptionalFeatures</em>，打开windows功能,勾选<em>Windows虚拟机监控程序平台</em>和<em>虚拟机平台</em>，最后重启电脑。</p><hr><h1>4.安装Linux系统</h1><p>打开<em>VMware workstation player</em>软件，选择<em>创建新的虚拟机</em>，在<em>安装程序光盘映像文件</em>中选择下载好的Linux发行版的 <em>.iso</em>文件，然后填写虚拟机的名称，以及该Linux系统的用户名和密码，<em>磁盘空间大小</em>一般分配20G，<em>自定义硬件</em>里一般将<em>内存</em>提至1-2G，<em>处理器核数</em>一般用1-2个，配置基本完成后就可以给安装好Linux系统的虚拟机开机了。</p><hr><h1>5.给虚拟机配置网络</h1><h2 id="5-1查看虚拟机IP地址">5.1查看虚拟机IP地址</h2><p>打开装有Linux系统虚拟机的<em>终端</em>，输入命令<code>ifconfig</code>，在<em>ens33</em>那块找到<em>inet</em>，<em>inet</em>后面的一串数字即为该虚拟机的<em>IPv4地址</em>。</p><h2 id="5-2">5.2</h2><p>在Windows系统同时按住<em>Win+R</em>键输入<em>cmd</em>打开<em>cmd终端</em>，在<em>cmd终端</em>中输入<code>ping 192.168...</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>且保证<em>cmd终端</em>中未显示有<em>数据包</em>丢失。</p><hr><blockquote><p>参考资料:<a href="https://kb.vmware.com/s/article/1003944?lang=zh_cn">https://kb.vmware.com/s/article/1003944?lang=zh_cn</a><br>参考视频:<a href="https://www.bilibili.com/video/BV1h94y1k7Jf?vd_source=5015a9256ea5937110eb7b6ee3e408f7">https://www.bilibili.com/video/BV1h94y1k7Jf?vd_source=5015a9256ea5937110eb7b6ee3e408f7</a></p></blockquote><br><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><br><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>若使用Windows10或11的操作系统，则VMware-workstation-player软件版本尽量在16以上，否则虚拟机开机时会一直蓝屏 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>不同电脑进入Bios的方法不同，具体情况请自行查找 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>ping后面的192.168…为虚拟机的IPv4地址 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仅适用于Windows </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo+Github搭建一个自己的博客</title>
      <link href="/CuteFox_Home.github.io/2023/08/05/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/CuteFox_Home.github.io/2023/08/05/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1>1.准备搭建环境</h1><p>(1)安装适用于Windows系统的Git<br><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>若无法下载，则下载并安装淘宝镜像版的Git<br><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">https://registry.npmmirror.com/binary.html?path=git-for-windows/</a></p><p>(2)安装适用于Windows系统的NodeJs环境(建议使用 Node.js 12.0 及以上版本)<br><a href="https://nodejs.org/zh-cn/download">https://nodejs.org/zh-cn/download</a><br>若无法下载，则下载并安装淘宝镜像版的NodeJs<br><a href="https://registry.npmmirror.com/binary.html?path=node/">https://registry.npmmirror.com/binary.html?path=node/</a></p><p>(3)安装适用于Windows系统的VSCode编译器<br><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p><h5 id="注1：若安装淘宝镜像版nodejs，则输入命令时需用cnpm而非npm"><em>注1：若安装淘宝镜像版nodejs，则输入命令时需用cnpm而非<s>npm</s></em></h5><h5 id="注2：在Windows自带的PowerShell里输入node-v和git-version查看NodeJs和Git是否安装成功"><em>注2：在Windows自带的PowerShell里输入<code>node -v</code>和<code>git version</code>查看NodeJs和Git是否安装成功</em></h5><hr><h1>2.获取SSH公钥</h1><p>(1)创建github账号<br><a href="https://github.com/">https://github.com/</a></p><p>(2)获取本地密钥<br>首先打开 <em>Git Bash</em> ，输入<code>cd ~/.ssh</code>，再输入<code>ls</code>，检查是否有 <em>id_</em> 开头的名字，如果没有则可以创建SSH密钥<br>继续使用 <em>Git Bash</em> 输入<code>ssh-keygen -t ed25519 -C "your_email@example.com"</code><br>一般不设置密码，就一直回车 (<em>enter</em>) 直到出现有图案出现<br>然后再次输入<code>ls</code>，复制有以 <em>id_</em> 开头 <em>pub</em> 结尾的名字，输入<code>cat id_...pub</code>，将得到的SSH公钥内容复制下来</p><p>(3)将SSH公钥绑定gitHub<br>进入github个人页面，点击右上角的头像，在弹出界面找到设置一栏，点击设置再找到 <em>SHH and GPG keys</em><br>点击 <em>SHH and GPG keys</em> ，将复制的SSH公钥内容填进下面方框中，再设置公钥名字并保存</p><h5 id="注1：your-email-example-com替换为自己注册github账号所使用的邮箱"><em>注1：your_email@example.com替换为自己注册github账号所使用的邮箱</em></h5><h5 id="注2：id-…pub替换为自己复制的名字"><em>注2：id_…pub替换为自己复制的名字</em></h5><hr><h1>3.安装Hexo</h1><p>(1)安装 <em>Hexo-CLI</em><br>打开 <em>PowerShell</em> 输入<code>npm install -g hexo-cli</code></p><p>(2)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(3)安装Hexo包并创建文件夹 <em>package</em> ( <em>package</em> 为文件夹名可修改)<br>在 <em>PowerShell</em> 中输入<code>hexo init package</code></p><p>(4)进入文件夹 <em>package</em><br>在 PowerShell* 中输入<code>cd package</code></p><p>(5)再次安装一遍，确保所有的包都安装完成<br>在 <em>PowerShell</em> 中输入<code>npm install</code></p><hr><h1>4.创建网站页面并运行服务器</h1><p>(1)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(2)生成静态网页文件<br>在 <em>PowerShell</em> 中输入<code>hexo g</code></p><p>(3)运行本地服务器<br>在 <em>PowerShell</em> 中输入<code>hexo s</code><br>在返回信息中我们可以得到 <a href="https://localhost:4000">https://localhost:4000</a> 这个端口，输入这个端口链接在浏览器中就能看到网页了</p><hr><h1>5.写作</h1><p>(1)新建一篇文章 <em>title</em> ( <em>title</em> 为标题可修改)<br>在 <em>PowerShell</em> 中输入<code>hexo new "title"</code></p><p>(2)再次生成静态网页文件<br>在 <em>PowerShell</em> 中输入<code>hexo g</code></p><p>(3)再次运行本地服务器<br>在 <em>PowerShell</em> 中输入<code>hexo s</code></p><hr><h1>6.部署网页在github上</h1><p>(1)在github上创建新的仓库<br>点击github右上角的 <em>加号(+)</em> ，选择新建存储库，然后输入自己的项目名字，且在名字后面一定要加上<br><em>.github.io</em> 后缀，还有README初始化也要勾上，最后点击创建即可</p><p>(2)获取SSH链接<br>点击刚刚创建的库上的 <em>code</em> ，选择 <em>SSH</em> ，复制 <em>SSH</em> 下面的内容</p><p>(3)安装插件在本地<br>在 <em>PowerShell</em> 中输入<code>npm install hexo-deployer-git --save</code></p><p>(4)检查插件是否安装成功<br>在 <em>PowerShell</em> 中输入<code>npm list hexo-deployer-git</code></p><p>(5)配置 <em>_config.yml</em> 文件<br>进入 <em>package</em> 文件夹，找到 <em>_config.yml</em> 件，选中它用VSCode打开，往下翻并找到<br><em>deploy:</em> 和 <em>type:</em> ，在 <em>type:</em> 后面写上 <em>git</em> ，并换行写上 <em>repo:</em> ，再在 <em>repo:</em> 后面<br>粘贴上复制好的SSH链接并保存</p><p>(6)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(7)将生成的网站部署到github仓库中<br>在 <em>PowerShell</em> 中输入<code>hexo d</code></p><p>(8)改变部署仓库分支<br>打开 <em>_config.yml</em> 文件，在 <em>repo:</em> 下面写上 <em>branch:</em> ，在 <em>branch:</em> 后面写上想要的分支的名字并保存</p><p>(9)再次部署更新内容到github仓库中<br>在 <em>PowerShell</em> 中输入<code>hexo d</code></p><p>(10)用github页面打开网站<br>在gitHub项目仓库页面的搜索栏下面有一个设置，点击设置并其在左下方找到 <em>页面</em> 一栏，点击页面就能看到<br>有 <em><a href="http://github.io">github.io</a></em> 域名的链接，点击链接即可访问我们创建的网站</p><h5 id="注：如果输入hexo-d-遇到错误，则在输入其之前输入git-config-global-credential-helper-wincred"><em>注：如果输入<code>hexo d </code>遇到错误，则在输入其之前输入<code>git config --global credential.helper wincred</code></em></h5><hr><blockquote><p>参考资料:<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a><br><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p></blockquote><blockquote><p>参考视频:<a href="https://www.youtube.com/watch?v=xvIRGmKWpFM">https://www.youtube.com/watch?v=xvIRGmKWpFM</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 仅适用于Windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
