<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/Java%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/Java%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/09/09/C-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/09/09/C-%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.关于#include<iostream></iostream></h1><p><em>C++语言</em>里<code>#include&lt;iostream&gt;</code>用于<em>引入标准输入输出流</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>即<code>cin(输入)</code>和<code>cout(输出)</code>，例如：</p><pre><code class="language-C++">#include"iostream"using namespace std;int main(){    int j; //声明整数j                                               cin &lt;&lt; j; //从键盘输入一个整数作为j的值                int i=1; //声明整数i的值为1    cout &lt;&lt; "输出的内容" &lt;&lt; i &lt;&lt; endl; //输出i的值}</code></pre><p>而<code>std::cout</code>与<code>cout</code>的区别是：<br><code>std</code>是一个<em>命名空间（namespace）</em>，<code>::</code>是<em>作用域</em>运算符，<code>cout</code>是<em>std空间</em>中的一个<em>函数名</em>，所以使用<code>cout</code>时，<strong>必须</strong>有使用std命名空间的说明<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，有两种说明方式（<code>cin</code>同理），如下：<br>①方式一：每次使用时都对cout说明</p><pre><code class="language-C++">#include"iostream"int main(){    std::cout&lt;&lt;"Input two numbers:";}</code></pre><p>②方式二：在主函数前说明一下，后面就可以直接使用cout</p><pre><code class="language-C++">#include"iostream"using namespace std;int main(){    cout &lt;&lt; "Input two numbers:";}</code></pre><h1>2.关于#pragma once</h1><p><em>C++语言</em>里<code>#pragma once</code>是用于<em>预编译</em>，为了<em>避免</em> <strong>同一个头文件</strong>被<code>include</code>多次，这里所说的<strong>同一个文件</strong>是指<strong>物理上</strong>的<em>一个文件</em>，而不是指<strong>内容相同</strong>的<em>两个文件</em></p><h1>3.关于#include<cstdlib></cstdlib></h1><p><em>C++语言</em>里<code>#include&lt;cstdlib&gt;</code>相当于<em>C语言</em>中<code>#include&lt;stdlib.h&gt;</code>的增强版，它包含了<em>C标准库的通用工具函数</em>，如<code>malloc</code>和<code>free</code>函数等</p><h1>4. nullptr关键字</h1><p>①在<em>C++11</em>之前，通常使用<code>0</code>或<code>NULL</code>来表示<strong>指针为空</strong>；在<em>C++11</em>中，引入了<code>nullptr</code><em>关键字</em>，它被定义为<code>std::nullptr_t</code><em>数据类型</em>的字面值<em>常量</em>，用于表示<strong>空指针</strong><br>②<em>C++11</em>中，初始化指针变量时，可以将其初始化为<code>nullptr</code>，如：<code>int *p = nullptr</code>，这种方式可以避免由于误解空指针的含义而导致的错误<br>③在<em>C++11</em>之后，<strong>不推荐</strong>使用<code>0</code>或<code>NULL</code>来表示<strong>空指针</strong>，因为它们在语义上<strong>不够明确</strong>，容易产生歧义；此外，对于<em>整型变量和指针类型变量</em> <strong>混用时</strong>，可能会导致一些问题<br>④由于<code>nullptr</code>是一个<strong>关键字</strong>，在进行初始化时<strong>不能</strong>将其改成其他字符，否则将会导致编译错误</p><h1>5. new关键字</h1><p>①<code>new</code>是<em>C++语言</em>中的一个<strong>关键字</strong>，用于在<strong>堆区</strong> <em>动态分配内存</em>并<em>返回其地址（即指针）</em>，可以使用<code>new</code>关键字<em>实例化一个类对象</em>、*分配一个数组或在堆区中动态分配内存等<br>②对于<strong>基本数据类型</strong>，使用<code>new</code>时可以<strong>指定初值</strong>，例如：</p><pre><code class="language-C++">int *p = new int(10);  // 分配4个字节的内存，初始化为10，返回指向该内存的指针</code></pre><p>③对于<strong>自定义类型</strong>，需要通过<strong>构造函数</strong>来初始化对象，例如：</p><pre><code class="language-C++">class MyClass {public:    MyClass() { cout &lt;&lt; "MyClass Constructor" &lt;&lt; endl; }};MyClass *obj = new MyClass();  // 动态分配内存并调用构造函数，返回指向该对象的指针</code></pre><p>④需要注意的是，在使用<code>new</code>关键字<strong>动态分配内存</strong>时，如果程序出现<strong>异常终止</strong>，可能会导致<strong>内存泄漏</strong>，所以在<strong>动态分配内存</strong>后应<strong>必须手动</strong>使用<code>delete</code>关键字<strong>释放内存</strong>，或使用<strong>智能指针</strong>等方式来<strong>自动管理内存</strong></p><h1>6.析构方法</h1><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>C++的I/O发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>用于避免导致全局命名冲突问题 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo页脚插入网站运行时间和不蒜子统计</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E9%A1%B5%E8%84%9A%E6%8F%92%E5%85%A5%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E9%A1%B5%E8%84%9A%E6%8F%92%E5%85%A5%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8C%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.网站页脚插入网站运行时间</h1><p>找到博客主题文件夹对应的页脚渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>footer.ejs</code>文件，把下面代码插入到<code>&lt;/footer&gt;</code>之前，然后在<code>var grt= new Date("08/10/2020 00:00:00")</code>把<code>08/10/2020 00:00:00</code>修改为自己的建站时间</p><pre><code>&lt;div&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt;    var now = new Date();     function createtime() {         var grt= new Date("08/10/2020 00:00:00");//在此处修改你的建站时间        now.setTime(now.getTime()+250);         days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);         hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);         if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);         mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}         seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);         snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}         document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 ";         document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";     } setInterval("createtime()",250);&lt;/script&gt;&lt;/div&gt;</code></pre><h1>2.不蒜子脚本使用</h1><p>找到博客主题文件夹对应的页脚渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>footer.ejs</code>文件，把下面代码插入到<code>&lt;/footer&gt;</code>之前；然后<code>&lt;script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</code>这行代码里<code>src=""</code>后面要填的就是不蒜子<strong>最新的</strong>脚本域名，可以在不蒜子官方网址查询</p><pre><code>&lt;div class="busuanzi-count"&gt;    &lt;script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;    &lt;span class="site-uv"&gt;      &lt;i class="fa fa-user"&gt;&lt;/i&gt;      访问量 &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 次      &lt;span class="post-meta-divider"&gt; | &lt;/span&gt;    &lt;/span&gt;    &lt;span class="site-uv"&gt;      &lt;i class="fa fa-eye"&gt;&lt;/i&gt;      总访客 &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 人    &lt;/span&gt;&lt;/div&gt;</code></pre><blockquote><p>不蒜子官方网址:<a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a><br>参考文章1:<a href="https://blog.csdn.net/qq_39720594/article/details/105411030">https://blog.csdn.net/qq_39720594/article/details/105411030</a><br>参考文章2:<a href="https://blog.csdn.net/wangqingchuan92/article/details/126346205">https://blog.csdn.net/wangqingchuan92/article/details/126346205</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 网站运行时间统计 </tag>
            
            <tag> 访问量统计 </tag>
            
            <tag> 总访客数统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插入彩色滚动文字</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E6%8F%92%E5%85%A5%E5%BD%A9%E8%89%B2%E6%BB%9A%E5%8A%A8%E6%96%87%E5%AD%97/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E6%8F%92%E5%85%A5%E5%BD%A9%E8%89%B2%E6%BB%9A%E5%8A%A8%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>一段代码搞定</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前，也可以是其他位置；其中<code>var l = " Hi. "</code>的<code>Hi.</code>，<code>return r + "."</code>里的<code>.</code>，还有<code>o = []</code>中<code>[]</code>里的文字都可以自行修改</p><pre><code>&lt;p style="text-align:center" id="saintwei"&gt;&lt;/p&gt;&lt;script&gt;   var saintwei = function (r) {       function t() {           return b[Math.floor(Math.random() * b.length)]       }       function e() {           return String.fromCharCode(94 * Math.random() + 33)       }       function n(r) {           for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) {               var l = document.createElement("span");               l.textContent = e(), l.style.color = t(), n.appendChild(l)           }           return n       }       function i() {           var t = o[c.skillI];           c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)       }       var l = " Hi. ",           o = ["Welcome to my blog", "世界本就如此艰难，何必还要让它更艰难呢", "你若盛开，蝴蝶自来；你若精彩，天自安排", "Are You OK", "转身变成一只猫"].map(function (r) {               return r + "."           }),           a = 2,           g = 1,           s = 5,           d = 75,           b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],           c = {               text: "",               prefixP: -s,               skillI: 0,               skillP: 0,               direction: "forward",               delay: a,               step: g           };       i()   };   saintwei(document.getElementById('saintwei'));&lt;/script&gt;</code></pre><blockquote><p>参考文章:<a href="https://blog.csdn.net/qq_25896347/article/details/117968673">https://blog.csdn.net/qq_25896347/article/details/117968673</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 彩色滚动文字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo标题搞怪特效</title>
      <link href="/CuteFox_Home.github.io/2023/09/03/Hexo%E6%A0%87%E9%A2%98%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88/"/>
      <url>/CuteFox_Home.github.io/2023/09/03/Hexo%E6%A0%87%E9%A2%98%E6%90%9E%E6%80%AA%E7%89%B9%E6%95%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.直接法（已成功）</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前；其中离开本网站和回到本网站的<strong>表情和中文</strong>可以自行更改</p><pre><code>&lt;script type="text/javascript"&gt;    var OriginTitile=document.title,st;document.addEventListener("visibilitychange",function(){        document.hidden?(document.title="o(இ௰இ)怎么就走了！",clearTimeout(st)):(document.title="☆*o(≧▽≦)o*☆欢迎回来！",st=setTimeout(function(){document.title=OriginTitile},3e3))    })&lt;/script&gt;</code></pre><h1>2.借用法（未实践）</h1><p>找到博客主题文件夹对应的渲染文件，例如我用的<em>Particlex</em>主题就是在<code>\themes\particlex\layout</code>这个文件夹里面，再找到<code>layout.ejs</code>文件，把下面代码插入到<code>&lt;/body&gt;</code>之前；目的是借用别人写好的<code>js</code>文件链接，但不能修改里面的<strong>表情和中文</strong>，且这个链接的存在和消亡取决于发这个链接的作者o(≧口≦)o</p><pre><code>&lt;script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.2.5/source/js/FunnyTitle.js"&gt;&lt;/script&gt;</code></pre><blockquote><p>参考资料:<a href="https://blog.csdn.net/victoryxa/article/details/105841309/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8--blog-86065141.235%5Ev38%5Epc_relevant_sort&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11">https://blog.csdn.net/victoryxa/article/details/105841309/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8--blog-86065141.235^v38^pc_relevant_sort&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 标题搞怪特效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Aplayer插件在Hexo上插入音乐</title>
      <link href="/CuteFox_Home.github.io/2023/08/30/%E7%94%A8Aplayer%E6%8F%92%E4%BB%B6%E5%9C%A8Hexo%E4%B8%8A%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/"/>
      <url>/CuteFox_Home.github.io/2023/08/30/%E7%94%A8Aplayer%E6%8F%92%E4%BB%B6%E5%9C%A8Hexo%E4%B8%8A%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.安装hexo-tag-aplayer插件</h1><pre><code class="language-bash">$ npm install --save hexo-tag-aplayer</code></pre><h2 id="2-使用">2.使用</h2><h3 id="2-1-Aplayer播放器基本格式">2.1 Aplayer播放器基本格式</h3><p>在每篇文章即<code>.md</code>文件中的正文中添加如下内容：</p><pre><code class="language-md">{% aplayer title author music-url [picture-url, lrc:lrc-url, width:xx%, autoplay, narrow] %}</code></pre><p>但如果无法直接在标签参数中加入空格，则直接将参数用<strong>双引号</strong>括起来使用，如下：</p><pre><code class="language-md">{% aplayer "title" "author" "music-url" "picture-url" "lrc:lrc-url" "width:xx%" "autoplay" "narrow" %}</code></pre><p>其中，<code>{% aplayer %}</code>是<strong>必须</strong>写上的格式，其他<strong>标签参数</strong>具体如下：</p><ul><li><code>title</code>：歌曲的标题（必选）</li><li><code>author</code>：歌曲的作者（必选）</li><li><code>music-url</code>：歌曲本体的URL地址（必选）</li><li><code>picture-url</code>：歌曲封面的URL地址（可选）</li><li><code>lrc-url</code>：歌词的URL地址（可选）</li><li><code>width:xx%</code>：宽度（可选，默认100%）</li><li><code>autoplay</code>：自动播放（可选，移动端暂不支持）</li><li><code>narrow</code>：袖珍风格播放器（可选）<br>若在网站根目录下的<code>config.yml</code>文件中将<code>post_asset_folder</code>设为<code>true</code>，即开启了Hexo的文章资源文件夹功能，则可以将歌曲本体、歌曲封面、歌词放入<strong>与文章同名</strong>的对应的资源文件夹中，然后直接引用，如下：</li></ul><pre><code class="language-md">{% aplayer "Running In The Dark" "MONKEY MAJIK" "Running In The Dark.mp3" "Running In The Dark.jpg" "lrc:Running In The Dark.txt" %}</code></pre><p>效果如下<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found (Running In The Dark.jpg)");</script><p>除了单曲，还支持列表模式，具体可参照<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8">播放列表</a></p><h3 id="2-2-MeingJS播放器">2.2 MeingJS播放器</h3><p>介绍：MetingJS是基于Meting API的APlayer衍生播放器<br>功能：将支持对于QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放<br>①在网站根目录下的<code>config.yml</code>文件中添加如下：</p><pre><code class="language-yml">aplayer:  meting: true</code></pre><p>②在每篇文章即<code>.md</code>文件中的正文中添加如下内容：</p><pre><code class="language-md">{% meting "2068111443" "netease" "song" "theme:#7777" "mutex:true" "listmaxheight:340px" "preload:auto" %}</code></pre><p>效果如下：</p>    <div id="aplayer-iUhbRjeO" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2068111443" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#7777"></div><p>其中，<code>{% meting %}</code>是<strong>必须</strong>写上的格式，其他<strong>标签参数</strong>具体如下：</p><ul><li><code>2068111443</code>是歌曲ID（必选），如网易云音乐分享歌曲链接的时<code>https://music.163.com/song?id=2068111443&amp;userid=</code>中<code>2068111443</code>就是该歌曲的ID</li><li><code>netease</code>是网易云音乐平台（必选），也可以换成其他音乐平台如：<code>tencent</code>，<code>kugou</code>，<code>xiami</code>，<code>baidu</code>等</li><li><code>song</code>是歌曲的类型（必选），单曲是<code>song</code>，歌单是<code>playlist</code>(效果可以参考我的<a href="https://drphilip425.github.io/CuteFox_Home.github.io/about/">About</a>)，专辑是<code>album</code>，还有<code>search</code>和<code>artist</code></li><li><code>theme:#7777</code>是播放器主题色（可选），具体喜欢的RGB颜色请自行查找并更改</li><li><code>mutex:true</code>意思是选择<code>true</code>时，如果<strong>同页面</strong>有其他aplayer播放，<strong>该播放器</strong>会暂停</li><li><code>listmaxheight:340px</code>意思是播放列表的最大长度默认为<code>340px</code></li><li><code>preload:auto</code>意思是音乐文件预载入模式为<code>auto</code>，可以改为<code>none</code>或<code>metadata</code><br>更多标签参数请看<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#meingjs-%E6%94%AF%E6%8C%81-30-%E6%96%B0%E5%8A%9F%E8%83%BD">选项列表</a></li></ul><p>③非post（正文）页面使用问题<br>如果在非post（正文）页面中无法使用Aplayer播放器，可以试试在<code>.md</code>文件添加<code>{% aplayer %}</code>或<code>{% meting %}</code>之前添加如下内容：</p><pre><code>&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"&gt;&lt;/script&gt;</code></pre><blockquote><p>hexo-tag-aplayer官方中文文档:<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md</a><br>参考文章:<a href="https://blog.csdn.net/hushhw/article/details/88092728">https://blog.csdn.net/hushhw/article/details/88092728</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>不知道是不是主题原因，我用F12查看发现我的歌曲本体和歌词都没成功上传，暂时没得到解决 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Aplayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言知识总结</title>
      <link href="/CuteFox_Home.github.io/2023/08/26/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/CuteFox_Home.github.io/2023/08/26/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.基本格式</h1><pre><code class="language-C">#include "stdio.h"...//函数体int main(){ ...//主函数}</code></pre><h2 id="1-1简单实例">1.1简单实例</h2><pre><code class="language-C">#include "stdio.h"void prinHello(){    printf("Hello World!");}int main(){    prinHello();    return 0;}</code></pre><h2 id="1-2具体讲解">1.2具体讲解</h2><p>(1)<code>#include</code>意思为<strong>导入</strong>，<code>stdio</code>为<strong>标准输入和输出</strong>，而<code>.h</code>为<strong>头文件</strong>，所以<code>#include"stdio.h"</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的意思是<strong>导入一个标准输入和输出的头文件</strong>，这个<strong>头文件</strong>通常是<strong>系统自带的库里的文件</strong>，而导入的<strong>头文件不同</strong>，能使用该文件里的<strong>函数就不同</strong></p><p>(2)①在<strong>函数体</strong>中<code>void</code>表示<strong>没有返回值</strong>，如需有返回值则将<code>void</code>改为<strong>具体的返回值类型</strong>，且在<code>{}</code>写上<code>retrun 返回值</code>；<br>②<code>prinHello</code>为<strong>函数名</strong>，函数名<strong>只能</strong>用<em>字母、下划线、数字表示</em>，<strong>不能</strong>使用<s>关键字</s>，且<strong>必须</strong>以<em>字母或下划线</em>开头，<strong>不能</strong>以<s>数字</s>开头；<br>③<code>()</code>里可以写形式参数（简称“形参”），形参用<code>数据类型 声明的变量</code>表示，也可以不添加形参表示<strong>空参</strong>，但在调用空参函数时还是需要<strong>在函数名后面</strong>加上<code>()</code>；<br>④<strong>函数具体内容</strong>写在<code>{}</code>里面，可以一个<code>{}</code>内嵌入许多<code>{}</code>，每一个语句写完都要用<code>;</code>隔开；<br>⑤<code>printf()</code>是<strong>系统自带的函数</strong>，表示把输入的内容<strong>打印</strong>在输出窗口，调用时在<code>printf</code>的<code>()</code>里添加<code>""</code>，并在<code>""</code>里输入想要打印的内容即可</p><p>(3)①<code>int main()</code>是<strong>主函数的入口</strong>，其<code>{}</code>写入<strong>主函数执行语句</strong>，因为C语言<strong>从上到下</strong>编译的特性，普通函数<strong>只能</strong>写在主函数<strong>上面</strong>，且主函数<strong>只有</strong>一个；<br>②<code>prinHello()</code>是一个<strong>调用</strong>上面已经写好的<strong>函数</strong>的语句；<code>return 0</code>表示<strong>返回值为0</strong>，即退出程序</p><h1>2.数据类型与格式符</h1><p>(1)数据类型与它的格式符<strong>一一对应</strong>，数据类型声明变量，格式符放在输入输出语句中<br>(2)常见的有:int–%d，double–%lf，float–%f，char–%c，long–%ld，short–%hd，unsigned int–%u …</p><h1>3.输出对齐与保留小数位数</h1><p>如<code>print("%10.2lf",a)</code>中<code>10</code>表示<strong>向右对齐</strong>10个位置，同理<code>-10</code>表示<strong>向左对齐</strong>10个位置，而<code>.2</code>表示<strong>保留小数后2位</strong></p><h1>4.非格式化输入和输出</h1><h2 id="4-1-gets-输入与puts-输出">4.1 gets()输入与puts()输出</h2><h3 id="4-1-1-gets-输入">4.1.1 gets()输入</h3><p>(1)用法：</p><pre><code class="language-C">int main(){ char arr[10],*s; //声明一个字符数组变量，即字符串和一个字符串指针 gets(arr); //从键盘上输入字符串，直到回车结束   gets(s); //从键盘上输入字符串，直到回车结束}</code></pre><p>(2)特点：<br>①<code>gets()</code>是从<em>键盘输入字符串</em> <strong>开始</strong>到<em>按下回车</em> <strong>结束</strong>，其中直到<em>回车</em>前<strong>有空格也行</strong>，且<em>回车</em> <strong>不包含</strong>在字符串内<br>②<code>gets(arr)</code>其中<code>arr</code>可以是<strong>字符串数组名</strong>，也可以是<strong>字符串指针</strong>，如果不是<em>字符串</em>而是<em>单个字符</em>，则<strong>编译</strong>可能不报错，<strong>但</strong> <strong>运行</strong>会报错</p><h3 id="4-1-2-puts-输出">4.1.2 puts()输出</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char arr[]="Hello World!"; //声明一个字符串arr并给该字符串赋值    puts(arr); //输出arr内容到屏幕    char* s; //声明一个字符串指针s    s="Hi! World"; //给s赋值    puts(s); //输出s指向的内容到屏幕    puts("Hello China!"); //直接输出括号里的内容}</code></pre><p>(2)特点：<br>①输出完字符串后会<strong>自动换行</strong><br>②<strong>只能</strong>输出<em>字符串</em>，<strong>不能</strong>输出<em>运算结果</em><br>③可以<strong>直接</strong>在<code>puts()</code>里写入要输出的字符串</p><h2 id="4-2-getchar-输入与putchar-输出">4.2 getchar()输入与putchar()输出</h2><h3 id="4-2-1-getchar-输入">4.2.1 getchar()输入</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char a; //声明一个单个字符变量a    a=getchar(); //从键盘上读取输入的单个字符赋值给a}</code></pre><p>(2)特点：<br>①无论从键盘上输入多少个字符，<code>getchar()</code>只读取输入的<strong>第一个字符</strong>作为返回值<br>②从<em>键盘输入字符</em> <strong>开始</strong>到<em>按下回车</em> 才<strong>结束</strong></p><p>(3)解释：<br><code>getchar()</code>是<code>stdio.h</code>中的<em>库函数</em>，它的作用是从<code>stdio</code>流中读入<strong>一个字符</strong>；键盘输入字符是<em>先存入缓冲区</em>，当你<em>按下回车</em>时，<code>getchar</code>就会<em>进入缓冲区</em>读取字符，<em>一次</em>只读取<em>第一个字符</em>，我们输入的一串字符被读出来是<code>getchar</code><em>循环读取</em>的结果，而<em>回车键</em>取代了我们输入的<em>第一个字符</em>，我们输入<code>getchar()</code>来<em>清除回车键</em>，达到从<em>第一个字符开始读起</em>的目的</p><h3 id="4-2-2-putchar-输出">4.2.2 putchar()输出</h3><p>(1)用法：</p><pre><code class="language-C">int main(){    char a; //声明单个字符变量a    a='A'; //把a赋值为A    putchar(a); //输出A    putchar(0x41); //因为A在ASCII码中十六进制为0x41，所以输出A    putchar('\x41'); //因为'\x41'就相当于十六进制的0x41，所以也输出A}</code></pre><p>(2)特点：<br>①向标准输出设备<strong>只</strong>输出<strong>一个字符</strong><br>②相当于<code>printf("%c",a)</code></p><h1>5.内存分配与释放函数</h1><h2 id="5-1-malloc函数分配动态内存地址">5.1 malloc函数分配动态内存地址</h2><p>(1)用法：</p><pre><code class="language-C">#include"stdlib.h"#include"stdio.h"int main(){    int* n; //声明一个整数型指针变量n    n = (int*) malloc(2*sizeof(int)); //为变量n分配动态内存空间    *n = 5; //把5这个值转成二进制存放在变量n的内存空间里    printf("变量n地址为: %d\n", n);    printf("变量n的值为: %d\n", *n);    return 0;    }</code></pre><p>(2)解释：<br>①使用<code>malloc</code>函数<em>分配动态内存空间</em>时要先引入<code>#include&lt;stdlib.h&gt;</code>头文件<br>②<code>malloc</code>函数的<em>函数原型</em>为<code>void* malloc(unsigned int size)</code>，它根据<em>参数</em>指定的尺寸来分配内存空间，且返回一个<code>void</code>型指针，指向新分配的内空间的<em>初始地址</em>；但如果内存分配失败（内存不足），则函数返回<code>NULL</code><br>③<code>n=(int*)malloc(2*sizeof(int))</code>这段代码中，<code>sizeof(int)</code>是分配一个整数类型所占用的字节数的内存空间，通常为4个字节，所以<code>malloc(2*sizeof(int))</code>表示分配一个大小为<code>2*sizeof(int)</code>字节的内存空间，即分配了8个字节大小的内存空间<br>④<code>n=(int*)malloc(2*sizeof(int))</code>这段代码中，<code>(int*)malloc</code>这样写的原因是<code>malloc</code>函数原本返回的是一个<code>void*</code>类型的指针，但指针变量<code>n</code>是<code>int*</code>型的，所以需要将其<em>强制转换</em>为<code>int*</code>类型，才能够将其赋值给一个<code>int*</code>型即<strong>整型指针变量</strong></p><h2 id="5-2-free函数释放动态分配的内存">5.2 free函数释放动态分配的内存</h2><p>(1)用法：</p><pre><code class="language-C">#include"stdlib.h"#include"stdio.h"int main(){    int* n; //声明一个整数型指针变量n    n = (int*) malloc(2*sizeof(int)); //为变量n分配动态内存空间    *n = 5; //把5这个值转成二进制存放在变量n的内存空间里    printf("变量n地址为: %d\n", n);    printf("变量n的值为: %d\n", *n);    free(n); //释放变量n分配的动态内存    return 0;    }</code></pre><p>(2)解释：<br>①使用<code>free</code>函数<em>释放动态分配的内存</em>时要先引入<code>#include&lt;stdlib.h&gt;</code>头文件<br>②用<code>free</code>函数去释放<strong>要释放的内存的指针</strong>为<code>NULL</code>时，则无事发生；但<strong>释放内存后的指针</strong>不能再<code>free</code>一次，否则会导致程序崩溃或者出现错误<br>③只有使用<code>malloc</code>、<code>calloc</code>、<code>realloc</code>等函数动态分配的内存，才能用<code>free()</code>函数进行释放<br>④<code>free</code>函数的函数原型为<code>void free(void* memblock)</code>，其中<code>memblock</code>参数是一个指针，指向要释放的内存空间，以避免内存泄漏；但<code>memblock</code>指针本身并不会消失，所以一般可以使用<code>free</code>函数后，<code>memblock=NULL</code>使<code>memblock</code>指针变为空指针</p><h1>6. enum枚举类型</h1><p>(1)用法：</p><pre><code class="language-C">#include "stdio.h"enum Weekday { //定义枚举类    Monday,    Tuesday,    Wednesday,    Thursday,    Friday,    Saturday,    Sunday};int main() {    enum Weekday today = Wednesday; //声明enum Weekday类型的today并用Wednesday赋值    printf("今天是星期%d\n", today + 1);    return 0;}</code></pre><p>(2)解释：<br>①枚举类型使用<code>enum</code>关键字进行定义<br>②枚举类型中的常量<em>默认从0开始递增</em>，所以上面的例子中，<code>Monday</code>的值为<code>0</code>，<code>Tuesday</code>的值为<code>1</code>，以此类推<br>③如果需要改变枚举类型中常量的值，可以在定义枚举类型时<em>显式指定</em>常量的值，如<code>Monday = 1</code></p><h1>7. typedef自定义类型与struct结构体</h1><p>(1)用法：</p><pre><code class="language-C">typedef struct Book{ //新的数据类型为struct Bookchar no[20];//ISBNchar name[20];//名字float price;//价格}novel; //别名为novelstruct Book{ //新的数据类型为struct Book   char no[20];//ISBN   char name[20];//名字   float price;//价格};</code></pre><p>(2)解释：<br>①结构体<code>struct</code>用于<strong>定义</strong>一个<strong>新的数据类型</strong>，这个<strong>新的数据类型</strong>可以由<strong>任意的基本数据类型</strong>构成，如<code>int</code>、<code>char</code>、<code>float</code>等<br>②自定义类型<code>typedef</code>一般和结构体<code>struct</code>一起用，只不过在<code>typedef struct Book{};</code>的<code>;</code>前多了一个可以<strong>添加别名</strong>的位置，如上面的<code>novel</code>，这个<strong>别名</strong>用于充当<strong>新的数据类型</strong><code>struct Book</code>来声明变量</p><h1>8. Status用法</h1><p>(1)用法：</p><pre><code class="language-C">#include "stdio.h"typedef enum { //自定义枚举类型    SUCCESS, //成功    ERROR //失败} Status; //别名为StatusStatus foo() { //Status类型的foo函数    return SUCCESS;// 函数逻辑}int main() {    Status result = foo(); //声明一个Status类型的result，用同样Status类型的foo函数赋值    if (result == SUCCESS) {        printf("函数执行成功\n");    } else {        printf("函数执行失败\n");    }    return 0;}</code></pre><p>(2)解释：<br>Status通常是一个自定义的类型（<code>typedef</code>），用于表示函数的返回状态；它通常被定义为一个枚举类型（<code>enum</code>）或整型类型（<code>int</code>），用来表示函数执行的结果，例如：成功、失败或其他状态</p><h1>9. assert函数</h1><p>(1)用法：</p><pre><code class="language-C">#include "assert.h"#include "stdio.h"int main() {    FILE *fp = NULL;    fp = fopen("file.txt", "r");    assert(fp != NULL); //如果文件打开失败，则程序会通过assert断言终止运行    char c = fgetc(fp);    printf("读取字符: %c\n", c);    fclose(fp);    return 0;}</code></pre><p>(2)解释：<br>①<code>assert</code>函数使用时需要调用<code>#include&lt;assert.h&gt;</code>头文件<br>②<code>assert</code>函数是一个调试宏，用于<strong>判断</strong>某个条件<strong>是否成立</strong>；如果条件<strong>不成立</strong>，则输出错误信息并调用<code>abort</code>函数，使程序异常终止；其作用可以在<strong>程序开发</strong>和<strong>调试</strong>过程中帮助我们<strong>快速定位错误</strong>，并且可以<strong>避免</strong>在错误条件下程序继续执行导致更严重的问题<br>③在上面的代码中，如果文件<strong>打开失败</strong>，则<code>fp</code>指向<code>NULL</code>，此时<code>assert(fp != NULL)</code>条件不成立，程序会输出错误信息并终止运行；如果文件成功打开，则会正常读取文件中的字符</p><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>调用系统自带的头文件一般是例如#include&lt;stdio.h&gt;用的尖括号，而如果是调用自己写的头文件一般是用的双引号；上面的代码用的双引号是因为尖括号在代码高亮里显示不出来，暂时无法解决 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章添加脚注和emoji表情的解决方法</title>
      <link href="/CuteFox_Home.github.io/2023/08/14/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%92%8Cemoji%E8%A1%A8%E6%83%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/CuteFox_Home.github.io/2023/08/14/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%B3%A8%E5%92%8Cemoji%E8%A1%A8%E6%83%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.脚注</h1><h2 id="1-1用npm安装markdown-it-footnote插件">1.1用npm安装markdown-it-footnote插件</h2><p>打开命令终端(cmd,PowerShell,Git bash等)，输入<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><pre><code class="language-bash">$ npm install markdown-it-footnote --save</code></pre><h2 id="1-2安装bower插件">1.2安装bower插件</h2><pre><code class="language-bash">$ npm install -g bower</code></pre><h2 id="1-3用bower再次安装markdown-it-footnote插件">1.3用bower再次安装markdown-it-footnote插件</h2><pre><code class="language-bash">$ bower install markdown-it-footnote --save</code></pre><h2 id="1-4卸载hexo默认的渲染引擎">1.4卸载hexo默认的渲染引擎</h2><pre><code class="language-bash">$ npm un hexo-renderer-marked --save</code></pre><h2 id="1-5替换其渲染引擎为hexo-renderer-markdown-it">1.5替换其渲染引擎为hexo-renderer-markdown-it</h2><pre><code class="language-bash">$ npm i hexo-renderer-markdown-it --save</code></pre><h2 id="1-6配置并启用markdown-it-footnote插件">1.6配置并启用markdown-it-footnote插件</h2><p>打开在 hexo网站文件 <em>根目录</em> 下的 <em>_config.yml</em> 文件，在里面手动添加</p><pre><code class="language-yml">markdown:  plugins:    - markdown-it-footnote</code></pre><h1>2.emoji表情</h1><h2 id="2-1安装hexo-filter-emoji插件">2.1安装hexo-filter-emoji插件</h2><p>打开命令终端(cmd,PowerShell,Git bash等)，输入</p><pre><code class="language-bash">$ npm install hexo-filter-emoji</code></pre><h2 id="2-2配置并启用hexo-filter-emoji插件">2.2配置并启用hexo-filter-emoji插件</h2><p>打开在hexo网站文件 <em>根目录</em> 下的 <em>_config.yml</em> 文件，在里面手动添加</p><pre><code class="language-yml"># hexo-filter-emojiemoji:  enable: true  className: github-emoji  styles:  customEmojis:</code></pre><h2 id="2-3emoji表情使用方法">2.3emoji表情使用方法</h2><p>打开<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji Cheat Sheet</a>网站，选择自己想要的<em>emoji表情</em>，单击即可复制😋</p><blockquote><p>脚注参考:<a href="https://stydxm.com/2022/09/23/hexo-footnote/">https://stydxm.com/2022/09/23/hexo-footnote/</a><br>emoji表情参考:<a href="https://lamirs.vercel.app/hexo-%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8emoji/">https://lamirs.vercel.app/hexo-配置使用emoji/</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>$符号多数情况下不参与命令，一般是终端自带的 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> 痛点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 脚注 </tag>
            
            <tag> emoji表情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用虚拟机软件安装Linux系统</title>
      <link href="/CuteFox_Home.github.io/2023/08/12/%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/CuteFox_Home.github.io/2023/08/12/%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85Linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.下载Linux发行版 <em>.iso</em>文件</h1><ul><li><a href="https://ubuntu.com/download/desktop">Ubuntu</a></li><li><a href="https://www.opensuse.org/">openSUSE</a></li><li><a href="https://www.centos.org/download/">CentOS</a></li><li><a href="https://archlinux.org/download/">Arch</a></li><li><a href="https://fedoraproject.org/">Fedora</a></li><li><a href="https://manjaro.org/download/">Manjaro</a></li><li><a href="https://www.debian.org/distrib/">Debian</a></li></ul><hr><h1>2.安装VMware workstation player软件</h1><p>这里下载的是个人免费版<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> <a href="https://www.vmware.com/cn/products/workstation-player.html">https://www.vmware.com/cn/products/workstation-player.html</a></p><hr><h1>3.开启虚拟化技术</h1><h2 id="3-1检查是否开启CPU虚拟化">3.1检查是否开启CPU虚拟化</h2><p>同时按住键盘上<em>ESC+SHIFT+CTRL</em>打开任务管理器，选择<em>性能</em>，再找到<em>CPU</em>，在<em>CPU</em>界面下找到虚拟化，查看是否启用。若未启用，则需开启CPU虚拟化。</p><h2 id="3-2开启CPU虚拟化">3.2开启CPU虚拟化</h2><p>在电脑开机时，长按<em>F1、F2、F8或F11</em><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>进入电脑主板<em>Bios</em>，在<em>Bios</em>中找到高级选项，再往下移至<em>Inter Virtual Technol</em>，按回车键<em>ENTER</em>，选择<em>Enable</em>；继续再高级选项下找<em>VT-d</em>，再按回车键<em>ENTER</em>，选择<em>Enable</em>；最后保存并退出，开机。</p><h2 id="3-3开启虚拟机平台">3.3开启虚拟机平台</h2><p>同时按下<em>WIN+R</em>键打开运行窗口，输入<em>OptionalFeatures</em>，打开windows功能,勾选<em>Windows虚拟机监控程序平台</em>和<em>虚拟机平台</em>，最后重启电脑。</p><hr><h1>4.安装Linux系统</h1><p>打开<em>VMware workstation player</em>软件，选择<em>创建新的虚拟机</em>，在<em>安装程序光盘映像文件</em>中选择下载好的Linux发行版的 <em>.iso</em>文件，然后填写虚拟机的名称，以及该Linux系统的用户名和密码，<em>磁盘空间大小</em>一般分配20G，<em>自定义硬件</em>里一般将<em>内存</em>提至1-2G，<em>处理器核数</em>一般用1-2个，配置基本完成后就可以给安装好Linux系统的虚拟机开机了。</p><hr><h1>5.给虚拟机配置网络</h1><h2 id="5-1查看虚拟机IP地址">5.1查看虚拟机IP地址</h2><p>打开装有Linux系统虚拟机的<em>终端</em>，输入命令<code>ifconfig</code>，在<em>ens33</em>那块找到<em>inet</em>，<em>inet</em>后面的一串数字即为该虚拟机的<em>IPv4地址</em>。</p><h2 id="5-2">5.2</h2><p>在Windows系统同时按住<em>Win+R</em>键输入<em>cmd</em>打开<em>cmd终端</em>，在<em>cmd终端</em>中输入<code>ping 192.168...</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>且保证<em>cmd终端</em>中未显示有<em>数据包</em>丢失。</p><hr><blockquote><p>参考资料:<a href="https://kb.vmware.com/s/article/1003944?lang=zh_cn">https://kb.vmware.com/s/article/1003944?lang=zh_cn</a><br>参考视频:<a href="https://www.bilibili.com/video/BV1h94y1k7Jf?vd_source=5015a9256ea5937110eb7b6ee3e408f7">https://www.bilibili.com/video/BV1h94y1k7Jf?vd_source=5015a9256ea5937110eb7b6ee3e408f7</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>若使用Windows10或11的操作系统，则VMware-workstation-player软件版本尽量在16以上，否则虚拟机开机时会一直蓝屏 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>不同电脑进入Bios的方法不同，具体情况请自行查找 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>ping后面的192.168…为虚拟机的IPv4地址 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 仅适用于Windows </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Hexo+Github搭建一个自己的博客</title>
      <link href="/CuteFox_Home.github.io/2023/08/05/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/CuteFox_Home.github.io/2023/08/05/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\CuteFox_Home.github.io\assets\css\APlayer.min.css"><script src="\CuteFox_Home.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\CuteFox_Home.github.io\assets\js\Meting.min.js"></script><h1>1.准备搭建环境</h1><p>(1)安装适用于Windows系统的Git<br><a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>若无法下载，则下载并安装淘宝镜像版的Git<br><a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">https://registry.npmmirror.com/binary.html?path=git-for-windows/</a></p><p>(2)安装适用于Windows系统的NodeJs环境(建议使用 Node.js 12.0 及以上版本)<br><a href="https://nodejs.org/zh-cn/download">https://nodejs.org/zh-cn/download</a><br>若无法下载，则下载并安装淘宝镜像版的NodeJs<br><a href="https://registry.npmmirror.com/binary.html?path=node/">https://registry.npmmirror.com/binary.html?path=node/</a></p><p>(3)安装适用于Windows系统的VSCode编译器<br><a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p><h5 id="注1：若安装淘宝镜像版nodejs，则输入命令时需用cnpm而非npm"><em>注1：若安装淘宝镜像版nodejs，则输入命令时需用cnpm而非<s>npm</s></em></h5><h5 id="注2：在Windows自带的PowerShell里输入node-v和git-version查看NodeJs和Git是否安装成功"><em>注2：在Windows自带的PowerShell里输入<code>node -v</code>和<code>git version</code>查看NodeJs和Git是否安装成功</em></h5><hr><h1>2.获取SSH公钥</h1><p>(1)创建github账号<br><a href="https://github.com/">https://github.com/</a></p><p>(2)获取本地密钥<br>首先打开 <em>Git Bash</em> ，输入<code>cd ~/.ssh</code>，再输入<code>ls</code>，检查是否有 <em>id_</em> 开头的名字，如果没有则可以创建SSH密钥<br>继续使用 <em>Git Bash</em> 输入<code>ssh-keygen -t ed25519 -C "your_email@example.com"</code><br>一般不设置密码，就一直回车 (<em>enter</em>) 直到出现有图案出现<br>然后再次输入<code>ls</code>，复制有以 <em>id_</em> 开头 <em>pub</em> 结尾的名字，输入<code>cat id_...pub</code>，将得到的SSH公钥内容复制下来</p><p>(3)将SSH公钥绑定gitHub<br>进入github个人页面，点击右上角的头像，在弹出界面找到设置一栏，点击设置再找到 <em>SHH and GPG keys</em><br>点击 <em>SHH and GPG keys</em> ，将复制的SSH公钥内容填进下面方框中，再设置公钥名字并保存</p><h5 id="注1：your-email-example-com替换为自己注册github账号所使用的邮箱"><em>注1：your_email@example.com替换为自己注册github账号所使用的邮箱</em></h5><h5 id="注2：id-…pub替换为自己复制的名字"><em>注2：id_…pub替换为自己复制的名字</em></h5><hr><h1>3.安装Hexo</h1><p>(1)安装 <em>Hexo-CLI</em><br>打开 <em>PowerShell</em> 输入<code>npm install -g hexo-cli</code></p><p>(2)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(3)安装Hexo包并创建文件夹 <em>package</em> ( <em>package</em> 为文件夹名可修改)<br>在 <em>PowerShell</em> 中输入<code>hexo init package</code></p><p>(4)进入文件夹 <em>package</em><br>在 PowerShell* 中输入<code>cd package</code></p><p>(5)再次安装一遍，确保所有的包都安装完成<br>在 <em>PowerShell</em> 中输入<code>npm install</code></p><hr><h1>4.创建网站页面并运行服务器</h1><p>(1)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(2)生成静态网页文件<br>在 <em>PowerShell</em> 中输入<code>hexo g</code></p><p>(3)运行本地服务器<br>在 <em>PowerShell</em> 中输入<code>hexo s</code><br>在返回信息中我们可以得到 <a href="https://localhost:4000">https://localhost:4000</a> 这个端口，输入这个端口链接在浏览器中就能看到网页了</p><hr><h1>5.写作</h1><p>(1)新建一篇文章 <em>title</em> ( <em>title</em> 为标题可修改)<br>在 <em>PowerShell</em> 中输入<code>hexo new "title"</code></p><p>(2)再次生成静态网页文件<br>在 <em>PowerShell</em> 中输入<code>hexo g</code></p><p>(3)再次运行本地服务器<br>在 <em>PowerShell</em> 中输入<code>hexo s</code></p><hr><h1>6.部署网页在github上</h1><p>(1)在github上创建新的仓库<br>点击github右上角的 <em>加号(+)</em> ，选择新建存储库，然后输入自己的项目名字，且在名字后面一定要加上<br><em>.github.io</em> 后缀，还有README初始化也要勾上，最后点击创建即可</p><p>(2)获取SSH链接<br>点击刚刚创建的库上的 <em>code</em> ，选择 <em>SSH</em> ，复制 <em>SSH</em> 下面的内容</p><p>(3)安装插件在本地<br>在 <em>PowerShell</em> 中输入<code>npm install hexo-deployer-git --save</code></p><p>(4)检查插件是否安装成功<br>在 <em>PowerShell</em> 中输入<code>npm list hexo-deployer-git</code></p><p>(5)配置 <em>_config.yml</em> 文件<br>进入 <em>package</em> 文件夹，找到 <em>_config.yml</em> 件，选中它用VSCode打开，往下翻并找到<br><em>deploy:</em> 和 <em>type:</em> ，在 <em>type:</em> 后面写上 <em>git</em> ，并换行写上 <em>repo:</em> ，再在 <em>repo:</em> 后面<br>粘贴上复制好的SSH链接并保存</p><p>(6)绕过执行策略的限制<br>在 <em>PowerShell</em> 中输入<code>powershell -ExecutionPolicy Bypass</code></p><p>(7)将生成的网站部署到github仓库中<br>在 <em>PowerShell</em> 中输入<code>hexo d</code></p><p>(8)改变部署仓库分支<br>打开 <em>_config.yml</em> 文件，在 <em>repo:</em> 下面写上 <em>branch:</em> ，在 <em>branch:</em> 后面写上想要的分支的名字并保存</p><p>(9)再次部署更新内容到github仓库中<br>在 <em>PowerShell</em> 中输入<code>hexo d</code></p><p>(10)用github页面打开网站<br>在gitHub项目仓库页面的搜索栏下面有一个设置，点击设置并其在左下方找到 <em>页面</em> 一栏，点击页面就能看到<br>有 <em><a href="http://github.io">github.io</a></em> 域名的链接，点击链接即可访问我们创建的网站</p><h5 id="注：如果输入hexo-d-遇到错误，则在输入其之前输入git-config-global-credential-helper-wincred"><em>注：如果输入<code>hexo d </code>遇到错误，则在输入其之前输入<code>git config --global credential.helper wincred</code></em></h5><hr><blockquote><p>参考资料:<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a><br><a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p></blockquote><blockquote><p>参考视频:<a href="https://www.youtube.com/watch?v=xvIRGmKWpFM">https://www.youtube.com/watch?v=xvIRGmKWpFM</a></p></blockquote><center><font color="FF3E96">希</font><font color="FF69B4">望</font><font color="FF7F00">这</font><font color="FF82AB">篇</font><font color="FFA07A">文</font><font color="FFB5C5">章</font><font color="FFBBFF">对</font><font color="FFC125">你</font><font color="FFA54F">有</font><font color="FF8C00">帮</font><font color="FF6347">助</font> 🥰</center>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 仅适用于Windows </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
